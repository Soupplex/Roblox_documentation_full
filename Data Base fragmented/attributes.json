{
    "metadata": {},
    "content": "{\n    \"source_filename\": \"attributes.md\",\n    \"metadata\": {\n        \"title\": \"Properties and attributes\",\n        \"description\": \"How to use scripts to manipulate object properties and attributes.\"\n    },\n    \"content\": \"Making experiences interactive often means manipulating object properties and attributes:\\n\\n- Properties are part of the object class. For example, the `Class.BasePart.Anchored` property controls physics for the part. In a track and field experience, you might want to anchor a discus or javelin the instant it lands so that players have a visual indicator of how far it traveled.\\n\\n- Attributes are essentially custom properties that you define. For example, the [Plant](../resources/plant-reference-project.md) reference project uses attributes to set the purchase price for seeds and the maximum plant size that a pot can hold.\\n\\n## Replication order\\n\\nBefore you begin retrieving and manipulating objects, you must have an understanding of replication order.\\n\\nThe Roblox Engine doesn't guarantee the order in which objects (and changes to objects) are replicated from the server to the client, which makes the `Class.Instance:WaitForChild()` method essential for accessing objects in client scripts, particularly objects in the `Class.Workspace`.\\n\\nFor example, if a server script changes a property of some instance in the Workspace and then calls `Class.RemoteEvent:FireAllClients()`, the property change might replicate to the client before or after `Class.RemoteEvent.OnClientEvent` fires. Use the available methods and events to [detect changes](#detect-changes) rather than assuming a change has replicated. Changes of the same type, such as two attribute changes, generally **do** arrive in order.\\n\\nWhen clients first launch an experience, some aspects of replication and script execution are predictable:\\n\\n1. The client loads the contents of `Class.ReplicatedFirst`, such as a loading screen, assets, and scripts.\\n1. `Class.LocalScript|LocalScripts` (and `Class.Script|Scripts` with a `Class.Script.RunContext|RunContext` of `Enum.RunContext.Client|Client`) in `ReplicatedFirst` run. These scripts can safely get objects from `ReplicatedFirst` without using `WaitForChild()`:\\n\\n   ```lua\\n   -- Safe\\n   local ReplicatedFirst = game:GetService(\\\"ReplicatedFirst\\\")\\n   local LoadingScreen = require(ReplicatedFirst.LoadingScreen)\\n   ```\\n\\n   These scripts **can't** safely get objects from other [services](services.md), because they might not have loaded yet:\\n\\n   ```lua\\n   -- Not safe\\n   local ReplicatedStorage = game:GetService(\\\"ReplicatedStorage\\\")\\n   local PickupManager = require(ReplicatedStorage.PickupManager)\\n   ```\\n\\n   You **can** use `WaitForChild()` in these scripts to get objects from other services, but doing so negates the benefits of using `ReplicatedFirst`.\\n\\n1. The client continues loading the rest of the experience.\\n\\n1. When it finishes, the `Class.DataModel.Loaded|game.Loaded` event fires and `Class.DataModel:IsLoaded()|game:IsLoaded()` returns true.\\n\\n1. `LocalScripts` in `Players.Player.PlayerScripts` (copied from `StarterPlayerScripts`) run, as well as client `Scripts` in `Class.ReplicatedStorage`. These scripts can safely get objects from `ReplicatedStorage` without using `WaitForChild()`.\\n\\n1. The player's `Class.Player.Character|Character` model spawns in the experience.\\n\\n1. `LocalScripts` in `Workspace.Character` (copied from `StarterCharacterScripts`) run.\\n\\nIf your experience uses [instance streaming](../workspace/streaming.md) (`Class.Workspace.StreamingEnabled`), some or most objects might not have loaded into the workspace, so using `WaitForChild()` to access workspace objects becomes an even more important safety measure. In particular, see [Stream in](../workspace/streaming.md#stream-in) and [Per-model streaming controls](../workspace/streaming.md#per-model-streaming-controls) for additional information on loading and tuning streaming behavior.\\n\\n## Get objects\\n\\nThe first step to modifying object properties and attributes is to get a reference to the object. The simplest solution is to make the script a child of the object in the **Explorer** and use `script.Parent` to reference the object.\\n\\n<img alt=\\\"A script parented to a model in the Explorer.\\\" src=\\\"../assets/studio/explorer/Script-Parent-Model.png\\\" width=\\\"320\\\" />\\n\\n```lua\\nlocal sign = script.Parent\\n```\\n\\nThe more universal solution is to get the object from a [service](services.md) using methods like `Class.Instance:FindFirstChild()` or `Class.Instance:WaitForChild()`.\\n\\n<img alt=\\\"A Model within a Folder in ReplicatedStorage.\\\" src=\\\"../assets/studio/explorer/Script-Parent-ReplicatedStorage.png\\\" width=\\\"320\\\" />\\n\\n```lua\\nlocal ReplicatedStorage = game:GetService(\\\"ReplicatedStorage\\\")\\n\\nlocal signsFolder = ReplicatedStorage:WaitForChild(\\\"Signs\\\")\\nlocal sign = signsFolder:WaitForChild(\\\"InteractiveSign\\\")\\n```\\n\\n## Modify properties\\n\\nProperties are straightforward to access — just use a `.` after the object reference&nbsp;— although if you're working with a model, you might need to choose an individual part rather than the model itself.\\n\\n<img alt=\\\"A Model within ReplicatedStorage.\\\" src=\\\"../assets/studio/explorer/ReplicatedStorage-Model.png\\\" width=\\\"320\\\" />\\n\\n```lua\\nlocal ReplicatedStorage = game:GetService(\\\"ReplicatedStorage\\\")\\nlocal chair = ReplicatedStorage:WaitForChild(\\\"Chair\\\")\\n\\nchair.LeftArmRest.Size = Vector3.new(10, 1, 10)\\n```\\n\\n## Create attributes\\n\\nAlthough you can create attributes programmatically, the more common solution is to create them with default values in the Studio user interface. Then you can use scripts to modify their values in response to player actions.\\n\\n<img alt=\\\"A script within a folder in ReplicatedStorage.\\\" src=\\\"../assets/studio/properties/Attributes-Example.png\\\" width=\\\"320\\\" />\\n\\nFor information on creating attributes in Studio, see [Instance attributes](../studio/properties.md#instance-attributes).\\n\\n## Set attributes\\n\\nTo modify an attribute's value, call `Class.Instance:SetAttribute()` with a name and value.\\n\\n```lua title=\\\"Create or Modify Attribute\\\"\\nlocal cabbage = script.Parent\\n\\ncabbage:SetAttribute(\\\"Harvestable\\\", true)\\n```\\n\\nIf the attribute doesn't already exist, this method creates it.\\n\\n## Get attribute values\\n\\nTo get the value of one existing attribute, call `Class.Instance:GetAttribute()` on the instance.\\n\\n```lua title=\\\"Get Attribute Value\\\"\\nlocal cabbage = script.Parent\\n\\ncabbage:SetAttribute(\\\"Harvestable\\\", true)\\n\\nlocal isHarvestable = cabbage:GetAttribute(\\\"Harvestable\\\")\\nprint(isHarvestable) --> true\\n```\\n\\nSimilarly, you can get all attributes by calling `Class.Instance:GetAttributes()`. This method returns a dictionary of key-value pairs.\\n\\n```lua title=\\\"Get All Attributes\\\"\\nlocal cabbage = script.Parent\\n\\nlocal cabbageAttributes = cabbage:GetAttributes()\\n\\nprint(cabbageAttributes.GrowthRate) --> 2\\n\\nfor k, v in cabbageAttributes do\\n\\tprint(k, v)\\nend\\n```\\n\\n## Delete attributes\\n\\nTo delete an attribute, set its value to `nil`.\\n\\n```lua title=\\\"Delete Attribute\\\"\\nlocal cabbage = script.Parent\\n\\ncabbage:SetAttribute(\\\"GrowthRate\\\", nil)\\n```\\n\\n## Detect changes\\n\\nThere are several ways to listen for changes to properties and attributes:\\n\\n- The `Class.Instance.AttributeChanged` event listens for changes to any attribute and passes the name of the changed attribute as a parameter.\\n- The `Class.Instance:GetPropertyChangedSignal()` method lets you listen for changes to one property and passes no parameters.\\n- The `Class.Instance:GetAttributeChangedSignal()` method lets you listen for changes to one attribute and passes no parameters.\\n\\nDue to the minimal information that these events and methods pass as parameters, all of them are a good fit for anonymous functions, particularly `Class.Instance:GetPropertyChangedSignal()` and `Class.Instance:GetAttributeChangedSignal()`. To learn more about anonymous functions and working with events, see [Events](events/index.md).\\n\\n```lua title=\\\"Listen for Changes\\\"\\nlocal cabbage = script.Parent\\n\\n-- Local functions\\nlocal function onAnyPropertyChange(property)\\n\\t-- Ignore changes to attributes\\n\\tif property ~= \\\"Attributes\\\" then\\n\\t\\tprint(property) --> Name\\n\\t\\tprint(cabbage[property]) --> Cabbage1\\n\\tend\\nend\\n\\nlocal function onAnyAttributeChange(attribute)\\n\\tprint(attribute) --> Grow, GrowthRate\\n\\tprint(cabbage:GetAttribute(attribute)) --> false, 3\\nend\\n\\n-- Listen for changes and connect to local functions\\ncabbage.Changed:Connect(onAnyPropertyChange)\\ncabbage.AttributeChanged:Connect(onAnyAttributeChange)\\n\\n-- Listen for changes and connect to anonymous functions\\ncabbage:GetPropertyChangedSignal(\\\"Name\\\"):Connect(function()\\n\\tprint(cabbage.Name) --> Cabbage1\\nend)\\ncabbage:GetAttributeChangedSignal(\\\"GrowthRate\\\"):Connect(function()\\n\\tprint(cabbage:GetAttribute(\\\"GrowthRate\\\")) --> 3\\nend)\\n\\n-- Fires Changed and GetPropertyChangedSignal()\\ncabbage.Name = \\\"Cabbage1\\\"\\n\\n-- Fires Changed and AttributeChanged\\ncabbage:SetAttribute(\\\"Grow\\\", false)\\n\\n-- Fires Changed, AttributeChanged, and GetAttributeChangedSignal()\\ncabbage:SetAttribute(\\\"GrowthRate\\\", 3)\\n```\"\n}"
}