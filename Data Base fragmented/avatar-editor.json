{
    "metadata": {},
    "content": "{\n    \"source_filename\": \"avatar-editor.md\",\n    \"metadata\": {\n        \"title\": \"Avatar Editor Service\",\n        \"description\": \"The Avatar Editor Service allows access to a user's avatar and inventory and Marketplace.\"\n    },\n    \"content\": \"The Avatar Editor Service lets you access and make changes to a user's avatar within an experience. The Avatar Editor Service can also access a user's inventory and the [Marketplace](https://www.roblox.com/catalog) to save outfits and purchase avatar items to the user's account.\\n\\nWe recommend implementing the Avatar Editor Service with an in-game avatar editor for a complete character customization experience. See the [Simple Avatar Editor Demo](https://www.roblox.com/games/9376329300/Simple-Avatar-Editor-Demo) reference place for an example of this feature.\\n\\nTo begin using the Avatar Editor Service, you must first [request access](#request-access) to the user's inventory. After access is successfully granted, you can perform the following actions:\\n\\n- [Read user's inventory](#read-user-inventory) to get a list of items owned by the user.\\n- [Search the Marketplace](#search-the-marketplace), using a variety of properties to filter and sort.\\n- [Equip avatar items and save outfits](#save-avatars-and-outfits) to the user's avatar.\\n- [Prompt the user to purchase](#purchase-items) an Marketplace item.\\n\\n## Request access\\n\\nTo begin accessing a user's inventory, you need to prompt the user to allow access through `Class.AvatarEditorService:PromptAllowInventoryReadAccess()|PromptAllowInventoryReadAccess()`. You need to perform this request once per session.\\n\\nUse the following code sample to initiate the access prompt and listen for the user response:\\n\\n```lua\\nlocal AvatarEditorService = game:GetService(\\\"AvatarEditorService\\\")\\n\\nAvatarEditorService:PromptAllowInventoryReadAccess()\\n\\nlocal result = AvatarEditorService.PromptAllowInventoryReadAccessCompleted:Wait()\\n\\nif result == Enum.AvatarPromptResult.Success then\\n  -- Access granted!\\nend\\n```\\n\\nThe user receives the following prompt:\\n\\n<img src=\\\"../assets/avatar/avatar-editor-service/Avatar-Editor-Access-Items.png\\\" width=\\\"400\\\" />\\n\\nOnce the user accepts the prompt, the `Class.AvatarEditorService` can begin accessing the user's inventory.\\n\\n## Read user inventory\\n\\nOnce access is granted by the user, you can read their inventory with the `Class.AvatarEditorService:GetInventory()|GetInventory()` function, supplying an array of `Enum.AvatarAssetType|AvatarAssetTypes` to filter by. This function returns an `Class.InventoryPages` object containing the user owned items.\\n\\nUse the following code sample to print a list of specific accessories in a user's inventory:\\n\\n```lua\\nlocal AvatarEditorService = game:GetService(\\\"AvatarEditorService\\\")\\n\\nAvatarEditorService:PromptAllowInventoryReadAccess()\\n\\nlocal result = AvatarEditorService.PromptAllowInventoryReadAccessCompleted:Wait()\\n\\nif result == Enum.AvatarPromptResult.Success then\\n  -- Access granted!\\n  local assetTypes = {\\n    Enum.AvatarAssetType.BackAccessory,\\n    Enum.AvatarAssetType.ShoulderAccessory,\\n    Enum.AvatarAssetType.WaistAccessory\\n  }\\n  local pagesObject = AvatarEditorService:GetInventory(assetTypes)\\n  local currentPage = pagesObject:GetCurrentPage()\\n  for _, item in currentPage do\\n    print(item)\\n  end\\nend\\n```\\n\\n## Search the Marketplace\\n\\n`Class.AvatarEditorService` includes functions and events which let you search the Roblox catalog. To search, supply your query with a `Datatype.CatalogSearchParams` object that includes one or more of the following properties:\\n\\n<table>\\n<thead>\\n  <tr>\\n    <th>Property</th>\\n    <th>Description</th>\\n  </tr>\\n</thead>\\n<tbody>\\n  <tr>\\n    <td>AssetTypes</td>\\n    <td>An array of `Enum.AvatarAssetType` such as Enum.AvatarAssetType.BackAccessory.</td>\\n  </tr>\\n  <tr>\\n    <td>BundleTypes</td>\\n    <td>An array of `Enum.BundleType` such as Enum.BundleType.BodyParts.</td>\\n  </tr>\\n  <tr>\\n    <td>CategoryFilter</td>\\n    <td>A `Enum.CatalogCategoryFilter` describing the various catalog categories like \\\"Featured\\\" or \\\"Community Creations\\\". By default this is set to `Enum.CatalogCategoryFilter.None`</td>\\n  </tr>\\n  <tr>\\n    <td>MaxPrice</td>\\n    <td>An integer describing the maximum price to filter.</td>\\n  </tr>\\n  <tr>\\n    <td>MinPrice</td>\\n    <td>An integer describing the minimum price to filter. By default, MinPrice is <b>0</b>.</td>\\n  </tr>\\n  <tr>\\n    <td>SearchKeyword</td>\\n    <td>A string to query against item descriptions in the catalog.</td>\\n  </tr>\\n  <tr>\\n    <td>SortType</td>\\n    <td>A `Enum.CatalogSortType` that describes how the results are ordered. By default this is set to `Enum.CatalogSortType.Relevance`.</td>\\n  </tr>\\n  <tr>\\n    <td>IncludeOffSale</td>\\n    <td>A boolean describing whether the results of the search include off sale items. By default this is set to false.</td>\\n  </tr>\\n  <tr>\\n    <td>CreatorId</td>\\n    <td>An integer to specify a given creator. You can use either a UserId or a GroupId.</td>\\n  </tr>\\n  <tr>\\n  <td>CreatorName</td>\\n    <td>A string used to search by items created by a given creator. You can use either a User Name or a Group Name.</td>\\n  </tr>\\n</tbody>\\n</table>\\n\\nThe following code sample constructs a `Datatype.CatalogSearchParams` object for **Back** and **Shoulder** asset types, and passes that through a `Class.AvatarEditorService:SearchCatalog()|SearchCatalog()` call:\\n\\n```lua\\nlocal AvatarEditorService = game:GetService(\\\"AvatarEditorService\\\")\\n\\nlocal catalogSearchParams = CatalogSearchParams.new()\\nlocal assetTypes = {\\n  Enum.AvatarAssetType.BackAccessory,\\n  Enum.AvatarAssetType.ShoulderAccessory\\n}\\ncatalogSearchParams.AssetTypes = assetTypes\\n\\nlocal pagesObject =\\n--This function returns a CatalogPages object containing the results.\\nAvatarEditorService:SearchCatalog(catalogSearchParams)\\nlocal currentPage = pagesObject:GetCurrentPage()\\nfor _, item in currentPage do\\n  print(item)\\nend\\n```\\n\\n## Save avatars and outfits\\n\\nWhen used alongside an in-game avatar editor, `Class.AvatarEditorService` can save and update avatar items and outfits to the Roblox platform. Users don't receive catalog items they don't own when saving an avatar or outfit.\\n\\nAny `Class.HumanoidDescription` can be saved to the user's current avatar with `Class.AvatarEditorService:PromptSaveAvatar()|PromptSaveAvatar()`. This may include:\\n\\n- Pre-defined avatar configurations that you've built using existing catalog items.\\n- Any configuration that the user has chosen through an in-game avatar editor.\\n\\n<img src=\\\"../assets/avatar/avatar-editor-service/Avatar-Editor-Equip-Items.png\\\" width=\\\"400\\\" />\\n\\nSince `Class.AvatarEditorService:PromptSaveAvatar()` does not yield, you can get the result by listening to the `Class.AvatarEditorService.PromptSaveAvatarCompleted` event.\\n\\nThe following code will save a current `Class.HumanoidDescription` using `Class.AvatarEditorService:PromptSaveAvatar()|PromptSaveAvatar()` and checks for a successful `Class.AvatarEditorService.PromptSaveAvatarCompleted` event:\\n\\n```lua\\nlocal AvatarEditorService = game:GetService(\\\"AvatarEditorService\\\")\\nlocal Players = game:GetService(\\\"Players\\\")\\n\\nlocal player = Players.LocalPlayer\\nlocal character = player.Character or player.CharacterAdded:Wait()\\nlocal humanoid = character:WaitForChild(\\\"Humanoid\\\")\\n\\nlocal currentDescription = humanoid:GetAppliedDescription()\\nAvatarEditorService:PromptSaveAvatar(currentDescription, humanoid.RigType)\\n\\nlocal result = AvatarEditorService.PromptSaveAvatarCompleted:Wait()\\nif result == Enum.AvatarPromptResult.Success then\\n  -- Avatar saved!\\nend\\n```\\n\\nTo save any `Class.HumanoidDescription` as an outfit (without overwriting the user's current avatar), use `Class.AvatarEditorService:PromptCreateOutfit()`.\\n\\n<img src=\\\"../assets/avatar/avatar-editor-service/Avatar-Editor-Save-Outfit.png\\\" width=\\\"400\\\" />\\n\\nOnce called, you can get the result of `Class.AvatarEditorService:PromptCreateOutfit()` by listening to the `Class.AvatarEditorService.PromptCreateOutfitCompleted` event.\\n\\nThe following code sample creates an outfit with `Class.AvatarEditorService:PromptCreateOutfit()` and listens for a successful `Class.AvatarEditorService.PromptCreateOutfitCompleted` event:\\n\\n```lua\\nlocal AvatarEditorService = game:GetService(\\\"AvatarEditorService\\\")\\nlocal Players = game:GetService(\\\"Players\\\")\\n\\nlocal player = Players.LocalPlayer\\nlocal character = player.Character or player.CharacterAdded:Wait()\\nlocal humanoid = character:WaitForChild(\\\"Humanoid\\\")\\n\\nlocal currentDescription = humanoid:GetAppliedDescription()\\nAvatarEditorService:PromptCreateOutfit(currentDescription, humanoid.RigType)\\n\\nlocal result = AvatarEditorService.PromptCreateOutfitCompleted:Wait()\\nif result == Enum.AvatarPromptResult.Success then\\n  -- Outfit saved!\\nend\\n```\\n\\n## Purchase items\\n\\nWhen saving either an avatar or an outfit that uses catalog items, the user doesn't receive any items that they do not own. Before saving an avatar or outfit, check if the user owns the asset with `Class.MarketplaceService:PlayerOwnsAsset()` and provide them with an option to purchase the item with `Class.MarketplaceService:PromptPurchase()`.\\n\\nIf you don't wish to implement item purchases, you can instead allow users to favorite non-owned items with `Class.AvatarEditorService:PromptSetFavorite()`.\\n\\n<Alert severity=\\\"info\\\">\\n Be aware that you can't earn Robux <a href=\\\"../marketplace/marketplace-fees-and-commissions.md#commissions\\\">commissions</a> if the user decides to purchase those items outside of your experience.\\n</Alert>\"\n}"
}