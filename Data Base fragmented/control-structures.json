{
    "title": "Control structures",
    "description": "Control structures are statements that manage the flow of Luau code execution.",
    "content": "Control structures are statements that manage the flow of Luau code execution. There are four main types of control structures:\n\n- An if then else statement executes code only if a specified condition is true. The code execution doesn't repeat.\n- A while loop executes code only if a specified condition is true, and repeats execution while the condition remains true.\n- A repeat loop executes code, and repeats execution if the condition is true.\n- A for loop executes code a set number of times depending on specified inputs.\n\nThe condition for if statements, while loops, and repeat loops can be any Luau expression or value. If a value isn't false or nil, then Luau evaluates it as true in conditional statements. Unlike other scripting languages, Luau considers both zero and the empty string as true.\n\nIf statements\n\nThe basic if statement tests its condition. If the condition is true, then Luau executes the code between then and end.\n\nYou can use an elseif statement to test for additional conditions if the if condition is false. You can use an else statement to execute code if all if and elseif conditions fail. The elseif and else parts are both optional, but you can't use either without an initial if statement.\n\nIn a chain of if, elseif, and else conditions, Luau tests conditions from top to bottom, stops at the first true condition, and executes the code that follows it.\n\nlua\nif 2 + 2 == 5 then\n\tprint(\"Two plus two is five\") -- Doesn't print because the condition is false\nelseif 2 + 3 == 5 then\n\tprint(\"Two plus three is five\") -- Two plus three is five\nelse\n\tprint(\"All conditions failed\") -- Doesn't print because the previous condition is true\nend\n\nWhile loops\n\nA while—do loop evaluates if a specified condition is true or false. If the condition is false or nil, then the loop ends, and Luau skips the code in the loop. If the condition is true, then Luau executes the code in the loop and repeats the process.\n\nlua\nlocal timeRemaining = 10\n\nwhile timeRemaining > 0 do\n\tprint(\"Seconds remaining: \" .. timeRemaining)\n\ttask.wait(1)\n\ttimeRemaining -= 1\nend\n\nprint(\"Timer reached zero!\")\n--[[ Resulting output:\nSeconds remaining: 10\nSeconds remaining: 9\nSeconds remaining: 8\nSeconds remaining: 7\nSeconds remaining: 6\nSeconds remaining: 5\nSeconds remaining: 4\nSeconds remaining: 3\nSeconds remaining: 2\nSeconds remaining: 1\nTimer reached zero!\n]]\n\nInfinite loops\n\nYou can use a while—do loop to write infinite game loops by setting true as the condition.\n\nlua\nwhile true do\n\tprint(\"Looping...\")\n\ttask.wait(0.5)\nend\n\n--[[ Resulting output:\nLooping...\nLooping...\nLooping...\nLooping...\n...\n]]\n\nAlways include a delay such as Library.task.wait() in an infinite loop. Omitting it freezes the experience and crashes Studio.\n\nRepeat loops\n\nThe repeat—until loop repeats until a condition is true. The conditional test evaluates after the code block runs, so the code block always runs at least once. Unlike other languages, the Luau scope of a local variable declared inside a repeat—until loop includes the condition.\n\nlua\nlocal currentGoblinCount = 18\n\n-- Spawn goblins up to a maximum of 25 in the game\nrepeat\n\tspawnGoblin()\n\tcurrentGoblinCount += 1\n\tprint(\"Current goblin count: \" .. currentGoblinCount)\nuntil currentGoblinCount == 25\n\nprint(\"Goblins repopulated!\")\n\n--[[ Resulting output:\nCurrent goblin count: 19\nCurrent goblin count: 20\nCurrent goblin count: 21\nCurrent goblin count: 22\nCurrent goblin count: 23\nCurrent goblin count: 24\nCurrent goblin count: 25\nGoblins repopulated!\n]]\n\nFor loops\n\nA for loop executes code a set number of times, either based on a numerical counter or the number of items in a collection.\n\nNumeric for loops\n\nA for—do loop determines the number of times to execute the loop using a counter. The loop is declared with a start value, end value, and optional increment.\n\nLuau sets the counter equal to the start value, executes the code block in the for loop, then adds the increment to the counter. If the increment is positive, then the process repeats until the counter is equal to or greater than the end value. If the increment is negative, then the process repeats until the counter is equal to or less than the end value.\n\nThe optional increment defaults to 1. It doesn't need to be a whole number.\n\nlua\nfor counter = 1, 3 do\n\tprint(counter)\nend\n\n--[[ Resulting output:\n1\n2\n3\n]]\n\nfor counter = 1, 6, 2 do\n\tprint(counter)\nend\n\n--[[ Resulting output:\n1\n3\n5\n]]\n\nfor counter = 2, 0, -0.5 do\n\tprint(counter)\nend\n\n--[[ Resulting output:\n2\n1.5\n1\n0.5\n0\n]]\n\nGeneric for loops\n\nThe generic for loop iterates over items in a collection rather than a sequence of numbers. With generic for loops, you can execute code for each item in the collection, and can easily use each item in the code.\n\nFor loops need a function, or iterator, to iterate over different types of collections. The global ipairs() returns an iterator for arrays, and the global pairs() returns an iterator for dictionaries. The Library.string library provides Library.string.gmatch() to iterate over strings.\n\nGeneralized iteration\n\nIn Luau, you can iterate over a table using the in keyword directly on the table, instead of using an iterator function such as ipairs():\n\nlua\nfor i, v in {1, 2, 3, 4, 5} do\n\tprint(i, v)\nend\n\nGeneralized iteration also lets you use the iter metamethod to create a custom iterator function. This contrived example iterates over an array in reverse order, from its last element to its first:\n\nlua\nlocal myTable = {1, 2, 3, 4, 5}\n\nmyMetatable = {\n\titer = function(t)\n\t\tlocal i = #t + 1\n\n\t\treturn function()\n\t\t\ti -= 1\n\n\t\t\tif i > 0 then\n\t\t\t\treturn i, t[i]\n\t\t\tend\n\t\tend\n\tend,\n}\n\nsetmetatable(myTable, myMetatable)\n\nfor i, v in myTable do\n\tprint(i, v)\nend\n\n--[[ Resulting output:\n5 5\n4 4\n3 3\n2 2\n1 1\n]]\n\nArrays\n\nThe ipairs() function returns an iterator that iterates through numerical indices in a table and returns an index and value for each element. This makes it appropriate for arrays, where all indices are numeric.\n\nlua\nlocal array = {\"a\", \"b\", \"c\", \"d\", \"e\"}\nfor index, value in ipairs(array) do\n\tprint(index, value)\nend\n\n--[[ Resulting output:\n1 a\n2 b\n3 c\n4 d\n5 e\n]]\n\nDictionaries\n\nThe pairs() function returns an iterator that iterates through all indices (including numerical indices) in a table and returns a key and value for each entry in the dictionary. The order of traversing elements in a dictionary table is arbitrary. This makes it appropriate for iterating over dictionaries, where items are stored out of order with non-numeric indices.\n\nlua\nlocal dictionary = {\n\t[1] = \"a\",\n\t[\"Hello\"] = \"b\",\n\t[5] = \"c\",\n\t[true] = \"d\",\n\t[\"World\"] = \"f\",\n\t[false] = \"e\"\n}\nfor key, value in pairs(dictionary) do\n\tprint(key, value)\nend\n\n--[[ Resulting output:\nHello b\ntrue d\nfalse e\nWorld f\n5 c\n1 a\n]]\n\nBreak loops\n\nTo force a loop to end, use the break keyword. The following code sample shows how to break an infinite while—do loop.\n\nlua\nlocal secondsElapsed = 0\nlocal timeout = 5\n\nwhile true do\n\ttask.wait(1)\n\tsecondsElapsed += 1\n\tprint(\"Seconds elapsed:\", secondsElapsed)\n\n\tif secondsElapsed == timeout then\n\t\tbreak\n\tend\nend\n\nprint(\"Five seconds elapsed. Time to move on!\")\n\n--[[ Resulting output:\n1\n2\n3\n4\n5\nFive seconds elapsed. Time to move on!\n]]\n\nContinue loops\n\nTo force a loop to iterate and start again, use the continue keyword. A for loop will iterate the counter; while and repeat—until will check the loop condition before continuing. The following code sample gets all children of an Class.Instance of a specific Class.Instance.ClassName|ClassName.\n\nlua\nlocal function GetChildrenOfClass(parent: Instance, className: string): {Instance}\n\tlocal children = {}\n\tfor , child in parent:GetChildren() do\n\t\tif child.ClassName ~= className then continue end  -- Iterates the loop\n\t\ttable.insert(children, child)\n\tend\n\n\treturn children\nend",
    "source": "control-structures.md"
}