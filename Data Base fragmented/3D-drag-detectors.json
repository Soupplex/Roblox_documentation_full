{
    "metadata": {},
    "content": "{\n    \"source_filename\": \"3D-drag-detectors.md\",\n    \"metadata\": {\n        \"title\": \"3D drag detectors\",\n        \"description\": \"3D drag detectors facilitate and encourage interaction with 3D objects in an experience, such as opening doors and drawers, sliding a part around, and much more.\"\n    },\n    \"content\": \"The `Class.DragDetector` instance facilitates and encourages interaction with 3D objects in an experience, such as opening doors and drawers, sliding a part around, grabbing and tossing a bowling ball, pulling back and firing a slingshot, and much more. Key features include:\\n\\n- Place a `Class.DragDetector` under any `Class.BasePart` or `Class.Model` to [make it draggable](#make-objects-draggable) via all inputs (mouse, touch, gamepad, and VR), all without a single line of code.\\n\\n- Choose from several [drag styles](#drag-style), define how the object [responds to motion](#response-to-motion), and optionally apply [axis or movement limits](#axis--movement-limits).\\n\\n- Scripts can [respond to manipulation of dragged objects](#script-responses-to-clicking-and-dragging) to drive UI or make logical decisions, such as adjusting the light level in a room based on a sliding wall switch dimmer.\\n\\n- Players can manipulate anchored parts or models and they'll stay exactly where you put them upon release.\\n\\n- `Class.DragDetector|DragDetectors` work in Studio as long as you're **not** using the **Select**, **Move**, **Scale**, or **Rotate** tools, making it easier to test and adjust draggable objects while editing.\\n\\n<video src=\\\"../assets/ui/3D-drag-detectors/Showcase.mp4\\\" controls width=\\\"100%\\\" alt=\\\"Drag detectors used in a variety of implementations in the 3D world\\\"></video>\\n\\n## Make objects draggable\\n\\nTo make any part or model draggable, simply add a `Class.DragDetector` as a direct descendant.\\n\\n1. In the [Explorer](../studio/explorer.md) window, hover over the `Class.Part`, `Class.MeshPart`, or `Class.Model` and click the &CirclePlus; button. A contextual menu displays.\\n1. From the menu, insert a **DragDetector**.\\n\\n   <img src=\\\"../assets/studio/explorer/Model-DragDetector.png\\\" width=\\\"320\\\" />\\n\\n1. By default, the object will now be draggable in the ground plane, but you can customize its `Class.DragDetector.DragStyle|DragStyle`, define how it [responds to motion](#response-to-motion), and optionally apply [axis or movement limits](#axis--movement-limits).\\n\\n<Alert severity=\\\"warning\\\">\\nRemember that `Class.DragDetector|DragDetectors` only work in Studio if you're **not** using the **Select**, **Move**, **Scale**, or **Rotate** tools.\\n</Alert>\\n\\n## Customize drag detectors\\n\\n### Drag style\\n\\n`Class.DragDetector|DragDetectors` map cursor motion to virtual lines and planes to calculate proposed 3D motion. Through the `Class.DragDetector.DragStyle|DragStyle` property, you can choose from different mappings to suit your needs. For example, **TranslatePlane** produces translation in a virtual plane, whereas **RotateAxis** produces rotation about a virtual axis.\\n\\n<table>\\n<thead>\\n  <tr>\\n    <th>Setting</th>\\n    <th>Description</th>\\n  </tr>\\n</thead>\\n<tbody>\\n  <tr>\\n    <td>`Enum.DragDetectorDragStyle.TranslateLine|TranslateLine`</td>\\n    <td>1D motion along the detector's `Class.DragDetector.Axis|Axis`, by default the world **Y** axis.</td>\\n  </tr>\\n  <tr>\\n    <td>`Enum.DragDetectorDragStyle.TranslatePlane|TranslatePlane`</td>\\n    <td>2D motion in the plane perpendicular to the detector's `Class.DragDetector.Axis|Axis`, by default the world **XZ** plane.</td>\\n  </tr>\\n\\t<tr>\\n    <td>`Enum.DragDetectorDragStyle.TranslatePlaneOrLine|TranslatePlaneOrLine`</td>\\n    <td>2D motion in the plane perpendicular to the detector's `Class.DragDetector.Axis|Axis` and, when the [modifier](#modifier-input) is active, 1D motion along the detector's `Class.DragDetector.Axis|Axis`.</td>\\n  </tr>\\n\\t<tr>\\n    <td>`Enum.DragDetectorDragStyle.TranslateLineOrPlane|TranslateLineOrPlane`</td>\\n    <td>1D motion along the detector's `Class.DragDetector.Axis|Axis` and, when the [modifier](#modifier-input) is active, 2D motion in the plane perpendicular to the detector's `Class.DragDetector.Axis|Axis`.</td>\\n  </tr>\\n\\t<tr>\\n    <td>`Enum.DragDetectorDragStyle.TranslateViewPlane|TranslateViewPlane`</td>\\n    <td>2D motion in the plane perpendicular to the camera's view. In this mode, the plane is constantly updated, even while dragging, and will always face the camera's current view.</td>\\n  </tr>\\n\\t<tr>\\n    <td>`Enum.DragDetectorDragStyle.RotateAxis|RotateAxis`</td>\\n    <td>Rotation about the detector's `Class.DragDetector.Axis|Axis`, by default the world **Y** axis.</td>\\n  </tr>\\n\\t<tr>\\n    <td>`Enum.DragDetectorDragStyle.RotateTrackball|RotateTrackball`</td>\\n    <td>Trackball rotation, further customized through the `Class.DragDetector.TrackballRadialPullFactor|TrackballRadialPullFactor` and `Class.DragDetector.TrackballRollFactor|TrackballRollFactor` properties.</td>\\n  </tr>\\n\\t<tr>\\n    <td>`Enum.DragDetectorDragStyle.BestForDevice|BestForDevice`</td>\\n    <td>**TranslatePlaneOrLine** for mouse and gamepad; **TranslatePlane** for touch; **6DOF** for VR.</td>\\n  </tr>\\n\\t<tr>\\n    <td>`Enum.DragDetectorDragStyle.Scriptable|Scriptable`</td>\\n    <td>Calculates desired motion via a custom function provided through `Class.DragDetector:SetDragStyleFunction()|SetDragStyleFunction()`.</td>\\n  </tr>\\n</tbody>\\n</table>\\n\\n### Drag direction\\n\\nBy default, 3D motion and the associated `Class.DragDetector.DragStyle|DragStyle` map to world space. However, you may want to change the `Class.DragDetector.ReferenceInstance|ReferenceInstance`, `Class.DragDetector.Orientation|Orientation`, or `Class.DragDetector.Axis|Axis`, for example when building drag detectors into [models with adjustable parts](#anchored-models-with-adjustable-parts).\\n\\n<table>\\n<thead>\\n  <tr>\\n    <th>Property</th>\\n    <th>Description</th>\\n\\t\\t<th>Default</th>\\n  </tr>\\n</thead>\\n<tbody>\\n  <tr>\\n    <td>`Class.DragDetector.ReferenceInstance|ReferenceInstance`</td>\\n    <td>An instance whose pivot provides the **reference frame** for the drag detector. The `Class.DragDetector.DragFrame|DragFrame` is expressed relative to this reference frame which may be retrieved via `Class.DragDetector:GetReferenceFrame()|GetReferenceFrame()`. If the reference frame is `nil`, translation will be in the direction of (or in the plane perpendicular to) the `Class.DragDetector.Axis|Axis` property in world space.</td>\\n\\t\\t<td>`nil`</td>\\n  </tr>\\n  <tr>\\n    <td>`Class.DragDetector.Orientation|Orientation`</td>\\n    <td>Specifies the **YXZ** rotation of axes of motion relative to the reference frame (does not change the orientation of the reference frame itself). Linear translation and axial rotation will be on this reoriented **Y** axis, and planar translation in the **XZ** plane. Changing this value automatically updates `Class.DragDetector.Axis|Axis` and vice versa.</td>\\n\\t\\t<td>(0,&nbsp;0,&nbsp;0)</td>\\n  </tr>\\n\\t<tr>\\n    <td>`Class.DragDetector.Axis|Axis`</td>\\n    <td>The primary axis of motion, expressed relative to the reference frame. Changing this value automatically updates `Class.DragDetector.Orientation|Orientation` and vice versa.</td>\\n\\t\\t<td>(0,&nbsp;1,&nbsp;0)</td>\\n  </tr>\\n</tbody>\\n</table>\\n\\n### Response to motion\\n\\nThe `Class.DragDetector.ResponseStyle|ResponseStyle` property specifies how an object responds to the proposed motion, depending on whether the object is `Class.BasePart.Anchored|Anchored` or not.\\n\\n<table>\\n<thead>\\n  <tr>\\n    <th>Setting</th>\\n    <th>Anchored behavior</th>\\n\\t\\t<th>Unanchored behavior</th>\\n  </tr>\\n</thead>\\n<tbody>\\n  <tr>\\n    <td>`Enum.DragDetectorResponseStyle.Geometric|Geometric`</td>\\n    <td>Both inside the running experience and in Studio edit mode, the position/orientation of an anchored object will be updated to exactly reflect the proposed motion.</td>\\n\\t\\t<td>For an unanchored object, behavior is the same as for an anchored object. However, in a running experience, the object will be anchored at the start of the drag and restored to unanchored upon drag release.</td>\\n  </tr>\\n  <tr>\\n    <td>`Enum.DragDetectorResponseStyle.Physical|Physical`</td>\\n    <td>An anchored object will default to **Geometric** behavior, as it is not affected by forces.</td>\\n\\t\\t<td>An unanchored object will be moved by [constraint forces](#physics-response) that attempt to bring it to the desired position and/or orientation given by the proposed motion. </td>\\n  </tr>\\n\\t<tr>\\n    <td>`Enum.DragDetectorResponseStyle.Custom|Custom`</td>\\n    <td>The object will not move at all, but `Class.DragDetector.DragFrame|DragFrame` will still be updated and you can [respond to drag manipulation](#script-responses-to-clicking-and-dragging) however you'd like.</td>\\n\\t\\t<td>(same as anchored)</td>\\n  </tr>\\n</tbody>\\n</table>\\n\\n<Alert severity=\\\"warning\\\">\\nRemember that `Class.DragDetector|DragDetectors` only work in Studio if you're **not** using the **Select**, **Move**, **Scale**, or **Rotate** tools.\\n</Alert>\\n\\n### Axis & movement limits\\n\\nBy default, there are no limits to 3D motion beyond the inherent restrictions of the `Class.DragDetector.DragStyle|DragStyle`. If necessary, you can apply minimum and maximum limits to both translation and rotation. Note, however, that these are **not** constraints; they merely impede the drag detector's attempts to generate motion in order to remain within limits.\\n\\n<table>\\n<thead>\\n  <tr>\\n    <th>Properties</th>\\n    <th>Description</th>\\n\\t\\t<th>Default</th>\\n  </tr>\\n</thead>\\n<tbody>\\n  <tr>\\n    <td>`Class.DragDetector.MinDragTranslation|MinDragTranslation`<br />\\n\\t\\t`Class.DragDetector.MaxDragTranslation|MaxDragTranslation`</td>\\n    <td>Limits to drag translation in each dimension. If MaxDragTranslation is greater than MinDragTranslation, translation will be clamped within that range.</td>\\n\\t\\t<td>(0,&nbsp;0,&nbsp;0)</td>\\n  </tr>\\n  <tr>\\n    <td>`Class.DragDetector.MinDragAngle|MinDragAngle`<br />\\n\\t\\t`Class.DragDetector.MaxDragAngle|MaxDragAngle`</td>\\n    <td>Only relevant if `Class.DragDetector.DragStyle|DragStyle` is set to **RotateAxis**. If `Class.DragDetector.MaxDragAngle|MaxDragAngle` is greater than `Class.DragDetector.MinDragAngle|MinDragAngle`, rotation will be clamped within that range.</td>\\n\\t\\t<td>0</td>\\n  </tr>\\n</tbody>\\n</table>\\n\\n<Alert severity=\\\"warning\\\">\\nWhen using axis/movement limits, you should always set the detector's `Class.DragDetector.ReferenceInstance|ReferenceInstance` so that the limits are relative to a dedicated reference frame. If you fail to establish the reference frame, each drag of the object will reset its limits to its own current world space position/orientation.\\n</Alert>\\n\\n### Drag permissions\\n\\nPermission of players to interact with a given drag detector instance can be specified by the `Class.DragDetector.PermissionPolicy|PermissionPolicy` property. This is set to `Enum.DragDetectorPermissionPolicy.Everybody` by default, and it can also be changed to support scripted permission controls as shown in the code sample.\\n\\n<table>\\n<thead>\\n  <tr>\\n    <th>Setting</th>\\n    <th>Description</th>\\n  </tr>\\n</thead>\\n<tbody>\\n  <tr>\\n    <td>`Enum.DragDetectorPermissionPolicy.Nobody|Nobody`</td>\\n    <td>No players can interact with the `Class.DragDetector`.</td>\\n  </tr>\\n  <tr>\\n    <td>`Enum.DragDetectorPermissionPolicy.Everybody|Everybody`</td>\\n    <td>All players can interact with the `Class.DragDetector`.</td>\\n  </tr>\\n  <tr>\\n    <td>`Enum.DragDetectorPermissionPolicy.Scriptable|Scriptable`</td>\\n    <td>Players' drag permissions will be determined by a function registered through `Class.DragDetector:SetPermissionPolicyFunction()|SetPermissionPolicyFunction()`. Under this setting, failure to register a function or returning an invalid result will prevent all players from dragging.</td>\\n  </tr>\\n</tbody>\\n</table>\\n\\n```lua title=\\\"DragDetector - Scripted Drag Permission\\\"\\nlocal dragDetector = script.Parent.DragDetector\\ndragDetector.PermissionPolicy = Enum.DragDetectorPermissionPolicy.Scriptable\\n\\ndragDetector:SetPermissionPolicyFunction(function(player, part)\\n\\tif player and player:GetAttribute(\\\"IsInTurn\\\") then\\n\\t\\treturn true\\n\\telseif part and not part:GetAttribute(\\\"IsDraggable\\\") then\\n\\t\\treturn false\\n\\telse\\n\\t\\treturn true\\n\\tend\\nend)\\n```\\n\\n### Physics response\\n\\nAssuming a dragger's [response style](#response-to-motion) is set to **Physical** and it is applied to an unanchored object, that object will be moved by constraint forces that attempt to bring it to the position/orientation given by the proposed motion. You can further customize the physical response through the following properties:\\n\\n<table>\\n<thead>\\n  <tr>\\n    <th>Property</th>\\n    <th>Description</th>\\n\\t\\t<th>Default</th>\\n  </tr>\\n</thead>\\n<tbody>\\n  <tr>\\n    <td>`Class.DragDetector.ApplyAtCenterOfMass|ApplyAtCenterOfMass`</td>\\n    <td>When false, drag force is applied at the point the user clicks on. When true, force is applied at the object's center of mass.</td>\\n\\t\\t<td>false</td>\\n  </tr>\\n  <tr>\\n    <td>`Class.DragDetector.MaxForce|MaxForce`</td>\\n    <td>Maximum force applied for the object to reach its goal.</td>\\n\\t\\t<td>10000000</td>\\n  </tr>\\n\\t<tr>\\n    <td>`Class.DragDetector.MaxTorque|MaxTorque`</td>\\n    <td>Maximum torque applied for the object to reach its goal.</td>\\n\\t\\t<td>10000</td>\\n  </tr>\\n\\t<tr>\\n    <td>`Class.DragDetector.Responsiveness|Responsiveness`</td>\\n    <td>Higher values cause the object to reach its goal more rapidly.</td>\\n\\t\\t<td>10</td>\\n  </tr>\\n</tbody>\\n</table>\\n\\n### Modifier input\\n\\nSome `Class.DragDetector.DragStyle|DragStyle` modes allow users to hold down a **modifier** key/button to manipulate the dragged object in different ways. By default, the modifier is `Enum.KeyCode|LeftControl` on PC, `Enum.KeyCode|ButtonR1` on gamepad, or `Enum.KeyCode|ButtonL2` on VR. You can customize these modifiers through the `Class.DragDetector.KeyboardModeSwitchKeyCode|KeyboardModeSwitchKeyCode`, `Class.DragDetector.GamepadModeSwitchKeyCode|GamepadModeSwitchKeyCode`, or `Class.DragDetector.VRSwitchKeyCode|VRSwitchKeyCode` properties of the drag detector instance.\\n\\n### Replication\\n\\nWhen the `Class.DragDetector.RunLocally|RunLocally` property is false (default), the client interprets all input to produce data that it sends to the server to perform the drag. In this mode, all custom event signals and registered functions must be in server `Class.Script|Scripts`.\\n\\nWhen the `Class.DragDetector.RunLocally|RunLocally` property is true, no events are replicated to the server. All custom event signals and registered functions must be in client `Class.LocalScript|LocalScripts` and you must use [remote events](../scripting/events/remote.md) to propagate necessary changes to the server.\\n\\n## Script responses to clicking and dragging\\n\\nThrough [event signals](#event-signals), property changes, `Enum.DragDetectorDragStyle.Scriptable|Scriptable` drag style, and custom functions, scripts can respond to the manipulation of dragged objects to drive UI or make logical decisions, such as adjusting the light level in a room based on a sliding wall switch dimmer.\\n\\n### Event signals\\n\\nThrough the following event signals, you can detect when a user starts, continues, and ends dragging an object.\\n\\n<table>\\n<thead>\\n  <tr>\\n    <th>Event</th>\\n    <th>Description</th>\\n  </tr>\\n</thead>\\n<tbody>\\n  <tr>\\n    <td>`Class.DragDetector.DragStart|DragStart`</td>\\n    <td>Fires when a user starts dragging the object.</td>\\n  </tr>\\n  <tr>\\n    <td>`Class.DragDetector.DragContinue|DragContinue`</td>\\n    <td>Fires when a user continues dragging the object after `Class.DragDetector.DragStart|DragStart` has been initiated.</td>\\n  </tr>\\n\\t<tr>\\n    <td>`Class.DragDetector.DragEnd|DragEnd`</td>\\n    <td>Fires when a user stops dragging the object.</td>\\n  </tr>\\n</tbody>\\n</table>\\n\\n```lua title=\\\"DragDetector - Event Signals\\\" highlight=\\\"7,9,11,13,15,17\\\"\\nlocal dragDetector = script.Parent.DragDetector\\n\\nlocal highlight = Instance.new(\\\"Highlight\\\")\\nhighlight.Enabled = false\\nhighlight.Parent = script.Parent\\n\\ndragDetector.DragStart:Connect(function()\\n\\thighlight.Enabled = true\\nend)\\n\\ndragDetector.DragContinue:Connect(function()\\n\\nend)\\n\\ndragDetector.DragEnd:Connect(function()\\n\\thighlight.Enabled = false\\nend)\\n```\\n\\n### Drag frame changes\\n\\nIn addition to [event signals](#event-signals), you can monitor changes to the detector's `Class.DragDetector.DragFrame|DragFrame` directly.\\n\\n```lua title=\\\"DragDetector - DragFrame Changes\\\" highlight=\\\"3,6\\\"\\nlocal dragDetector = script.Parent.DragDetector\\n\\ndragDetector:GetPropertyChangedSignal(\\\"DragFrame\\\"):Connect(function()\\n\\tlocal currentDragTranslation = dragDetector.DragFrame.Position\\n\\tprint(currentDragTranslation)\\nend)\\n```\\n\\n### Scripted drag style\\n\\nIf you set a detector's `Class.DragDetector.DragStyle|DragStyle` to **Scriptable**, you can provide your own function that takes in a `Datatype.Ray` and returns a world space `Datatype.CFrame`. The detector will move the motion so that the dragged object goes to that custom location/orientation.\\n\\n```lua title=\\\"DragDetector - Scripted DragStyle\\\" highlight=\\\"2,7,31,32,34\\\"\\nlocal Workspace = game:GetService(\\\"Workspace\\\")\\n\\nlocal dragDetector = script.Parent.DragDetector\\ndragDetector.DragStyle = Enum.DragDetectorDragStyle.Scriptable\\n\\nlocal cachedHitPoint = Vector3.zero\\nlocal cachedHitNormal = Vector3.yAxis\\n\\nlocal function followTheCursor(cursorRay)\\n\\t-- Exclude dragged object from raycast detection\\n\\tlocal raycastParams = RaycastParams.new()\\n\\traycastParams.FilterDescendantsInstances = {dragDetector.Parent}\\n\\traycastParams.FilterType = Enum.RaycastFilterType.Exclude\\n\\n\\tlocal hitPoint = Vector3.zero\\n\\tlocal hitNormal = Vector3.yAxis\\n\\n\\tlocal raycastResult = Workspace:Raycast(cursorRay.Origin, cursorRay.Direction, raycastParams)\\n\\tif raycastResult then\\n\\t\\thitPoint = raycastResult.Position\\n\\t\\thitNormal = raycastResult.Normal.Unit\\n\\telse\\n\\t\\thitPoint = cachedHitPoint\\n\\t\\thitNormal = cachedHitNormal\\n\\tend\\n\\n\\tcachedHitPoint = hitPoint\\n\\tcachedHitNormal = hitNormal\\n\\n\\tlocal lookDir1 = hitNormal:Cross(Vector3.xAxis)\\n\\tlocal lookDir2 = hitNormal:Cross(Vector3.yAxis)\\n\\tlocal lookDir = if lookDir1.Magnitude > lookDir2.Magnitude then lookDir1.Unit else lookDir2.Unit\\n\\treturn CFrame.lookAt(hitPoint, hitPoint + lookDir, hitNormal)\\nend\\n\\ndragDetector:SetDragStyleFunction(followTheCursor)\\n```\\n\\n### Custom constraint function\\n\\nDrag detectors do not have built-in motion rules about grids and snapping, but you can register custom constraint functions to edit the detector's `Class.DragDetector.DragFrame|DragFrame` before it is applied. For example, you can keep motion on a grid by rounding positions to multiples of the grid increment, or simulate a chess game with rules of motion legal to each piece.\\n\\n```lua title=\\\"DragDetector - Custom Constraint Function\\\" highlight=\\\"4,14,27,28,30\\\"\\nlocal dragDetector = script.Parent.DragDetector\\nlocal startPartPosition = nil\\n\\nlocal SNAP_INCREMENT = 4\\n\\ndragDetector.DragStart:Connect(function()\\n\\tstartPartPosition = script.Parent.Position\\nend)\\n\\ndragDetector.DragEnd:Connect(function()\\n\\tstartPartPosition = nil\\nend)\\n\\nlocal function snapToWorldGrid(proposedMotion)\\n\\tif startPartPosition == nil then\\n\\t\\treturn proposedMotion\\n\\tend\\n\\tlocal snapIncrement = SNAP_INCREMENT // 1\\n\\tif snapIncrement < 1 then\\n\\t\\treturn proposedMotion\\n\\tend\\n\\tlocal newWorldPosition = startPartPosition + proposedMotion.Position\\n\\tlocal roundedX = ((newWorldPosition.X / snapIncrement + 0.5) // 1) * snapIncrement\\n\\tlocal roundedY = ((newWorldPosition.Y / snapIncrement + 0.5) // 1) * snapIncrement\\n\\tlocal roundedZ = ((newWorldPosition.Z / snapIncrement + 0.5) // 1) * snapIncrement\\n\\tlocal newRoundedWorldPosition = Vector3.new(roundedX, roundedY, roundedZ)\\n\\treturn proposedMotion.Rotation + (newRoundedWorldPosition - startPartPosition)\\nend\\n\\nlocal connection = dragDetector:AddConstraintFunction(2, snapToWorldGrid)\\n-- When applicable, remove the constraint function by invoking connection:Disconnect()\\n```\\n\\n## Example usage\\n\\n### Unanchored physical objects\\n\\nA basic implementation of drag detectors is a tower balance game where players must carefully remove pieces and attempt to keep the tower upright. In the following tower structure, each piece has a child `Class.DragDetector` with a default `Class.DragDetector.DragStyle|DragStyle` of **TranslatePlane** so that players can pull the pieces outward but not upward or downward.\\n\\n<video src=\\\"../assets/ui/3D-drag-detectors/Balance-Tower.mp4\\\" controls width=\\\"800\\\" alt=\\\"Drag detectors placed on each piece of a tower balance game\\\"></video>\\n\\n### Anchored models with adjustable parts\\n\\nYou can easily create and share models which are primarily anchored, but which have one or more child parts/models that players can drag. For example, the following desk has two drawers which players can open to inspect what's inside.\\n\\n<video src=\\\"../assets/ui/3D-drag-detectors/Desk-Drawers.mp4\\\" controls width=\\\"800\\\" alt=\\\"Drag detectors placed on the drawers of a desk to allow for opening/sliding\\\"></video>\\n\\n<Alert severity=\\\"warning\\\">\\nWhen making children of models draggable, you should set the drag detector's `Class.DragDetector.ReferenceInstance|ReferenceInstance` to an object within the model that can serve as a dedicated reference frame, for example the desk's top surface. This establishes a consistent reference `Datatype.CFrame` for the style/direction of dragging, even if the model is rotated.\\n</Alert>\\n\\n### Drag detectors and constraints\\n\\nYou can combine drag detectors with `Class.Constraint|Constraints`, for example a marionette puppet. In the following setup, the control handles are anchored, the body parts are unanchored, and constraints hold the marionette together. Moving the handles with the **TranslateViewPlane** `Class.DragDetector.DragStyle|DragStyle` makes the marionette dance, and the individual body parts may also be moved with drag detectors, all while the model retains its integrity.\\n\\n<video src=\\\"../assets/ui/3D-drag-detectors/Marionette.mp4\\\" controls width=\\\"800\\\" alt=\\\"Drag detectors placed on the handles of a marionette puppet\\\"></video>\\n\\n### 3D user interfaces\\n\\n3D user interfaces are easily achievable through drag detectors, such as adjusting the brightness of a `Class.SpotLight` based on a sliding switch dimmer. You can also detect the **X** and **Z** axes individually to control two different aspects of a 3D user interface, such as the `Class.ParticleEmitter.Size|Size`, `Class.ParticleEmitter.Speed|Speed`, and `Class.ParticleEmitter.Color|Color` of a `Class.ParticleEmitter`.\\n\\n<video src=\\\"../assets/ui/3D-drag-detectors/Color-Slider.mp4\\\" controls width=\\\"800\\\" alt=\\\"Drag detectors used in 3D user interface to control a particle emitter\\\"></video>\\n\\n```lua title=\\\"DragDetector - 3D User Interface\\\"\\nlocal model = script.Parent\\nlocal slider = model.SliderPart\\nlocal originPart = model.OriginPart\\nlocal emitter = script.Parent.EmitterPart.ParticleEmitter\\n\\nlocal dragDetector = slider.DragDetector\\ndragDetector.ReferenceInstance = originPart\\ndragDetector.MinDragTranslation = Vector3.zero\\ndragDetector.MaxDragTranslation = Vector3.new(10, 0, 10)\\n\\nlocal dragRangeX = dragDetector.MaxDragTranslation.X - dragDetector.MinDragTranslation.X\\nlocal dragRangeZ = dragDetector.MaxDragTranslation.Z - dragDetector.MinDragTranslation.Z\\n\\nlocal MIN_PARTICLE_SIZE = 1\\nlocal MAX_PARTICLE_SIZE = 1.5\\nlocal MIN_PARTICLE_SPEED = 2.5\\nlocal MAX_PARTICLE_SPEED = 5\\nlocal COLOR1 = Color3.fromRGB(255, 150, 0)\\nlocal COLOR2 = Color3.fromRGB(255, 0, 50)\\n\\nlocal function updateParticles(emitter)\\n\\tlocal dragFactorX = (dragDetector.DragFrame.Position.X - dragDetector.MinDragTranslation.X) / dragRangeX\\n\\tlocal dragFactorZ = (dragDetector.DragFrame.Position.Z - dragDetector.MinDragTranslation.Z) / dragRangeZ\\n\\n\\t-- Adjust particle size and speed based on drag detector X factor\\n\\temitter.Size = NumberSequence.new{\\n\\t\\tNumberSequenceKeypoint.new(0, 0),\\n\\t\\tNumberSequenceKeypoint.new(0.1, MIN_PARTICLE_SIZE + ((MAX_PARTICLE_SIZE - MIN_PARTICLE_SIZE) * dragFactorX)),\\n\\t\\tNumberSequenceKeypoint.new(1, 0)\\n\\t}\\n\\tlocal speed = MIN_PARTICLE_SPEED + ((MAX_PARTICLE_SPEED - MIN_PARTICLE_SPEED) * dragFactorX)\\n\\temitter.Speed = NumberRange.new(speed, speed * 1.2)\\n\\t-- Adjust particle color based on drag detector Z factor\\n\\tlocal color = COLOR2:Lerp(COLOR1, dragFactorZ)\\n\\temitter.Color = ColorSequence.new{\\n\\t\\tColorSequenceKeypoint.new(0, color),\\n\\t\\tColorSequenceKeypoint.new(1, color)\\n\\t}\\nend\\n\\ndragDetector:GetPropertyChangedSignal(\\\"DragFrame\\\"):Connect(function()\\n\\tupdateParticles(emitter)\\nend)\\n```\"\n}"
}