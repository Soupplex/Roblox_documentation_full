{
    "title": "Camera",
    "description": "",
    "content": "This file is automatically generated. Please don't edit it manually.\nTo submit a bug report on the content, see\nhttps://devforum.roblox.com/c/bug-reports/documentation-issues/72\n\nname: Camera\ntype: class\nmemorycategory: Instances\nsummary: |\n  A class which defines a view of the 3D world.\ndescription: |\n  The Camera object defines a view of the 3D world. In a running experience,\n  each client has its own Camera object which resides in that client's local\n  Class.Workspace, accessible through the Class.Workspace.CurrentCamera\n  property.\n\n  The most important camera properties are:\n\n  - Class.Camera.CFrame|CFrame which represents the position and orientation\n    of the camera.\n\n  - Class.Camera.CameraType|CameraType which is read by the experience's\n    camera scripts and determines how the camera should update each frame.\n\n  - Class.Camera.CameraSubject|CameraSubject which is read by the experience's\n    camera scripts and determines what object the camera should follow.\n\n  - Class.Camera.FieldOfView|FieldOfView which represents the visible extent\n    of the observable world.\n\n  - Class.Camera.Focus|Focus which represents the point the camera is looking\n    at. It's important this property is set, as certain visuals will be more\n    detailed and will update more frequently depending on how close they are to\n    the focus point.\n\n  See Customizing the Camera for more\n  information on how to adjust and customize the camera's behavior.\n\n  #### Storing Multiple Cameras\n\n  Note that when changing Class.Workspace.CurrentCamera to a new\n  Class.Camera, all other Class.Camera|Cameras directly descending from\n  Class.Workspace will be destroyed. If you need to store multiple cameras and\n  swap between them on demand, it's recommended that you store them in a\n  Class.Folder or Class.Model under Class.Workspace, inside which they\n  will remain even when Class.Workspace.CurrentCamera|CurrentCamera is\n  changed.\ncodesamples: []\ninherits:\n  - PVInstance\ndescendants: []\ntags:\n  - NotReplicated\ndeprecationmessage: ''\nproperties:\n  - name: Camera.CameraSubject\n    summary: |\n      The Class.Humanoid or Class.BasePart that is the Class.Camera\n      subject.\n    description: |\n      CameraSubject accepts a variety of Class.Instance|Instances. The\n      default camera scripts respond differently to the available settings:\n\n      - By default, the camera scripts follow the local character's\n        Class.Humanoid, factoring in the humanoid's current state and\n        Class.Humanoid.CameraOffset.\n\n      - When set to a Class.BasePart, the camera scripts follow its position,\n        with a vertical offset in the case of Class.VehicleSeat|VehicleSeats.\n\n      CameraSubject cannot be set to nil. Attempting to do so will revert it\n      to its previous value.\n\n      To restore CameraSubject to its default value, set it to the local\n      character's Class.Humanoid:\n\n      lua\n      local Players = game:GetService(\"Players\")\n      local Workspace = game:GetService(\"Workspace\")\n\n      local localPlayer = Players.LocalPlayer\n      local camera = Workspace.CurrentCamera\n\n      local function resetCameraSubject()\n      \tif camera and localPlayer.Character then\n      \t\tlocal humanoid = localPlayer.Character:FindFirstChildWhichIsA(\"Humanoid\")\n      \t\tif humanoid then\n      \t\t\tcamera.CameraSubject = humanoid\n      \t\tend\n      \tend\n      end\n\n    codesamples: []\n    type: Instance\n    tags: []\n    deprecationmessage: ''\n    security:\n      read: None\n      write: None\n    threadsafety: ReadSafe\n    category: Camera\n    serialization:\n      canload: true\n      cansave: true\n    capabilities:\n      - Basic\n  - name: Camera.CameraType\n    summary: |\n      Specifies the Enum.CameraType to be read by the camera scripts.\n    description: |\n      The default Roblox camera scripts have several built-in behaviors. Setting\n      this property toggles between the various Enum.CameraType behaviors.\n      Note that some camera types require a valid\n      Class.Camera.CameraSubject|CameraSubject to work correctly.\n\n      The default camera scripts will not move or update the camera if\n      CameraType is set to Enum.CameraType.Scriptable. For more information\n      on positioning and orienting the camera manually, see\n      Class.Camera.CFrame|CFrame.\n\n      For all CameraType settings except Enum.CameraType.Scriptable, the\n      Class.Camera.CameraSubject|CameraSubject property represents the object\n      whose position the camera's Class.Camera.Focus|Focus is set to.\n    codesamples: []\n    type: CameraType\n    tags: []\n    deprecationmessage: ''\n    security:\n      read: None\n      write: None\n    threadsafety: ReadSafe\n    category: Camera\n    serialization:\n      canload: true\n      cansave: true\n    capabilities:\n      - Basic\n  - name: Camera.CFrame\n    summary: |\n      The Datatype.CFrame of the Class.Camera, defining its position and\n      orientation in the 3D world.\n    description: |\n      This property is the Datatype.CFrame of the Class.Camera, defining its\n      position and orientation in the 3D world. Note that some transformations,\n      such as the rotation of the head when using VR devices, are not reflected\n      in this property, so you should use\n      Class.Camera:GetRenderCFrame()|GetRenderCFrame() to obtain the \"true\"\n      Datatype.CFrame of the camera.\n\n      You can move the camera by setting this property. However, the default\n      camera scripts also set it, so you should either:\n\n      - Set the camera Class.Camera.CameraType|CameraType to\n        Enum.CameraType.Scriptable so that the default camera scripts will not\n        update the camera's Datatype.CFrame. This method is simplest and\n        recommended in most cases.\n\n      - Completely replace the default camera scripts with alternatives. This\n        approach is only recommended if you do not need any default camera\n        functionality.\n\n      The most intuitive way to position and orient the Class.Camera is by\n      using the Datatype.CFrame.lookAt() constructor. In the following\n      example, the Class.Camera is positioned at\n      Datatype.Vector3.new(0, 10, 0) and is oriented to be looking towards\n      Datatype.Vector3.new(10, 0, 0).\n\n      lua\n      local Workspace = game:GetService(\"Workspace\")\n\n      local camera = Workspace.CurrentCamera\n      camera.CameraType = Enum.CameraType.Scriptable\n\n      local pos = Vector3.new(0, 10, 0)\n      local lookAtPos = Vector3.new(10, 0, 0)\n\n      Workspace.CurrentCamera.CFrame = CFrame.lookAt(pos, lookAtPos)\n\n\n      Although the camera can be placed in the manner demonstrated above, you\n      may want to animate it to move smoothly from one Datatype.CFrame to\n      another. For this, you can either:\n\n      - Set the camera's position/orientation every frame with\n        Class.RunService:BindToRenderStep() and the Datatype.CFrame:Lerp()\n        method.\n      - Create and play a Class.Tween that animates the position/orientation\n        of the camera:\n\n        lua\n        local Players = game:GetService(\"Players\")\n        local TweenService = game:GetService(\"TweenService\")\n        local Workspace = game:GetService(\"Workspace\")\n\n        local camera = Workspace.CurrentCamera\n        camera.CameraType = Enum.CameraType.Scriptable\n\n        local player = Players.LocalPlayer\n        local character = player.Character\n        if not character or character.Parent == nil then\n        \tcharacter = player.CharacterAdded:Wait()\n        end\n\n        local pos = camera.CFrame  Vector3.new(0, 20, 0)\n        local lookAtPos = character.PrimaryPart.Position\n        local targetCFrame = CFrame.lookAt(pos, lookAtPos)\n\n        local tween = TweenService:Create(camera, TweenInfo.new(2), {CFrame = targetCFrame})\n\n        tween:Play()\n\n    codesamples: []\n    type: CFrame\n    tags: []\n    deprecationmessage: ''\n    security:\n      read: None\n      write: None\n    threadsafety: ReadSafe\n    category: Data\n    serialization:\n      canload: true\n      cansave: true\n    capabilities:\n      - Basic\n  - name: Camera.CoordinateFrame\n    summary: ''\n    description: |\n      The old version of the Class.Camera.CFrame|CFrame property which\n      functions identically to it.\n\n      This item should be used in a Class.LocalScript in order to work as\n      expected online.\n    codesamples: []\n    type: CFrame\n    tags:\n      - Hidden\n      - NotReplicated\n      - Deprecated\n    deprecationmessage: |\n      This item has been superseded by Class.Camera.CFrame which should be\n      used in all new work.\n    security:\n      read: None\n      write: None\n    threadsafety: ReadSafe\n    category: Data\n    serialization:\n      canload: true\n      cansave: false\n    capabilities:\n      - Basic\n  - name: Camera.DiagonalFieldOfView\n    summary: |\n      Sets the angle of the camera's diagonal field of view.\n    description: |\n      Sets how many degrees in the diagonal direction (from one corner of the\n      viewport to its opposite corner) the camera can view. See\n      Class.Camera.FieldOfView|FieldOfView for a more general explanation of\n      field of view.\n\n      Note that DiagonalFieldOfView represents the field of view that is\n      visible by the Class.Camera rendering into the fullscreen area which may\n      be occluded by notches or screen cutouts on some devices. See\n      Class.Camera.ViewportSize|ViewportSize for more information.\n    codesamples: []\n    type: float\n    tags:\n      - NotReplicated\n    deprecationmessage: ''\n    security:\n      read: None\n      write: None\n    threadsafety: ReadSafe\n    category: Camera\n    serialization:\n      canload: false\n      cansave: false\n    capabilities:\n      - Basic\n  - name: Camera.FieldOfView\n    summary: |\n      Sets the angle of the camera's vertical field of view.\n    description: |\n      The FieldOfView (FOV) property sets how many degrees in the vertical\n      direction the camera can view. This property is clamped between 1 and\n      120 degrees and defaults at 70. Very low or very high fields of view\n      are not recommended as they can be disorientating to players.\n\n      Note that uniform scaling is enforced, meaning the vertical and horizontal\n      field of view are always related by the aspect ratio of the screen.\n\n      Suggested uses for FieldOfView include:\n\n      - Reducing FOV to give the impression of magnification, for example when\n        using binoculars.\n      - Increasing FOV when the player is \"sprinting\" to give the impression of\n        a lack of control.\n\n      Note that FieldOfView represents the field of view that is visible by\n      the Class.Camera rendering into the fullscreen area which may be\n      occluded by notches or screen cutouts on some devices. See\n      Class.Camera.ViewportSize|ViewportSize for more information.\n    codesamples: []\n    type: float\n    tags: []\n    deprecationmessage: ''\n    security:\n      read: None\n      write: None\n    threadsafety: ReadSafe\n    category: Camera\n    serialization:\n      canload: true\n      cansave: true\n    capabilities:\n      - Basic\n  - name: Camera.FieldOfViewMode\n    summary: |\n      Determines the FOV value of the Class.Camera that's invariant under\n      viewport size changes.\n    description: |\n      The camera's Class.Camera.FieldOfView|FieldOfView (FOV) must be updated\n      to reflect Class.Camera.ViewportSize|ViewportSize changes. The value of\n      FieldOfViewMode determines which FOV value will be kept constant.\n\n      For example, when this property is set to Enum.FieldOfViewMode.Vertical,\n      the horizontal FOV is updated when the viewport is resized, but the\n      vertical FOV is kept constant. If this property is set to\n      Enum.FieldOfViewMode.Diagonal, both horizontal and vertical FOV might be\n      changed to keep the diagonal FOV constant.\n    codesamples: []\n    type: FieldOfViewMode\n    tags: []\n    deprecationmessage: ''\n    security:\n      read: None\n      write: None\n    threadsafety: ReadSafe\n    category: Camera\n    serialization:\n      canload: true\n      cansave: true\n    capabilities:\n      - Basic\n  - name: Camera.Focus\n    summary: |\n      Sets the area in 3D space that is prioritized by Roblox's graphical\n      systems.\n    description: |\n      Certain graphical operations the engine performs, such as updating\n      lighting, can take time or computational effort to complete. The camera's\n      Focus property tells the engine which area in 3D space to prioritize\n      when performing such operations. For example, dynamic lighting from\n      objects such as Class.PointLight|PointLights may not render at distances\n      far from the focus.\n\n      The default Roblox camera scripts automatically set Focus to follow the\n      Class.Camera.CameraSubject|CameraSubject (usually a Class.Humanoid).\n      However, Focus will not automatically update when\n      Class.Camera.CameraType|CameraType is set to\n      Enum.CameraType.Scriptable or when the default camera scripts are not\n      being used. In these cases, you should update Focus every frame, using\n      Class.RunService:BindToRenderStep() method at the\n      Enum.RenderPriority.Camera priority.\n\n      Focus has no bearing on the position or orientation of the camera; see\n      Class.Camera.CFrame|CFrame for this.\n    codesamples: []\n    type: CFrame\n    tags: []\n    deprecationmessage: ''\n    security:\n      read: None\n      write: None\n    threadsafety: ReadSafe\n    category: Data\n    serialization:\n      canload: true\n      cansave: true\n    capabilities:\n      - Basic\n  - name: Camera.focus\n    summary: ''\n    description: ''\n    codesamples: []\n    type: CFrame\n    tags:\n      - NotReplicated\n      - Deprecated\n    deprecationmessage: |\n      This property is a deprecated variant of Class.Camera.Focus|Focus which\n      should be used instead.\n    security:\n      read: None\n      write: None\n    threadsafety: ReadSafe\n    category: Data\n    serialization:\n      canload: true\n      cansave: false\n    capabilities:\n      - Basic\n  - name: Camera.HeadLocked\n    summary: |\n      Toggles whether the camera will automatically track the head motion of a\n      player using a VR device.\n    description: |\n      Toggles whether the camera will automatically track the head motion of a\n      player using a VR device. When true (default), the engine combines\n      Class.Camera.CFrame|CFrame with the Enum.UserCFrame of the user's head\n      to render the player's view with head tracking factored in. The view will\n      be rendered at the following Datatype.CFrame:\n\n      lua\n      local UserInputService = game:GetService(\"UserInputService\")\n      local Workspace = game:GetService(\"Workspace\")\n\n      local camera = Workspace.CurrentCamera\n\n      local headCFrame = UserInputService:GetUserCFrame(Enum.UserCFrame.Head)\n      headCFrame = headCFrame.Rotation + headCFrame.Position  camera.HeadScale\n\n      -- This will be equivalent to Camera:GetRenderCFrame()\n      local renderCFrame = camera.CFrame  headCFrame\n\n\n      It is recommended to not disable this property for the following\n      reasons:\n\n      - Players may experience motion sickness if an equivalent head tracking\n        solution is not added.\n      - The Roblox Engine performs latency optimizations when HeadLocked is\n        true.\n\n      ##### See Also\n\n      - Class.VRService:GetUserCFrame() which can be used to obtain the\n        Datatype.CFrame of the head.\n      - Class.VRService:RecenterUserHeadCFrame() which is used to recenter the\n        head to the current position and orientation of the VR device.\n      - The Class.Camera:GetRenderCFrame()|GetRenderCFrame() method which\n        returns the Class.Camera.CFrame|CFrame combined with the\n        Datatype.CFrame of the user's head.\n    codesamples: []\n    type: boolean\n    tags: []\n    deprecationmessage: ''\n    security:\n      read: None\n      write: None\n    threadsafety: ReadSafe\n    category: Data\n    serialization:\n      canload: true\n      cansave: true\n    capabilities:\n      - Basic\n  - name: Camera.HeadScale\n    summary: |\n      Sets the scale of the user's perspective of the world when using VR.\n    description: |\n      HeadScale is the scale of the user's perspective of the world when using\n      VR.\n\n      The size of 1 stud in VR is 0.3 meters / HeadScale, meaning that larger\n      HeadScale values equate to the world looking smaller from the user's\n      perspective when using VR devices. For example, a part that's 1 stud tall\n      appears to be 0.6 meters tall to a VR player with a HeadScale of 0.5.\n\n      This property is automatically controlled by\n      Class.VRService.AutomaticScaling to align the player's perspective with\n      the size of their avatar. If you intend to control HeadScale yourself or\n      use custom characters, toggle Class.VRService.AutomaticScaling to\n      Enum.VRScaling.Off.\n\n      This property should not be confused with Class.Humanoid.HeadScale which\n      is a Class.NumberValue parented to a Class.Humanoid to control its\n      scaling.\n    codesamples: []\n    type: float\n    tags: []\n    deprecationmessage: ''\n    security:\n      read: None\n      write: None\n    threadsafety: ReadSafe\n    category: Data\n    serialization:\n      canload: true\n      cansave: true\n    capabilities:\n      - Basic\n  - name: Camera.MaxAxisFieldOfView\n    summary: |\n      Sets the angle of the camera's field of view along the longest viewport\n      axis.\n    description: |\n      The MaxAxisFieldOfView property sets how many degrees along the longest\n      viewport axis the camera can view.\n\n      When the longest axis is the vertical axis, this property will behave\n      similar to the Class.Camera.FieldOfView|FieldOfView property. This is\n      generally the case when a device is in a portrait orientation. In a\n      landscape orientation, the longest axis will be the horizontal axis; in\n      this case, the property describes the horizontal field of view of the\n      Class.Camera.\n    codesamples: []\n    type: float\n    tags:\n      - NotReplicated\n    deprecationmessage: ''\n    security:\n      read: None\n      write: None\n    threadsafety: ReadSafe\n    category: Camera\n    serialization:\n      canload: false\n      cansave: false\n    capabilities:\n      - Basic\n  - name: Camera.NearPlaneZ\n    summary: |\n      Describes the negative Z offset, in studs, of the camera's near\n      clipping plane.\n    description: |\n      The NearPlaneZ property describes how far away the camera's near\n      clipping plane is, in studs. The near clipping plane is a geometric plane\n      that sits in front of the camera's Class.Camera.CFrame|CFrame. Anything\n      between this plane and the camera will not render, creating a cutaway view\n      when viewing objects at very short distances. The value of NearPlaneZ\n      varies across different platforms and is currently always between -0.1\n      and -0.5.\n\n\n    codesamples: []\n    type: float\n    tags:\n      - ReadOnly\n      - NotReplicated\n    deprecationmessage: ''\n    security:\n      read: None\n      write: None\n    threadsafety: ReadSafe\n    category: Data\n    serialization:\n      canload: false\n      cansave: true\n    capabilities:\n      - Basic\n  - name: Camera.ViewportSize\n    summary: |\n      The dimensions of the device safe area on a Roblox client.\n    description: |\n      ViewportSize returns the dimensions of the device safe area on the\n      current screen. This area is a rectangle which includes the Roblox top bar\n      area but does not include any device notches or screen cutouts. The units\n      of ViewportSize are Roblox UI offset units which may be different from\n      native display pixels.\n\n\n\n      As noted above, ViewportSize is not equal to the fullscreen area size on\n      displays with cutouts or notches. To obtain the fullscreen area size on\n      all displays, you can query the\n      Class.ScreenGui.AbsoluteSize|AbsoluteSize property of a\n      Class.ScreenGui with Class.ScreenGui.ScreenInsets|ScreenInsets set to\n      Enum.ScreenInsets.None|None. See Enum.ScreenInsets for a more\n      information about how screen areas are defined.\n\n      Finally, note that ViewportSize is not the actual viewport size the\n      camera uses for rendering (the camera renders in the fullscreen area).\n      Also, the Class.Camera.FieldOfView|FieldOfView and\n      Class.Camera.DiagonalFieldOfView|DiagonalFieldOfView properties are\n      based on the fullscreen area, not ViewportSize.\n\n      ##### Camera Updates\n\n      Only the Class.Camera currently referred to by\n      Class.Workspace.CurrentCamera has its ViewportSize updated each frame\n      during the Class.RunService.PreRender|PreRender step. The ViewportSize\n      of all other cameras in your experience won't be updated, including those\n      used for Class.ViewportFrame|ViewportFrames.\n    codesamples: []\n    type: Vector2\n    tags:\n      - ReadOnly\n      - NotReplicated\n    deprecationmessage: ''\n    security:\n      read: None\n      write: None\n    threadsafety: ReadSafe\n    category: Data\n    serialization:\n      canload: false\n      cansave: true\n    capabilities:\n      - Basic\n  - name: Camera.VRTiltAndRollEnabled\n    summary: |\n      Toggles whether to apply tilt and roll from the\n      Class.Camera.CFrame|CFrame property while the player is using a VR\n      device.\n    description: |\n      This property toggles whether to apply tilt and roll from the\n      Class.Camera.CFrame|CFrame property while the player is using a VR\n      device.\n\n      To prevent motion sickness, the horizon should remain level. Tilting and\n      rolling the player's view while using a VR device can cause a disconnect\n      between the player's physical space and the virtual space they are\n      viewing. Changing the apparent downwards direction can cause players to\n      lose balance or experience dizziness.\n\n      For these reasons, it is generally advisable to leave this property\n      disabled, unless you have extensively tested your experience for these\n      effects. Even with tilt and roll enabled, you may want to ensure the\n      player always has a stable reference frame, such as the interior of a\n      vehicle or a floor that can help the player ground themselves in their\n      physical space.\n    codesamples: []\n    type: boolean\n    tags: []\n    deprecationmessage: ''\n    security:\n      read: None\n      write: None\n    threadsafety: ReadSafe\n    category: Data\n    serialization:\n      canload: true\n      cansave: true\n    capabilities:\n      - Basic\nmethods:\n  - name: Camera:GetLargestCutoffDistance\n    summary: |\n      Returns how much the Class.Camera needs to be pushed towards its\n      Class.Camera.Focus|Focus in order to make sure there is no obstructions\n      between the Class.Camera.Focus|Focus and Class.Camera.CFrame|CFrame.\n    description: |\n      This method is used by PopperCam in the default camera scripts to ensure\n      obstructions do not come between the Class.Camera and its subject.\n\n      This method will check all Class.BasePart|BaseParts and Class.Terrain\n      in the Class.Workspace with the following exceptions:\n\n      - Any Class.Instance specified in the ignoreList (including its\n        descendants) will be ignored\n      - Class.BasePart|BaseParts with Class.BasePart.CanCollide set to false\n        are ignored\n      - Class.BasePart|BaseParts with a Class.BasePart.Transparency greater\n        than 0.95 will be ignored Water Class.Terrain is ignored\n\n      Note, as this method requires an ignoreList to run, you should pass an\n      empty table when none is required.\n    codesamples: []\n    parameters:\n      - name: ignoreList\n        type: Instances\n        default:\n        summary: |\n          An array of Class.Instance|Instances to ignore. Descendants of these\n          instances will also be ignored.\n    returns:\n      - type: float\n        summary: |\n          The distance, in studs, that the Class.Camera needs to be pushed\n          towards its Class.Camera.Focus|Focus to ensure there are no\n          obstructions between the Class.Camera.Focus|Focus and\n          Class.Camera.CFrame|CFrame of the Class.Camera.\n    tags:\n      - Deprecated\n    deprecationmessage: ''\n    security: None\n    threadsafety: Unsafe\n    capabilities:\n      - Basic\n  - name: Camera:GetPanSpeed\n    summary: |\n      Returns the current 'pan' speed of the Class.Camera.\n    description: |\n      This method is broken and should not be used.\n\n      This method returns the current pan speed of the Class.Camera.\n\n      The pan speed of the Class.Camera describes the speed at which the\n      Class.Camera is rotating around its Class.Camera.Focus|Focus around\n      the Y axis.\n    codesamples: []\n    parameters: []\n    returns:\n      - type: float\n        summary: |\n          The speed at which the Class.Camera is rotating around its\n          Class.Camera.Focus|Focus on the Y axis.\n    tags:\n      - Deprecated\n    deprecationmessage: |\n      This method has been deprecated and no longer works. It should not be used\n      in new work.\n    security: None\n    threadsafety: Unsafe\n    capabilities:\n      - Basic\n  - name: Camera:GetPartsObscuringTarget\n    summary: |\n      Returns an array of Class.BasePart|BaseParts that are obscuring the\n      lines of sight between the camera's Class.Camera.CFrame|CFrame and the\n      cast points.\n    description: |\n      This method returns an array of Class.BasePart|BaseParts that are\n      obscuring the lines of sight between the camera's\n      Class.Camera.CFrame|CFrame and Datatype.Vector3 positions in the\n      castPoints array. Any Class.Instance|Instances included in the\n      ignoreList array will be ignored, along with their descendants.\n\n      The castPoints parameter is given as an array of Datatype.Vector3\n      positions. Note that the array of Class.BasePart|BaseParts returned is\n      in an arbitrary order, and no additional raycast data is provided. If you\n      need data such as hit position, hit material, or surface normal, you\n      should opt for the Class.WorldRoot:Raycast() method.\n\n      lua\n      local Workspace = game:GetService(\"Workspace\")\n\n      local camera = Workspace.CurrentCamera\n\n      local castPoints = {\n      \tVector3.new(0, 10, 0),\n      \tVector3.new(0, 15, 0)\n      }\n      local ignoreList = {}\n\n      local partsObscuringTarget = camera:GetPartsObscuringTarget(castPoints, ignoreList)\n\n\n      If Class.Terrain obscures a cast point, Class.BasePart|BaseParts\n      obscuring the cast point between the obscuring Class.Terrain and the\n      cast point will not be returned.\n    codesamples: []\n    parameters:\n      - name: castPoints\n        type: Array\n        default:\n        summary: |\n          An array of Datatype.Vector3 positions of cast points.\n      - name: ignoreList\n        type: Instances\n        default:\n        summary: |\n          An array of Class.Instance|Instances that should be ignored, along\n          with their descendants.\n    returns:\n      - type: Instances\n        summary: |\n          An array of Class.BasePart|BaseParts that obscure the lines of sight\n          between the camera's Class.Camera.CFrame|CFrame and the\n          castPoints.\n    tags: []\n    deprecationmessage: ''\n    security: None\n    threadsafety: Unsafe\n    capabilities:\n      - Basic\n  - name: Camera:GetRenderCFrame\n    summary: |\n      Returns the actual Datatype.CFramewhere the Class.Camera is being\n      rendered, accounting for any roll applied and the impact of VR devices.\n    description: |\n      This method returns the actual Datatype.CFrame of the Class.Camera as\n      it is rendered, including the impact of VR (VR head transformations are\n      not applied to the Class.Camera.CFrame|CFrame property, so it is best\n      practice to use Class.Camera:GetRenderCFrame()|GetRenderCFrame() to\n      obtain the \"true\" Datatype.CFrame of a player's view).\n\n      For example, when using VR, the Class.Camera is actually rendered at the\n      following Datatype.CFrame:\n\n      lua\n      local UserInputService = game:GetService(\"UserInputService\")\n      local Workspace = game:GetService(\"Workspace\")\n\n      local camera = Workspace.CurrentCamera\n\n      local headCFrame = UserInputService:GetUserCFrame(Enum.UserCFrame.Head)\n      headCFrame = headCFrame.Rotation + headCFrame.Position  camera.HeadScale\n      renderCFrame = camera.CFrame  headCFrame\n\n\n      The camera's render Datatype.CFrame will only be changed to account for\n      the head when the Class.Camera.HeadLocked|HeadLocked property is true.\n    codesamples: []\n    parameters: []\n    returns:\n      - type: CFrame\n        summary: |\n          The Datatype.CFrame the Class.Camera is being rendered at.\n    tags: []\n    deprecationmessage: ''\n    security: None\n    threadsafety: Unsafe\n    capabilities:\n      - Basic\n  - name: Camera:GetRoll\n    summary: |\n      Returns in radians the current roll, or rotation around the camera's\n      Z-axis, applied to the Class.Camera using\n      Class.Camera:SetRoll()|SetRoll().\n    description: |\n      This method returns, in radians, the current roll applied to the\n      Class.Camera using Class.Camera:SetRoll()|SetRoll(). Roll is defined\n      as rotation around the camera's Z-axis.\n\n      This method only returns roll applied using the\n      Class.Camera:SetRoll()|SetRoll() method. Roll manually applied to the\n      camera's Class.Camera.CFrame|CFrame is not accounted for. To obtain the\n      actual roll of the Class.Camera, including roll manually applied, you\n      can use the following snippet:\n\n      lua\n      local Workspace = game:GetService(\"Workspace\")\n\n      local function getActualRoll()\n      \tlocal camera = Workspace.CurrentCamera\n\n      \tlocal trueUp = Vector3.new(0, 1, 0)\n      \tlocal cameraUp = camera:GetRenderCFrame().upVector\n\n      \treturn math.acos(trueUp:Dot(cameraUp))\n      end\n\n    codesamples:\n      - Camera-GetRoll1\n    parameters: []\n    returns:\n      - type: float\n        summary: |\n          The current roll applied by Class.Camera:SetRoll()|SetRoll(), in\n          radians.\n    tags: []\n    deprecationmessage: |\n      This method has been deprecated.\n    security: None\n    threadsafety: Unsafe\n    capabilities:\n      - Basic\n  - name: Camera:GetTiltSpeed\n    summary: |\n      Returns the current tilt speed of the Class.Camera.\n    description: |\n      This method is broken and should not be used.\n\n      This method returns the current tilt speed of the Class.Camera.\n\n      The tilt speed of the Class.Camera describes the speed at which the\n      Class.Camera is rotating around its Class.Camera.Focus|Focus around\n      the camera's X axis.\n    codesamples: []\n    parameters: []\n    returns:\n      - type: float\n        summary: |\n          The speed at which the Class.Camera is rotating around its\n          Class.Camera.Focus|Focus around the camera's X axis.\n    tags:\n      - Deprecated\n    deprecationmessage: |\n      This method has been deprecated and no longer works.\n    security: None\n    threadsafety: Unsafe\n    capabilities:\n      - Basic\n  - name: Camera:Interpolate\n    summary: |\n      Tweens the Class.Camera in a linear fashion towards a new\n      Class.Camera.CFrame|CFrame and Class.Camera.Focus|Focus over a given\n      duration.\n    description: |\n      This method tweens the Class.Camera in a linear fashion towards a new\n      Class.Camera.CFrame|CFrame and Class.Camera.Focus|Focus over a given\n      duration, for example:\n\n      lua\n      local Workspace = game:GetService(\"Workspace\")\n\n      local camera = Workspace.CurrentCamera\n      camera.CameraType = Enum.CameraType.Scriptable\n\n      camera:Interpolate(\n      \tCFrame.new(0, 10, 100),\n      \tCFrame.new(0, 0, 100),\n      \t5\n      )\n\n\n      Throughout the tween, the camera's Class.Camera.CFrame|CFrame will be\n      orientated towards the camera's Class.Camera.Focus|Focus.\n\n      When the tween has completed, the camera's\n      Class.Camera.InterpolationFinished|InterpolationFinished event will\n      fire.\n\n      If this method is called while the Class.Camera is already tweening, the\n      older tween will be stopped (without firing\n      Class.Camera.InterpolationFinished|InterpolationFinished) and overridden\n      by the new tween.\n\n      Interpolate can only be used if the current\n      Class.Camera.CameraType|CameraType is Scriptable, regardless of\n      whether the default camera scripts are being used. If it is used with any\n      other Class.Camera.CameraType|CameraType an error will be thrown.\n\n      You are advised to use Class.TweenService to tween the Class.Camera\n      instead as it is more reliable and offers a variety of easing styles. See\n      below for an example:\n\n      lua\n      local TweenService = game:GetService(\"TweenService\")\n      local Workspace = game:GetService(\"Workspace\")\n\n      local camera = Workspace.CurrentCamera\n      camera.CameraType = Enum.CameraType.Scriptable\n\n      local tween = TweenService:Create(\n      \tcamera,\n      \tTweenInfo.new(5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),\n      \t{\n      \t\tCFrame = CFrame.new(0, 10, 100),\n      \t\tFocus = CFrame.new(0, 0, 100)\n      \t}\n      )\n\n      tween:Play()\n\n    codesamples: []\n    parameters:\n      - name: endPos\n        type: CFrame\n        default:\n        summary: |\n          The Datatype.CFrame for the Class.Camera to tween to.\n      - name: endFocus\n        type: CFrame\n        default:\n        summary: |\n          The Datatype.CFrame for the camera's Class.Camera.Focus|Focus to\n          tween to.\n      - name: duration\n        type: float\n        default:\n        summary: |\n          The duration, in seconds, of the tween.\n    returns:\n      - type: ()\n        summary: ''\n    tags:\n      - Deprecated\n    deprecationmessage: |\n      This method has been deprecated. Instead use Class.TweenService to\n      smoothly animate the Class.Camera, see the code snippets below for an\n      example.\n    security: None\n    threadsafety: Unsafe\n    capabilities:\n      - Basic\n  - name: Camera:PanUnits\n    summary: |\n      Pans the Class.Camera around the Class.Camera.Focus|Focus in 45 degree\n      increments around the Y axis.\n    description: |\n      This method pans the Class.Camera around the Class.Camera.Focus|Focus\n      in 45 degree increments around the Y axis.\n\n      The rotation is applied to the camera's Class.Camera.CFrame|CFrame\n      property.\n\n      This method pans the Class.Camera in 45 degree increments, for example:\n\n      lua\n      local Workspace = game:GetService(\"Workspace\")\n\n      Workspace.CurrentCamera:PanUnits(1) -- 45 degrees\n      Workspace.CurrentCamera:PanUnits(-2) -- -90 degrees\n\n\n      PanUnits does not require the Class.Camera.CameraType|CameraType to be\n      Scriptable.\n    codesamples: []\n    parameters:\n      - name: units\n        type: int\n        default:\n        summary: |\n          The number of 45 degree increments by which to pan the Class.Camera.\n    returns:\n      - type: ()\n        summary: ''\n    tags:\n      - Deprecated\n    deprecationmessage: |\n      This method was used for legacy camera controls and has since been\n      deprecated. Do not use in new work.\n    security: None\n    threadsafety: Unsafe\n    capabilities:\n      - Basic\n  - name: Camera:ScreenPointToRay\n    summary: |\n      Creates a unit Datatype.Ray from a position on the screen (in pixels),\n      at a set depth from the Class.Camera orientated in the camera's\n      direction. Accounts for the GUI inset.\n    description: |\n      This method creates a unit Datatype.Ray from a 2D position on the screen\n      (defined in pixels), accounting for the GUI inset. The Datatype.Ray\n      originates from the Datatype.Vector3 equivalent of the 2D position in\n      the world at the given depth (in studs) away from the Class.Camera.\n\n      As this method acknowledges the GUI inset, the offset applied to GUI\n      elements (such as from the top bar) is accounted for. This means the\n      screen position specified will start in the top left corner below the top\n      bar. For an otherwise identical method that does not account for the GUI\n      offset, use Class.Camera:ViewportPointToRay()|ViewportPointToRay().\n\n      As the Datatype.Ray created is a unit ray, it is only one stud long. To\n      create a longer ray, you can do the following:\n\n      lua\n      local Workspace = game:GetService(\"Workspace\")\n\n      local camera = Workspace.CurrentCamera\n      local length = 500\n      local unitRay = camera:ScreenPointToRay(100, 100)\n      local extendedRay = Ray.new(unitRay.Origin, unitRay.Direction  length)\n\n\n      This method only works for the current Class.Workspace camera. Other\n      cameras, such as those you create for a Class.ViewportFrame, have an\n      initial viewport size of (1, 1) and are\n      only updated after you set them to Class.Workspace.CurrentCamera. The\n      mismatch in viewport size causes the camera to return a ray with an\n      incorrect Datatype.Ray.Direction.\n    codesamples: []\n    parameters:\n      - name: x\n        type: float\n        default:\n        summary: |\n          The position on the X axis, in pixels, of the screen point at\n          which to originate the Datatype.Ray. This position accounts for the\n          GUI inset.\n      - name: 'y'\n        type: float\n        default:\n        summary: |\n          The position on the Y axis, in pixels, of the screen point at\n          which to originate the Datatype.Ray. This position accounts for the\n          GUI inset.\n      - name: depth\n        type: float\n        default: 0\n        summary: |\n          The depth from the Class.Camera, in studs, from which to offset the\n          origin of the Datatype.Ray.\n    returns:\n      - type: Ray\n        summary: |\n          A unit Datatype.Ray, originating from the equivalent\n          Datatype.Vector3 world position of the given screen coordinates at\n          the given depth away from the Class.Camera. This ray is orientated\n          in the direction of the Class.Camera.\n    tags: []\n    deprecationmessage: ''\n    security: None\n    threadsafety: Safe\n    capabilities:\n      - Basic\n  - name: Camera:SetCameraPanMode\n    summary: |\n      Sets the Enum.CameraPanMode to be used by the Class.Camera on mobile\n      devices.\n    description: |\n      This method sets the Enum.CameraPanMode to be used by the Class.Camera\n      on mobile devices.\n\n      When the \\'EdgeBump' Enum.CameraPanMode is used, swipe to pan is\n      disabled and the edge bump camera controls are enabled.\n\n      SetCameraPan mode has no effect on Windows or Mac users.\n    codesamples: []\n    parameters:\n      - name: mode\n        type: CameraPanMode\n        default: Classic\n        summary: |\n          The Enum.CameraPanMode to set the Class.Camera to.\n    returns:\n      - type: ()\n        summary: ''\n    tags:\n      - Deprecated\n    deprecationmessage: |\n      This method has been deprecated and should not be used in new work.\n    security: None\n    threadsafety: Unsafe\n    capabilities:\n      - Basic\n  - name: Camera:SetRoll\n    summary: |\n      Sets the current rotation applied around the camera's Z-axis.\n    description: |\n      This method is outdated and no longer considered best practice.\n\n      This method sets the current roll, in radians, of the Class.Camera. The\n      roll is applied after the Class.Camera.CFrame|CFrame and represents the\n      rotation around the camera's Z-axis.\n\n      For example, the following would invert the Class.Camera:\n\n      lua\n      local Workspace = game:GetService(\"Workspace\")\n\n      Workspace.CurrentCamera:SetRoll(math.pi) -- math.pi radians = 180 degrees\n\n\n      SetRoll has no effect on any roll applied using the\n      Class.Camera.CFrame|CFrame property. Roll applied using SetRoll is not\n      reflected in the Class.Camera.CFrame|CFrame property but is reflected in\n      the Datatype.CFrame returned\n      byClass.Camera:GetRenderCFrame()|GetRenderCFrame().\n\n      This method can only be used when the Class.Camera.CameraType|CameraType\n      is set to Scriptable, regardless of whether the default camera scripts\n      are being used. If it is used with any other\n      Class.Camera.CameraType|CameraType a warning is given in the output.\n\n      Any roll applied using this method will be lost when the\n      Class.Camera.CameraType|CameraType is changed from Scriptable.\n\n      To obtain the roll set using this method use\n      Class.Camera:GetRoll()|GetRoll().\n\n      As this method is outdated, you are advised to instead apply roll to the\n      Class.Camera using the Class.Camera.CFrame|CFrame property. For\n      example:\n\n      lua\n      local Workspace = game:GetService(\"Workspace\")\n\n      local currentCFrame = Workspace.CurrentCamera.CFrame\n      local rollCFrame = CFrame.Angles(0, 0, roll)\n      Workspace.CurrentCamera.CFrame = currentCFrame  rollCFrame\n\n    codesamples: []\n    parameters:\n      - name: rollAngle\n        type: float\n        default:\n        summary: |\n          The roll angle, in radians, to be applied to the Class.Camera.\n    returns:\n      - type: ()\n        summary: ''\n    tags: []\n    deprecationmessage: |\n      This method has been deprecated. Instead use the\n      Class.Camera.CFrame|CFrame property to 'roll' the Class.Camera.\n    security: None\n    threadsafety: Unsafe\n    capabilities:\n      - Basic\n  - name: Camera:TiltUnits\n    summary: |\n      Tilts the Class.Camera around its Class.Camera.Focus|Focus in 10\n      degree increments around the camera's X axis.\n    description: |\n      This method tilts the Class.Camera by rotating it around the\n      Class.Camera.Focus|Focus around the camera's X axis by a given\n      multiple of 10 degrees.\n\n      The rotation is applied to the camera's Class.Camera.CFrame|CFrame\n      property and is constrained between -81.05 and 81.05 degrees.\n    codesamples: []\n    parameters:\n      - name: units\n        type: int\n        default:\n        summary: |\n          The number of 10 degree units by which to tilt the Class.Camera.\n    returns:\n      - type: boolean\n        summary: |\n          Whether the Class.Camera tilt applied was constrained.\n    tags:\n      - Deprecated\n    deprecationmessage: |\n      This method was used for legacy camera controls and has been deprecated.\n      Do not use in new work.\n    security: None\n    threadsafety: Unsafe\n    capabilities:\n      - Basic\n  - name: Camera:ViewportPointToRay\n    summary: |\n      Creates a unit Datatype.Ray from a position on the viewport (in pixels),\n      at a given depth from the Class.Camera, orientated in the camera's\n      direction. Does not account for the Enum.ScreenInsets|CoreUISafeInsets\n      inset.\n    description: |\n      This method creates a unit Datatype.Ray from a 2D position in device\n      safe viewport coordinates, defined in pixels. The ray originates from the\n      Datatype.Vector3 equivalent of the 2D position in the world at the given\n      depth (in studs) away from the Class.Camera.\n\n      As illustrated below, (0, 0) corresponds to the topâ€‘left point of the\n      Roblox top bar. This means that the input 2D position does not account\n      for the Enum.ScreenInsets|CoreUISafeInsets inset, but it does account\n      for any Enum.ScreenInsets|DeviceSafeInsets.\n\n\n\n      Note that UI instances use a different coordinate system\n      (Class.GuiObject.AbsolutePosition uses the\n      Enum.ScreenInsets|CoreUISafeInsets viewport coordinate system while this\n      method uses the Enum.ScreenInsets|DeviceSafeInsets viewport coordinate\n      system). If you would like to specify position in core UI coordinates,\n      please use Class.Camera:ScreenPointToRay()|ScreenPointToRay().\n\n      Also note that this method only works for the\n      Class.Workspace.CurrentCamera camera. Other cameras, such as those you\n      create for a Class.ViewportFrame, have an initial viewport size of\n      (1, 1) and are only updated after you set them to\n      Class.Workspace.CurrentCamera|CurrentCamera. The mismatch in viewport\n      size causes the camera to return a ray with an incorrect\n      Datatype.Ray.Direction.\n\n      This method can be used in conjunction with the\n      Class.Camera.ViewportSize|ViewportSize property to create a ray from the\n      centre of the screen, for example:\n\n      lua\n      local Workspace = game:GetService(\"Workspace\")\n\n      local camera = Workspace.CurrentCamera\n\n      local viewportPoint = camera.ViewportSize / 2\n      local unitRay = camera:ViewportPointToRay(viewportPoint.X, viewportPoint.Y, 0)\n\n\n      As the Datatype.Ray created is a unit ray, it is only one stud long. To\n      create a longer ray, you can do the following:\n\n      lua\n      local Workspace = game:GetService(\"Workspace\")\n\n      local camera = Workspace.CurrentCamera\n\n      local length = 500\n      local unitRay = camera:ScreenPointToRay(100, 100)\n      local extendedRay = Ray.new(unitRay.Origin, unitRay.Direction  length)\n\n    codesamples: []\n    parameters:\n      - name: x\n        type: float\n        default:\n        summary: |\n          The position on the X axis, in pixels, of the viewport point at\n          which to originate the Datatype.Ray, in device safe area\n          coordinates.\n      - name: 'y'\n        type: float\n        default:\n        summary: |\n          The position on the Y axis, in pixels, of the viewport point at\n          which to originate the Datatype.Ray, in device safe area\n          coordinates.\n      - name: depth\n        type: float\n        default: 0\n        summary: |\n          The depth from the Class.Camera, in studs, from which to offset the\n          origin of the Datatype.Ray.\n    returns:\n      - type: Ray\n        summary: |\n          A unit Datatype.Ray, originating from the equivalent\n          Datatype.Vector3 world position of the given viewport coordinates at\n          the given depth away from the Class.Camera. This ray is orientated\n          in the direction of the Class.Camera.\n    tags: []\n    deprecationmessage: ''\n    security: None\n    threadsafety: Safe\n    capabilities:\n      - Basic\n  - name: Camera:WorldToScreenPoint\n    summary: |\n      Returns the screen location and depth of a Datatype.Vector3 worldPoint\n      and whether this point is within the bounds of the screen. Accounts for\n      the GUI inset.\n    description: |\n      This method returns the screen location and depth of a Datatype.Vector3\n      worldPoint and whether this point is within the bounds of the screen.\n\n      This method takes in account the current GUI inset, such as the space\n      occupied by the top bar, meaning that the 2D position returned is in the\n      same term as GUI positions and can be used to place GUI elements. For an\n      otherwise identical method that ignores the GUI inset, see\n      Class.Camera:WorldToViewportPoint()|WorldToViewportPoint().\n\n      lua\n      local Workspace = game:GetService(\"Workspace\")\n\n      local camera = Workspace.CurrentCamera\n\n      local worldPoint = Vector3.new(0, 10, 0)\n      local vector, onScreen = camera:WorldToScreenPoint(worldPoint)\n\n      local screenPoint = Vector2.new(vector.X, vector.Y)\n      local depth = vector.Z\n\n\n      Note this method does not perform any raycasting and the boolean\n      indicating whether worldPoint is within the bounds of the screen will be\n      true regardless of whether the point is obscured by\n      Class.BasePart|BaseParts or Class.Terrain.\n    codesamples: []\n    parameters:\n      - name: worldPoint\n        type: Vector3\n        default:\n        summary: |\n          The Datatype.Vector3 world position.\n    returns:\n      - type: Tuple\n        summary: |\n          A tuple containing, in order:\n\n          - A Datatype.Vector3 whose X and Y components represent the\n            offset of the worldPoint from the top left corner of the screen,\n            in pixels. The Datatype.Vector3 Z component represents the\n            depth of the worldPoint from the screen (in studs).\n\n          - A boolean indicating if the worldPoint is within the bounds of the\n            screen.\n    tags: []\n    deprecationmessage: ''\n    security: None\n    threadsafety: Safe\n    capabilities:\n      - Basic\n  - name: Camera:WorldToViewportPoint\n    summary: |\n      Returns the screen location and depth of a Datatype.Vector3 worldPoint\n      and whether this point is within the bounds of the screen. Does not\n      account for the GUI inset.\n    description: |\n      This method returns the screen location and depth of a Datatype.Vector3\n      worldPoint and whether this point is within the bounds of the screen.\n\n      This method does not take in account the current GUI inset, such as the\n      space occupied by the top bar, meaning that the 2D position returned is\n      taken from the top left corner of the viewport. Unless you are using\n      Class.ScreenGui.IgnoreGuiInset, this position is not appropriate for\n      placing GUI elements.\n\n      For an otherwise identical method that accounts for the GUI inset, see\n      Class.Camera:WorldToScreenPoint()|WorldToScreenPoint().\n\n      lua\n      local Workspace = game:GetService(\"Workspace\")\n\n      local camera = Workspace.CurrentCamera\n\n      local worldPoint = Vector3.new(0, 10, 0)\n      local vector, onScreen = camera:WorldToViewportPoint(worldPoint)\n\n      local viewportPoint = Vector2.new(vector.X, vector.Y)\n      local depth = vector.Z\n\n\n      Note this method does not perform any raycasting and the boolean\n      indicating whether worldPoint is within the bounds of the screen will be\n      true regardless of whether the point is obscured by\n      Class.BasePart|BaseParts or Class.Terrain.\n    codesamples: []\n    parameters:\n      - name: worldPoint\n        type: Vector3\n        default:\n        summary: |\n          The Datatype.Vector3 world position.\n    returns:\n      - type: Tuple\n        summary: |\n          A tuple containing, in order:\n\n          - A Datatype.Vector3 whose X and Y components represent the\n            offset of the worldPoint from the top left corner of the viewport,\n            in pixels. The Datatype.Vector3 Z component represents the\n            depth of the worldPoint from the screen (in studs).\n\n          - A boolean indicating if the worldPoint is within the bounds of the\n            screen.\n    tags: []\n    deprecationmessage: ''\n    security: None\n    threadsafety: Safe\n    capabilities:\n      - Basic\n  - name: Camera:ZoomToExtents\n    summary: |\n      Adjusts the Class.Camera.CFrame|CFrame so that the specified bounding\n      box is fully visible within the camera's viewport.\n    description: |\n      This method adjusts the Class.Camera.CFrame|CFrame so that a specified\n      bounding box is fully visible within the camera's viewport, without\n      cropping any part of the box.\n\n      The bounding box is defined by its center and orientation\n      (boundingBoxCFrame) and its size (boundingBoxSize).\n\n      This can be used to focus the camera on a 3D object or model, such as when\n      framing content in a Class.ViewportFrame, taking screenshots, or\n      smoothly transitioning the camera to highlight specific content.\n\n      The method automatically accounts for the camera's field of view and\n      viewport aspect ratio to ensure the entire bounding box fits.\n\n      lua\n      local Workspace = game:GetService(\"Workspace\")\n\n      local camera = Workspace.CurrentCamera\n      local model = Workspace:FindFirstChild(\"MyModel\")\n\n      if model then\n      \tlocal modelCFrame = model:GetModelCFrame()\n      \tlocal extentsSize = model:GetExtentsSize()\n      \tcamera:ZoomToExtents(modelCFrame, extentsSize)\n      end\n\n    codesamples: []\n    parameters:\n      - name: boundingBoxCFrame\n        type: CFrame\n        default:\n        summary: |\n          The Datatype.CFrame representing the center and orientation of the\n          bounding box to fit into the viewport.\n      - name: boundingBoxSize\n        type: Vector3\n        default:\n        summary: |\n          The Datatype.Vector3 size of the bounding box to fit into the\n          viewport.\n    returns:\n      - type: ()\n        summary: ''\n    tags: []\n    deprecationmessage: ''\n    security: None\n    threadsafety: Unsafe\n    capabilities:\n      - Basic\nevents:\n  - name: Camera.InterpolationFinished\n    summary: |\n      Fired when the Class.Camera has finished interpolating\n      usingClass.Camera:Interpolate()|Interpolate().\n    description: |\n      This event fires when the Class.Camera has finished interpolating using\n      the Class.Camera:Interpolate() method. It will not fire if a tween is\n      interrupted due to Class.Camera:Interpolate() being called again.\n\n      You are advised to use Class.TweenService to animate the Class.Camera\n      instead, as it is more reliable and provides more options for easing\n      styles.\n    codesamples: []\n    parameters: []\n    tags: []\n    deprecationmessage: |\n      This event has been deprecated. Instead use Class.TweenService to\n      smoothly animate the Class.Camera.\n    security: None\n    capabilities:\n      - Basic\ncallbacks: []",
    "source": "Camera.yaml"
}