{
    "title": "AvatarCreationService",
    "description": "",
    "content": "This file is automatically generated. Please don't edit it manually.\nTo submit a bug report on the content, see\nhttps://devforum.roblox.com/c/bug-reports/documentation-issues/72\n\nname: AvatarCreationService\ntype: class\nmemorycategory: Instances\nsummary: |\n  A service to support developer avatar creators.\ndescription: |\n  AvatarCreationService is a service that supports developer avatar creators,\n  providing methods that support the prompting of avatar creation from within\n  experiences.\ncodesamples: []\ninherits:\n  - Instance\ndescendants: []\ntags:\n  - NotCreatable\n  - Service\ndeprecationmessage: ''\nproperties: []\nmethods:\n  - name: AvatarCreationService:AutoSetupAvatarAsync\n    summary: |\n      Automatically sets up a custom Class.Model and/or avatar accessories.\n    description: |\n      Automatically sets up a custom Class.Model as an avatar asset. This\n      method returns a string generation ID which can be passed to\n      Class.AvatarCreationService:LoadGeneratedAvatarAsync()|LoadGeneratedAvatarAsync()\n      to load the generated avatar and return a Class.HumanoidDescription with\n      all the generated instances and properties. The load method can be called\n      on both the server and client, allowing the generated avatar to be loaded\n      in both places (on the client for previewing, and on the server for saving\n      the generated avatar to the player's inventory using\n      Class.AvatarCreationService:PromptCreateAvatarAsync()|PromptCreateAvatarAsync()).\n\n      Auto-setup has specific model requirements and accepts certain\n      configurations of models. For more information, see\n      Auto-setup requirements.\n      In addition to the above requirements, the input model must use\n      Class.EditableMesh and Class.EditableImage objects for all mesh and\n      texture assets.\n    codesamples:\n      - AvatarCreationService-AutoSetupAvatarAsync\n    parameters:\n      - name: player\n        type: Player\n        default:\n        summary: |\n          The Class.Player that the avatar is being set up for.\n      - name: autoSetupParams\n        type: Dictionary\n        default:\n        summary: |\n          A table containing the arguments. Type:\n          type AutoSetupAccessory = { AccessoryType: Enum.AccessoryType, IsLayered: bool, Instance: Model, } type AutoSetupParams = { Body: Model?, Accessories: {AutoSetupAccessory}, }\n      - name: progressCallback\n        type: Function?\n        default:\n        summary: |\n          Optional callback function that will be invoked periodically with a\n          progressInfo table with the overall progress (from 0 to 1). Type:\n          (progressInfo: { Progress: number }) -> ()\n    returns:\n      - type: string\n        summary: |\n          A unique identifier for the generated avatar.\n    tags:\n      - Yields\n    deprecationmessage: ''\n    security: None\n    threadsafety: Unsafe\n    capabilities:\n      - DynamicGeneration\n  - name: AvatarCreationService:GenerateAvatar2DPreviewAsync\n    summary: |\n      Creates a 2D avatar preview and returns a previewId.\n    description: |\n      Creates a 2D avatar image preview, taking as input the FileId from\n      Class.AvatarCreationService:PromptSelectAvatarGenerationImageAsync()|PromptSelectAvatarGenerationImageAsync()\n      and an optional text prompt. It returns a previewId which can be passed to\n      Class.AvatarCreationService:LoadAvatar2DPreviewAsync()|LoadAvatar2DPreviewAsync()\n      to retrieve the preview image on the client. This API can only be used on\n      the game server.\n\n      lua\n      local AvatarCreationService = game:GetService(\"AvatarCreationService\")\n\n      function generateAvatar2DPreview(sessionId, fileId, textPrompt)\n          local pcallSuccess, result = pcall(function()\n              local args = {}\n              args.SessionId = sessionId\n              args.FileId = fileId\n              args.TextPrompt = textPrompt\n              return AvatarCreationService:GenerateAvatar2DPreview(args)\n          end)\n\n          if not pcallSuccess then\n              warn(\"Generating 2D preview failed: \", result)\n          end\n\n          return result\n      end\n\n    codesamples: []\n    parameters:\n      - name: avatarGeneration2dPreviewParams\n        type: Dictionary\n        default:\n        summary: |\n          A table of arguments for 2D preview generation. Type:\n          avatarGeneration2dPreviewParams: {SessionId: string, FileId: string, TextPrompt: string?}\n    returns:\n      - type: string\n        summary: |\n          A string previewId\n    tags:\n      - Yields\n    deprecationmessage: ''\n    security: None\n    threadsafety: Unsafe\n    capabilities:\n      - DynamicGeneration\n  - name: AvatarCreationService:GenerateAvatarAsync\n    summary: |\n      Generates an avatar and returns a generationId.\n    description: |\n      Generate an avatar from a preview and return the generationId. The\n      Class.AvatarCreationService:LoadGeneratedAvatarAsync()|LoadGeneratedAvatarAsync()\n      method is then called to retrieve the generated\n      Class.HumanoidDescription avatar. This API can only be used on the game\n      server.\n\n      lua\n      local AvatarCreationService = game:GetService(\"AvatarCreationService\")\n\n      function generateAvatar(sessionId, previewId)\n          local pcallSuccess, result = pcall(function()\n              local args = {}\n              args.SessionId = sessionId\n              args.PreviewId = previewId\n              return AvatarCreationService:GenerateAvatarAsync(args)\n          end)\n\n          if not pcallSuccess then\n              warn(\"Generating avatar failed: \", result)\n          end\n\n          return result\n      end\n\n    codesamples: []\n    parameters:\n      - name: avatarGenerationParams\n        type: Dictionary\n        default:\n        summary: |\n          A table of arguments for generating an avatar. Type:\n          avatarGenerationParams: {SessionId: string, PreviewId: string}\n    returns:\n      - type: string\n        summary: |\n          A string generationId.\n    tags:\n      - Yields\n    deprecationmessage: ''\n    security: None\n    threadsafety: Unsafe\n    capabilities:\n      - DynamicGeneration\n  - name: AvatarCreationService:GetBatchTokenDetailsAsync\n    summary: |\n      Gets the avatar creation token details for a list of avatar creation\n      tokens at once.\n    description: |\n      Gets the avatar creation token details for a list of avatar creation\n      tokens at once (tokens are generated through the\n      token creation\n      process). Returns an array of avatar creation token details; each token\n      detail is a dictionary with the fields indicated in the example result\n      below:\n\n      lua\n      {\n      \t[\"Name\"] = \"string\",\n      \t[\"Description\"] = \"string\",\n      \t[\"UniverseId\"] = 0,\n      \t[\"CreatorId\"] = 0,\n      \t[\"CreatorType\"] = Enum.CreatorType.User,\n      \t[\"OnSale\"] = true,\n      \t[\"Price\"] = 0,\n      \t[\"OffSaleReasons\"] = {\n      \t\t\"string\",\n      \t}\n      }\n\n    codesamples: []\n    parameters:\n      - name: tokenIds\n        type: Array\n        default:\n        summary: |\n          The list of avatar creation token IDs to get details of.\n    returns:\n      - type: Array\n        summary: |\n          Array of avatar creation token details as outlined above.\n    tags:\n      - Yields\n    deprecationmessage: ''\n    security: None\n    threadsafety: Unsafe\n    capabilities:\n      - Monetization\n  - name: AvatarCreationService:GetValidationRules\n    summary: |\n      Gets data regarding rules that assets must abide by to pass UGC\n      validation.\n    description: |\n      Gets data regarding rules that assets must abide by to pass UGC\n      validation. Validation is an essential step before creating avatars and\n      there are various checks that occur, including mesh triangle limits,\n      texture sizes, body part size limits, attachment positions, and more.\n\n      The returned dictionary of validation rules takes the following form:\n\n\n      {\n      \t[\"MeshRules\"] = {\n      \t\t[\"BodyPartMaxTriangles\"] = {\n      \t\t\tEnum.AssetType.DynamicHead: number,\n      \t\t\tEnum.AssetType.LeftArm: number,\n      \t\t\tEnum.AssetType.RightArm: number,\n      \t\t\tEnum.AssetType.Torso: number,\n      \t\t\tEnum.AssetType.LeftLeg: number,\n      \t\t\tEnum.AssetType.RightLeg: number,\n      \t\t},\n      \t\t\t[\"AccessoryMaxTriangles\"]: number,\n      \t\t\t[\"MeshVertColor\"]: Color3,\n      \t\t\t[\"CageMeshMaxDistanceFromRenderMesh\"]: number,\n      \t},\n      \t[\"TextureRules\"] = {\n      \t\t[\"MaxTextureSize\"]: number,\n      \t},\n      \t[\"BodyPartRules\"] = {\n      \t\t[Enum.AssetType.DynamicHead] = {\n      \t\t\t[\"Bounds\"] = {\n      \t\t\t\t[\"Classic\"] = {\n      \t\t\t\t\t[\"MinSize\"]: Vector3,\n      \t\t\t\t\t[\"MaxSize\"]: Vector3,\n      \t\t\t},\n      \t\t\t\t[\"ProportionsSlender\"] = {\n      \t\t\t\t\t[\"MinSize\"]: Vector3,\n      \t\t\t\t\t[\"MaxSize\"]: Vector3,\n      \t\t\t\t},\n      \t\t\t\t[\"ProportionsNormal\"] = {\n      \t\t\t\t\t[\"MinSize\"]: Vector3,\n      \t\t\t\t\t[\"MaxSize\"]: Vector3,\n      \t\t\t\t},\n      \t\t\t},\n      \t\t\t[\"SubParts\"] = {\n      \t\t\t\t[\"Head\"] = {\n      \t\t\t\t\t[\"NeckRigAttachment\"] = {\n      \t\t\t\t\t\t[\"LowerBound\"]: Vector3,\n      \t\t\t\t\t\t[\"UpperBound\"]: Vector3,\n      \t\t\t\t\t},\n      \t\t\t\t\t[\"FaceFrontAttachment\"] = {\n      \t\t\t\t\t\t[\"LowerBound\"]: Vector3,\n      \t\t\t\t\t\t[\"UpperBound\"]: Vector3,\n      \t\t\t\t\t},\n      \t\t\t\t\t[\"HatAttachment\"] = {\n      \t\t\t\t\t\t[\"LowerBound\"]: Vector3,\n      \t\t\t\t\t\t[\"UpperBound\"]: Vector3,\n      \t\t\t\t\t},\n      \t\t\t\t\t[\"HairAttachment\"] = {\n      \t\t\t\t\t\t[\"LowerBound\"]: Vector3,\n      \t\t\t\t\t\t[\"UpperBound\"]: Vector3,\n      \t\t\t\t\t},\n      \t\t\t\t\t[\"FaceCenterAttachment\"] = {\n      \t\t\t\t\t\t[\"LowerBound\"]: Vector3,\n      \t\t\t\t\t\t[\"UpperBound\"]: Vector3,\n      \t\t\t\t\t},\n      \t\t\t\t},\n      \t\t\t},\n      \t\t},\n      \t\t[Enum.AssetType.LeftArm] = {\n      \t\t\t[\"Bounds\"] = {\n      \t\t\t\t[\"Classic\"] = {\n      \t\t\t\t\t[\"MinSize\"]: Vector3,\n      \t\t\t\t\t[\"MaxSize\"]: Vector3,\n      \t\t\t\t},\n      \t\t\t\t[\"ProportionsSlender\"] = {\n      \t\t\t\t\t[\"MinSize\"]: Vector3,\n      \t\t\t\t\t[\"MaxSize\"]: Vector3,\n      \t\t\t\t},\n      \t\t\t\t[\"ProportionsNormal\"] = {\n      \t\t\t\t\t[\"MinSize\"]: Vector3,\n      \t\t\t\t\t[\"MaxSize\"]: Vector3,\n      \t\t\t\t},\n      \t\t\t},\n      \t\t\t[\"SubParts\"] = {\n      \t\t\t\t[\"LeftHand\"] = {\n      \t\t\t\t\t[\"LeftWristRigAttachment\"] = {\n      \t\t\t\t\t\t[\"LowerBound\"]: Vector3,\n      \t\t\t\t\t\t[\"UpperBound\"]: Vector3,\n      \t\t\t\t\t},\n      \t\t\t\t\t[\"LeftGripAttachment\"] = {\n      \t\t\t\t\t\t[\"LowerBound\"]: Vector3,\n      \t\t\t\t\t\t[\"UpperBound\"]: Vector3,\n      \t\t\t\t\t},\n      \t\t\t\t},\n      \t\t\t\t[\"LeftUpperArm\"] = {\n      \t\t\t\t\t[\"LeftShoulderRigAttachment\"] = {\n      \t\t\t\t\t\t[\"LowerBound\"]: Vector3,\n      \t\t\t\t\t\t[\"UpperBound\"]: Vector3,\n      \t\t\t\t\t},\n      \t\t\t\t\t[\"LeftShoulderAttachment\"] = {\n      \t\t\t\t\t\t[\"LowerBound\"]: Vector3,\n      \t\t\t\t\t\t[\"UpperBound\"]: Vector3,\n      \t\t\t\t\t},\n      \t\t\t\t\t\t[\"LeftElbowRigAttachment\"] = {\n      \t\t\t\t\t\t[\"LowerBound\"]: Vector3,\n      \t\t\t\t\t\t[\"UpperBound\"]: Vector3,\n      \t\t\t\t\t},\n      \t\t\t\t},\n      \t\t\t\t[\"LeftLowerArm\"] = {\n      \t\t\t\t\t[\"LeftElbowRigAttachment\"] = {\n      \t\t\t\t\t\t[\"LowerBound\"]: Vector3,\n      \t\t\t\t\t\t[\"UpperBound\"]: Vector3,\n      \t\t\t\t\t},\n      \t\t\t\t\t[\"LeftWristRigAttachment\"] = {\n      \t\t\t\t\t\t[\"LowerBound\"]: Vector3,\n      \t\t\t\t\t\t[\"UpperBound\"]: Vector3,\n      \t\t\t\t\t},\n      \t\t\t\t},\n      \t\t\t},\n      \t\t},\n      \t\t...\n      \t},\n      \t[\"AccessoryRules\"] = {\n      \t\t[Enum.AssetType.HairAccessory] = {\n      \t\t\t[\"Attachments\"] = {\n      \t\t\t\t{\n      \t\t\t\t\t[\"Size\"]: Vector3,\n      \t\t\t\t\t[\"Offset\"]: Vector3,\n      \t\t\t\t\t[\"Name\"]: string,\n      \t\t\t\t},\n      \t\t\t},\n      \t\t\t[\"RigidAllowed\"]: boolean,\n      \t\t},\n      \t\t...\n      \t}\n      }\n\n    codesamples: []\n    parameters: []\n    returns:\n      - type: Dictionary\n        summary: |\n          Dictionary of validation rules as detailed above.\n    tags:\n      - CustomLuaState\n    deprecationmessage: ''\n    security: None\n    threadsafety: Unsafe\n    capabilities: []\n  - name: AvatarCreationService:LoadAvatar2DPreviewAsync\n    summary: |\n      Load an AvatarGeneration 2D preview on the client from a previewId.\n    description: |\n      Load an AvatarGeneration 2D preview as an Class.EditableImage on the\n      client for the given previewId. This API can only be used on the client.\n\n      lua\n      local AvatarCreationService = game:GetService(\"AvatarCreationService\")\n\n      function loadAvatar2DPreview(previewId)\n          local pcallSuccess, result = pcall(function()\n              return AvatarCreationService:LoadAvatar2DPreviewAsync(previewId)\n          end)\n\n          if not pcallSuccess then\n              warn(\"Failed to load preview: \", result)\n          end\n\n          return result\n      end\n\n    codesamples: []\n    parameters:\n      - name: previewId\n        type: string\n        default:\n        summary: |\n          Load the preview generated from\n          Class.AvatarCreationService:GenerateAvatar2DPreviewAsync()|GenerateAvatar2DPreviewAsync().\n    returns:\n      - type: EditableImage\n        summary: |\n          An Class.EditableImage containing the preview image.\n    tags:\n      - Yields\n    deprecationmessage: ''\n    security: None\n    threadsafety: Unsafe\n    capabilities:\n      - DynamicGeneration\n  - name: AvatarCreationService:LoadGeneratedAvatarAsync\n    summary: |\n      Loads a generated avatar using an avatar generation ID.\n    description: |\n      Loads a generated avatar using an avatar generation ID, as returned by\n      Class.AvatarCreationService:AutoSetupAvatarAsync()|AutoSetupAvatarAsync()\n      or\n      Class.AvatarCreationService:GenerateAvatarAsync()|GenerateAvatarAsync().\n      The generated avatar will be returned as a Class.HumanoidDescription\n      with all the generated instances and properties. Mesh and texture assets\n      will be provided as Class.EditableMesh and Class.EditableImage\n      objects, respectively, to allow continued editing of the generated avatar.\n\n      This method can be called on both the server and client, allowing the\n      generated avatar to be loaded in both places (on the client for\n      previewing, and on the server for saving the generated avatar to the\n      player's inventory using\n      Class.AvatarCreationService:PromptCreateAvatarAsync()|PromptCreateAvatarAsync()).\n      Once the method has been invoked on both the client and server, the data\n      associated with the generation ID will be erased and subsequent calls to\n      his method with the same generation ID will fail.\n    codesamples:\n      - AvatarCreationService-LoadGeneratedAvatarAsync\n    parameters:\n      - name: generationId\n        type: string\n        default:\n        summary: |\n          A unique string that identifies the generated avatar, as returned by\n          Class.AvatarCreationService:AutoSetupAvatarAsync()| AutoSetupAvatarAsync().\n    returns:\n      - type: HumanoidDescription\n        summary: |\n          The Class.HumanoidDescription of the generated avatar, which\n          includes all the generated instances and properties.\n    tags:\n      - Yields\n    deprecationmessage: ''\n    security: None\n    threadsafety: Unsafe\n    capabilities:\n      - DynamicGeneration\n  - name: AvatarCreationService:PrepareAvatarForPreviewAsync\n    summary: |\n      Prepares in-experience avatar for preview.\n    description: |\n      Triggers HSR generation and attachment point updating for in-experience\n      avatar previews. This allows for previewing of avatars created in\n      experience with layered clothing and accessories in the same way they will\n      appear when published through\n      Class.AvatarCreationService:PromptCreateAvatarAsync()|PromptCreateAvatarAsync().\n\n      When developers use Class.EditableMesh and Class.WrapDeformer to\n      modify avatars before publishing, the original HSR data may not accurately\n      account for the new deformations. This method generates updated HSR data\n      and corrects attachment points based on the Class.WrapDeformer\n      modifications, ensuring consistent preview and published avatar\n      appearance.\n    codesamples: []\n    parameters:\n      - name: humanoidModel\n        type: Model\n        default:\n        summary: |\n          The Class.Model containing Class.MeshPart children with\n          Class.WrapDeformer instances that require HSR data updating for\n          preview.\n    returns:\n      - type: ()\n        summary: ''\n    tags:\n      - Yields\n    deprecationmessage: ''\n    security: None\n    threadsafety: Unsafe\n    capabilities:\n      - Avatar\n  - name: AvatarCreationService:PromptCreateAvatarAssetAsync\n    summary: |\n      Prompts a Class.Player to purchase and create an avatar asset from an\n      Class.Instance.\n    description: |\n      Prompts a Class.Player to purchase and create an avatar asset from an\n      Class.Instance. The price of the creation is dictated by the price\n      attributed to the avatar creation token. This creation token is required\n      for the purchasing and creation of the asset and can be generated by\n      following the\n      token creation\n      process.\n\n      For avatar asset creation, the Class.Instance is expected to include a\n      new accessory to be created. This includes the following types:\n      Enum.AvatarAssetType.Hat|Hat, Enum.AvatarAssetType.HairAccessory|Hair,\n      Enum.AvatarAssetType.FaceAccessory|FaceAccessory,\n      Enum.AvatarAssetType.NeckAccessory|NeckAccessory,\n      Enum.AvatarAssetType.ShoulderAccessory|ShoulderAccessory,\n      Enum.AvatarAssetType.FrontAccessory|FrontAccessory,\n      Enum.AvatarAssetType.BackAccessory|BackAccessory,\n      Enum.AvatarAssetType.WaistAccessory|WaistAccessory,\n      Enum.AvatarAssetType.TShirtAccessory|TShirtAccessory,\n      Enum.AvatarAssetType.ShirtAccessory|ShirtAccessory,\n      Enum.AvatarAssetType.PantsAccessory|PantsAccessory,\n      Enum.AvatarAssetType.JacketAccessory|JacketAccessory,\n      Enum.AvatarAssetType.SweaterAccessory|SweaterAccessory,\n      Enum.AvatarAssetType.ShortsAccessory|ShortsAccessory,\n      Enum.AvatarAssetType.DressSkirtAccessory|DressSkirtAccessory.\n\n      To support this, the Class.Instance should be an Class.Accessory\n      instance or contain an Class.Accessory child instance. This should\n      include a Class.MeshPart child instance which makes up the accessory.\n\n      The avatar asset Class.MeshPart will also need to include:\n\n      - An Class.EditableImage.\n      - An Class.EditableMesh.\n\n      If creating a layered clothing accessory such as a shirt, the\n      Class.MeshPart should include a Class.WrapDeformer with an\n      Class.EditableMesh.\n\n      Finally, the provided Enum.AvatarAssetType should match the creation\n      type of the token and the type of Class.Accessory for upload.\n    codesamples:\n      - AvatarCreationService-PromptCreateAvatarAssetAsync\n    parameters:\n      - name: tokenId\n        type: string\n        default:\n        summary: |\n          The ID of a creation token. The token must be valid in that the\n          universe the method is called from is the same universe the token was\n          created for. Furthermore, the token creator must maintain ID\n          verification and\n          Roblox Premium. To create\n          a token for utilization in this API, follow the\n          token creation\n          process. The token's creation type must match the\n          Enum.AvatarAssetType passed in to the method.\n      - name: player\n        type: Player\n        default:\n        summary: |\n          The Class.Player intended to be presented with the creation prompt.\n      - name: assetInstance\n        type: Instance\n        default:\n        summary: |\n          The Class.Instance of the avatar asset intended for creation.\n      - name: assetType\n        type: AvatarAssetType\n        default:\n        summary: |\n          The Enum.AvatarAssetType of the expected creation. This must match\n          the creation type of the provided token.\n    returns:\n      - type: Tuple\n        summary: |\n          A tuple containing, in order:\n\n          - An Enum.PromptCreateAssetResult indicating the result of the\n            creation prompt.\n\n          - A string result. In the case of\n            Enum.PromptCreateAssetResult.Success, this will indicate the asset\n            ID. In the case of any failure enum, this will indicate the\n            resultant error message.\n    tags:\n      - Yields\n    deprecationmessage: ''\n    security: None\n    threadsafety: Unsafe\n    capabilities: []\n  - name: AvatarCreationService:PromptCreateAvatarAsync\n    summary: |\n      Prompts a Class.Player to purchase and create an avatar from a\n      Class.HumanoidDescription.\n    description: |\n      Prompts a Class.Player to purchase and create an avatar from a\n      Class.HumanoidDescription. The price of the creation is dictated by the\n      price attributed to the avatar creation token. This avatar creation token\n      is required for the purchasing and creation of the body and can be\n      generated by following the\n      token creation\n      process.\n\n      For avatar creation, the Class.HumanoidDescription is expected to\n      include new assets to be created for each of the 6 body parts\n      (Enum.BodyPart.Head|Head, Enum.BodyPart.Torso|Torso,\n      Enum.BodyPart.RightLeg|RightLeg, Enum.BodyPart.LeftLeg|LeftLeg,\n      Enum.BodyPart.RightArm|RightArm, Enum.BodyPart.LeftArm|LeftArm).\n      Optionally, it can also include a new Enum.AccessoryType.Hair|Hair\n      accessory.\n\n      To support this, the Class.HumanoidDescription should include 6\n      Class.BodyPartDescription children (one for each body part). For each,\n      the Class.BodyPartDescription.Instance property references a\n      Class.Folder which includes all of the Class.MeshPart instances which\n      make up the body part, for example a LeftArm folder which has\n      LeftHand, LeftUpperArm, and LeftLowerArm Class.MeshPart|MeshParts.\n      The Class.BodyPartDescription.BodyPart property should also be set to\n      the relevant Enum.BodyPart.\n\n      Each body part Class.MeshPart will also need to include:\n\n      - An Class.EditableImage.\n      - A Class.WrapDeformer with an Class.EditableMesh.\n\n      If including an accessory such as hair, the Class.HumanoidDescription\n      should include a child Class.AccessoryDescription where:\n\n      - The Class.AccessoryDescription.Instance property references the\n        Class.Accessory instance.\n      - The Class.AccessoryDescription.AccessoryType property is set to the\n        relevant Enum.AccessoryType.\n\n      Finally, the Class.HumanoidDescription should include the humanoid\n      scales of Class.HumanoidDescription.BodyTypeScale|BodyTypeScale,\n      Class.HumanoidDescription.HeadScale|HeadScale,\n      Class.HumanoidDescription.HeightScale|HeightScale,\n      Class.HumanoidDescription.WidthScale|WidthScale, and\n      Class.HumanoidDescription.ProportionScale|ProportionScale. Be mindful of\n      the scales that a base body is imported with so that they match the scales\n      provided to the Class.HumanoidDescription.\n    codesamples:\n      - AvatarCreationService-PromptCreateAvatarAsync\n    parameters:\n      - name: tokenId\n        type: string\n        default:\n        summary: |\n          The ID of an avatar creation token. The token must be valid in that\n          the universe the method is called from is the same universe the token\n          was created for. Furthermore, the token creator must maintain ID\n          verification and\n          Roblox Premium. To create\n          a token for utilization in this API, follow the\n          token creation\n          process.\n      - name: player\n        type: Player\n        default:\n        summary: |\n          The Class.Player intended to be presented with the creation prompt.\n      - name: humanoidDescription\n        type: HumanoidDescription\n        default:\n        summary: |\n          The Class.HumanoidDescription of the avatar intended for creation.\n    returns:\n      - type: Tuple\n        summary: |\n          A tuple containing, in order:\n\n          - An Enum.PromptCreateAvatarResult indicating the result of the\n            creation prompt.\n\n          - A string result. In the case of\n            Enum.PromptCreateAvatarResult.Success, this will indicate the\n            bundle ID. In the case of any failure enum, this will indicate the\n            resultant error message.\n\n          - A secondary optional string result. In the case of\n            Enum.PromptCreateAvatarResult.Success, this will indicate the\n            outfit ID. In the case of any failure enum, this will be nil.\n    tags:\n      - Yields\n    deprecationmessage: ''\n    security: None\n    threadsafety: Unsafe\n    capabilities:\n      - AssetCreateUpdate\n      - Monetization\n  - name: AvatarCreationService:PromptSelectAvatarGenerationImageAsync\n    summary: |\n      Prompt the Class.Player to take a selfie and return the FileId.\n    description: |\n      Prompt the Class.Player to take a selfie and return the FileId of the\n      selfie. This FileId is then passed as an argument to\n      Class.AvatarCreationService:GenerateAvatar2DPreviewAsync()|GenerateAvatar2DPreviewAsync().\n      This API can only be used on the game server.\n\n      lua\n      local AvatarCreationService = game:GetService(\"AvatarCreationService\")\n\n      function promptSelectAvatarGenerationImage(player)\n          local pcallSuccess, result = pcall(function()\n              return AvatarCreationService:PromptSelectAvatarGenerationImageAsync(player)\n          end)\n\n          if not pcallSuccess then\n              warn(\"Failed to prompt for image: \", result)\n          end\n\n          return result\n      end\n\n    codesamples: []\n    parameters:\n      - name: player\n        type: Player\n        default:\n        summary: |\n          The Class.Player to prompt for taking a selfie.\n    returns:\n      - type: string\n        summary: |\n          A string FileId of the selfie.\n    tags:\n      - Yields\n    deprecationmessage: ''\n    security: None\n    threadsafety: Unsafe\n    capabilities:\n      - SensitiveInput\n  - name: AvatarCreationService:RequestAvatarGenerationSessionAsync\n    summary: |\n      Request an AvatarGeneration session for a Class.Player.\n    description: |\n      Request an AvatarGeneration session for a Class.Player. Information\n      about the session is returned via the callback, including the SessionId\n      which is passed to the\n      Class.AvatarCreationService:GenerateAvatar2DPreviewAsync()|GenerateAvatar2DPreviewAsync()\n      and\n      Class.AvatarCreationService:GenerateAvatarAsync()|GenerateAvatarAsync()\n      methods. Additional session information includes allowed 2d preview\n      generations, allowed 3d avatar generations, and the session time. The\n      method returns a Tuple with an Datatype.RBXScriptConnection and\n      estimated waitTime. The Datatype.RBXScriptConnection allows canceling\n      a session request. The estimated waitTime is used to provide the player\n      an estimated time in seconds until the session will be ready. This API can\n      only be used on the game server.\n\n      lua\n      local AvatarCreationService = game:GetService(\"AvatarCreationService\")\n      local playerSessions = {}\n      local playerSessionRequests = {}\n\n      function requestAvatarGenerationSession(player)\n          local pcallSuccess, conn, waitTime = pcall(function()\n              return AvatarCreationService:RequestAvatarGenerationSessionAsync(player, function(sessionInfo)\n                  playerSessions[player.UserID] = sessionInfo\n                  playerSessionRequests[player.UserID] = nil\n              end)\n          end)\n\n          if not pcallSuccess then\n              warn(\"Failed to request Avatar generation session: \", conn)\n          end\n\n          playerSessionRequests[player.UserID] = conn\n          print(\"Wait time for session: \", tostring(waitTime))\n      end\n\n      function cancelAvatarGenerationSessionRequest(player)\n          if playerSessionRequests[player.UserID] ~= nil then\n              playerSessionRequests[player.UserID]:Disconnect()\n          end\n      end\n\n    codesamples: []\n    parameters:\n      - name: player\n        type: Player\n        default:\n        summary: |\n          The Class.Player to request an AvatarGeneration session for.\n      - name: callback\n        type: Function\n        default:\n        summary: |\n          Callback function that is invoked with a SessionInfo table, with\n          information about the session. Type:\n          (SessionInfo: { SessionId: string, Allowed2DGenerations: number, Allowed3DGenerations: number, SessionTime: number }) -> ()\n    returns:\n      - type: Tuple\n        summary: |\n          A tuple containing a Datatype.RBXScriptConnection that can be used\n          to cancel the session request and the estimated wait time in seconds.\n    tags:\n      - Yields\n    deprecationmessage: ''\n    security: None\n    threadsafety: Unsafe\n    capabilities:\n      - DynamicGeneration\n  - name: AvatarCreationService:ValidateUGCAccessoryAsync\n    summary: |\n      Studio only. Runs UGC validation for an Enum.AccessoryType.\n    description: |\n      Studio only. Given a Class.Player and Class.Instance for an\n      Enum.AccessoryType, determines if UGC validation passes.\n    codesamples: []\n    parameters:\n      - name: player\n        type: Player\n        default:\n        summary: |\n          The Class.Player validation is completed for.\n      - name: accessory\n        type: Instance\n        default:\n        summary: |\n          The instance validation is run on.\n      - name: accessoryType\n        type: AccessoryType\n        default:\n        summary: |\n          Enum.AccessoryType the instance is expected to be. Expects\n          Enum.AccessoryType.Eyebrow|Eyebrow,\n          Enum.AccessoryType.Eyelash|Eyelash, or\n          Enum.AccessoryType.Hair|Hair.\n    returns:\n      - type: Tuple\n        summary: |\n          A tuple containing, in order:\n\n          - A boolean indicating if validation was successful for the accessory.\n          - An optional table of strings. This includes failure reasons if\n            validation was unsuccessful; otherwise nil if validation was\n            successful.\n    tags:\n      - Yields\n    deprecationmessage: ''\n    security: None\n    threadsafety: Unsafe\n    capabilities: []\n  - name: AvatarCreationService:ValidateUGCBodyPartAsync\n    summary: |\n      Studio only. Runs UGC validation for an Enum.BodyPart.\n    description: |\n      Studio only. Given a Class.Player and Class.Instance for an\n      Enum.BodyPart, determines if UGC validation passes. The instance\n      parameter is expected as a Class.Folder in the following example format\n      with relevant Class.MeshPart|MeshParts:\n\n      - LeftArm (Class.Folder)\n        - R15ArtistIntent (Class.Folder)\n          - LeftLowerArm (Class.MeshPart)\n          - LeftUpperArm (Class.MeshPart)\n          - LeftHand (Class.MeshPart)\n\n      However, if the expected bodyPart is Enum.BodyPart.Head, the function\n      takes a singular Head Class.MeshPart directly.\n    codesamples: []\n    parameters:\n      - name: player\n        type: Player\n        default:\n        summary: |\n          The Class.Player validation is completed for.\n      - name: instance\n        type: Instance\n        default:\n        summary: |\n          The instance validation is run on.\n      - name: bodyPart\n        type: BodyPart\n        default:\n        summary: |\n          Enum.BodyPart the instance is expected to be.\n    returns:\n      - type: Tuple\n        summary: |\n          A tuple containing, in order:\n\n          - A boolean indicating if validation was successful for the body part.\n          - An optional table of strings. This includes failure reasons if\n            validation was unsuccessful; otherwise nil if validation was\n            successful.\n    tags:\n      - Yields\n    deprecationmessage: ''\n    security: None\n    threadsafety: Unsafe\n    capabilities: []\n  - name: AvatarCreationService:ValidateUGCFullBodyAsync\n    summary: |\n      Studio only. Runs UGC validation for a whole body.\n    description: |\n      Studio only. Given a Class.Player and Class.HumanoidDescription, all\n      instances in the Class.HumanoidDescription will be validated.\n\n      The Class.HumanoidDescription is expected to include instances set on\n      Class.BodyPartDescription children for each of the 6 required\n      Enum.BodyPart values. Optionally, it can include instances set on\n      Class.AccessoryDescription children for Eyebrow, Eyelash, and Hair\n      Enum.AccessoryType|AccessoryTypes.\n    codesamples: []\n    parameters:\n      - name: player\n        type: Player\n        default:\n        summary: |\n          The Class.Player validation is completed for.\n      - name: humanoidDescription\n        type: HumanoidDescription\n        default:\n        summary: |\n          Class.HumanoidDescription representing the body that validation is\n          run on.\n    returns:\n      - type: Tuple\n        summary: |\n          A tuple containing, in order:\n\n          - A boolean indicating if validation was successful for the body.\n          - An optional table of strings. This includes failure reasons if\n            validation was unsuccessful; otherwise nil if validation was\n            successful.\n    tags:\n      - Yields\n    deprecationmessage: ''\n    security: None\n    threadsafety: Unsafe\n    capabilities: []\nevents:\n  - name: AvatarCreationService.AvatarAssetModerationCompleted\n    summary: |\n      Fires when an in-experience-created avatar asset's moderation status has\n      been updated from pending.\n    description: |\n      Fires when an in-experience-created avatar asset's moderation status has\n      been updated from pending. This event provides a streamlined way to know\n      when an avatar asset created through\n      Class.AvatarCreationService:PromptCreateAvatarAssetAsync()|PromptCreateAvatarAssetAsync()\n      has completed the moderation process and is ready for use in-experience.\n\n      Note that this event only fires for avatar assets created within the\n      current experience and will trigger when the Enum.ModerationStatus\n      changes from Enum.ModerationStatus.NotReviewed|NotReviewed to any other\n      status. The event fires on the client only.\n    codesamples:\n      - AvatarCreationService-AvatarAssetModerationCompleted\n    parameters:\n      - name: assetId\n        type: int64\n        default:\n        summary: |\n          The asset ID of the asset that has completed moderation.\n      - name: moderationStatus\n        type: ModerationStatus\n        default:\n        summary: |\n          The final Enum.ModerationStatus result after moderation completed.\n    tags: []\n    deprecationmessage: ''\n    security: None\n    capabilities:\n      - DynamicGeneration\n  - name: AvatarCreationService.AvatarModerationCompleted\n    summary: |\n      Fires when an in-experience-created avatar's moderation status has been\n      updated from pending.\n    description: |\n      Fires when an in-experience-created avatar's moderation status has been\n      updated from pending. This event provides a streamlined way to know when\n      an avatar created through\n      Class.AvatarCreationService:PromptCreateAvatarAsync()|PromptCreateAvatarAsync()\n      has completed the moderation process and is ready for use in-experience.\n\n      Note that this event only fires for avatars created within the current\n      experience and will trigger when the Enum.ModerationStatus changes from\n      Enum.ModerationStatus.NotReviewed|NotReviewed to any other status. The\n      event fires on the client only.\n      Class.AvatarEditorService:GetOutfitDetailsAsync|GetOutfitDetailsAsync\n      can be used on the server to verify the current moderation status if\n      needed.\n    codesamples: []\n    parameters:\n      - name: outfitId\n        type: int64\n        default:\n        summary: |\n          The outfit ID of the avatar that has completed moderation.\n      - name: moderationStatus\n        type: ModerationStatus\n        default:\n        summary: |\n          The final Enum.ModerationStatus result after moderation completion.\n    tags: []\n    deprecationmessage: ''\n    security: None\n    capabilities:\n      - DynamicGeneration\ncallbacks: []",
    "source": "AvatarCreationService.yaml"
}