{
    "metadata": {},
    "content": "{\n    \"source_filename\": \"collisions.md\",\n    \"metadata\": {\n        \"title\": \"Collisions\",\n        \"description\": \"Explains methods to detect physical collisions, handle collision events, and fine-tune which objects collide with others.\"\n    },\n    \"content\": \"A collision occurs when two 3D objects come into contact within the 3D world. For customized collision handling, `Class.BasePart` has a set of [collision events](#collision-events) and [collision filtering](#collision-filtering) techniques, so you can control which physical assemblies collide with others.\\n\\n## Collision events\\n\\nCollision **events** occur when two `Class.BasePart|BaseParts` touch or stop touching in the 3D world. You can detect these collisions through the `Class.BasePart.Touched|Touched` and `Class.BasePart.TouchEnded|TouchEnded` events which occur regardless of either part's `Class.BasePart.CanCollide|CanCollide` property value. When considering collision handling on parts, note the following:\\n\\n- A part's `Class.BasePart.CanTouch|CanTouch` property determines whether it triggers collision events. If set to `false`, neither `Class.BasePart.Touched|Touched` nor `Class.BasePart.TouchEnded|TouchEnded` will fire.\\n- A part's `Class.BasePart.CanCollide|CanCollide` property affects whether it will **physically** collide with other parts and cause forces to act upon them. Even if `Class.BasePart.CanCollide|CanCollide` is disabled for a part, you can detect touch and non‑touch through `Class.BasePart.Touched|Touched` and `Class.BasePart.TouchEnded|TouchEnded` events.\\n- The `Class.BasePart.Touched|Touched` and `Class.BasePart.TouchEnded|TouchEnded` events only fire as a result of **physical** movement, not from a `Class.BasePart.Position|Position` or `Class.BasePart.CFrame|CFrame` changes that cause a part to intersect or stop intersecting another part.\\n- The top-level `Class.Terrain` class inherits from `Class.BasePart`, so you can assign a [collision group](#collision-groups) to `Class.Terrain` to determine whether other `Class.BasePart|BaseParts` collide with [Terrain](../parts/terrain.md) voxels.\\n\\n<Alert severity=\\\"info\\\">\\nFor performance optimization, set `Class.BasePart.CanTouch|CanTouch` to `false` for objects that don't require collisions.\\n</Alert>\\n\\n### Touched\\n\\nThe `Class.BasePart.Touched|Touched` event fires when a `Class.BasePart`\\ncomes in contact with another, or with a [Terrain](../parts/terrain.md) voxel. It only fires as a result of **physical simulation** and will not fire when the part's `Class.BasePart.Position|Position` or `Class.BasePart.CFrame|CFrame` is explicitly set such that it intersects another part or voxel.\\n\\nThe following code pattern shows how the `Class.BasePart.Touched|Touched` event can be connected to a custom `onTouched()` function. Note that the event sends the `otherPart` argument to the function, indicating the other part involved in the collision.\\n\\n```lua title=\\\"Part Collision\\\" highlight=\\\"3-5, 7\\\"\\nlocal Workspace = game:GetService(\\\"Workspace\\\")\\n\\nlocal part = Workspace.Part\\n\\nlocal function onTouched(otherPart)\\n\\tprint(part.Name .. \\\" collided with \\\" .. otherPart.Name)\\nend\\n\\npart.Touched:Connect(onTouched)\\n```\\n\\nNote that the `Class.BasePart.Touched|Touched` event can fire multiple times in quick succession based on subtle physical collisions, such as when a moving object \\\"settles\\\" into a resting position or when a collision involves a [multi‑part model](#model-collisions). To avoid triggering more `Class.BasePart.Touched|Touched` events than necessary, you can implement a simple debounce system which enforces a \\\"cooldown\\\" period through an instance [attribute](../studio/properties.md#instance-attributes).\\n\\n```lua title=\\\"Part Collision With Cooldown\\\" highlight=\\\"3, 6, 9-12\\\"\\nlocal Workspace = game:GetService(\\\"Workspace\\\")\\n\\nlocal part = Workspace.Part\\n\\nlocal COOLDOWN_TIME = 1\\n\\nlocal function onTouched(otherPart)\\n\\tif not part:GetAttribute(\\\"Touched\\\") then\\n\\t\\tprint(part.Name .. \\\" collided with \\\" .. otherPart.Name)\\n\\n\\t\\tpart:SetAttribute(\\\"Touched\\\", true)  -- Set attribute to true\\n\\t\\ttask.wait(COOLDOWN_TIME)  -- Wait for cooldown duration\\n\\t\\tpart:SetAttribute(\\\"Touched\\\", false)  -- Reset attribute\\n\\tend\\nend\\n\\npart.Touched:Connect(onTouched)\\n```\\n\\n### TouchEnded\\n\\nThe `Class.BasePart.TouchEnded|TouchEnded` event fires when the entire collision bounds of a `Class.BasePart` exits the bounds of another `Class.BasePart` or a filled [Terrain](../parts/terrain.md) voxel. It only fires as a result of **physical simulation** and will not fire when the part's `Class.BasePart.Position|Position` or `Class.BasePart.CFrame|CFrame` is explicitly set such that it stops intersecting another part or voxel.\\n\\nThe following code pattern shows how the `Class.BasePart.TouchEnded|TouchEnded` event can be connected to a custom `onTouchEnded()` function. Like `Class.BasePart.Touched|Touched`, the event sends the `otherPart` argument to the function, indicating the other part involved.\\n\\n```lua title=\\\"Non-Collision Detection\\\" highlight=\\\"3-5, 7\\\"\\nlocal Workspace = game:GetService(\\\"Workspace\\\")\\n\\nlocal part = Workspace.Part\\n\\nlocal function onTouchEnded(otherPart)\\n\\tprint(part.Name .. \\\" is no longer touching \\\" .. otherPart.Name)\\nend\\n\\npart.TouchEnded:Connect(onTouchEnded)\\n```\\n\\n## Collision filtering\\n\\nCollision **filtering** defines which physical parts collide with others. You can configure filtering for numerous objects through [collision groups](#collision-groups) or you can control collisions on a [part‑to‑part](#part-to-part-filtering) basis with `Class.NoCollisionConstraint` instances.\\n\\n### Collision groups\\n\\nCollision **groups** let you assign `Class.BasePart|BaseParts` to dedicated groups and specify whether or not they collide with those in other groups. Parts within non‑colliding groups pass through each other completely, even if both parts have their `Class.BasePart.CanCollide|CanCollide` property set to `true`.\\n\\n<figure>\\n  <video src=\\\"../assets/physics/collisions/Collision-Groups.mp4\\\" controls width=\\\"100%\\\" alt=\\\"Video of spinning objects in different collision groups colliding or not colliding\\\"></video>\\n  <figcaption>In the video above, the spinning objects are in different collision groups such that they collide with objects of another color but not with objects of their own color</figcaption>\\n</figure>\\n\\nYou can easily set up collision groups through Studio's **Collision Groups** editor, accessible through Studio's **Window**&nbsp;⟩ **3D** menu.\\n\\nThe editor functions in either **List&nbsp;View** which favors [docking](../studio/ui-overview.md#reposition-windows) to the left or right side of Studio, or in a wider **Table&nbsp;View**, which favors docking to the top or bottom.\\n\\n<Tabs>\\n  <TabItem label=\\\"List View\\\">\\n    <img src=\\\"../assets/studio/collision-groups-editor/List-View.png\\\" width=\\\"500\\\" height=\\\"176\\\" alt=\\\"List View example in Collision Groups Editor\\\" />\\n  </TabItem>\\n  <TabItem label=\\\"Table View\\\">\\n    <img src=\\\"../assets/studio/collision-groups-editor/Table-View.png\\\" width=\\\"500\\\" height=\\\"176\\\" alt=\\\"Table View example in Collision Groups Editor\\\" />\\n  </TabItem>\\n</Tabs>\\n\\n#### Register groups\\n\\n<Tabs>\\n<TabItem label=\\\"Studio Editor\\\">\\nThe editor includes one **Default** collision group which cannot be renamed or deleted. All `Class.BasePart|BaseParts` automatically belong to this default group unless assigned to another group, meaning that they will collide with all other objects in the **Default** group.\\n\\nTo create a new collision group:\\n\\n1. Click the **Add Group** button along the top of the editor panel, enter a new group name, and press <kbd>Enter</kbd>. The new group appears in both columns of list view, or in both the left column and upper row of table view.\\n\\n   <Tabs>\\n   <TabItem label=\\\"List View\\\">\\n   <img src=\\\"../assets/studio/collision-groups-editor/New-Group-List-View.png\\\" width=\\\"500\\\" height=\\\"220\\\" alt=\\\"New group added to Collision Groups Editor in List View\\\" />\\n   </TabItem>\\n   <TabItem label=\\\"Table View\\\">\\n   <img src=\\\"../assets/studio/collision-groups-editor/New-Group-Table-View.png\\\" width=\\\"500\\\" height=\\\"220\\\" alt=\\\"New group added to Collision Groups Editor in Table View\\\" />\\n   </TabItem>\\n   </Tabs>\\n\\n1. Repeat the process if necessary, choosing a unique and descriptive name for each group. Note that you can change a group's name during development by clicking in its field, or by selecting it and clicking the **rename** button.\\n\\n   <img src=\\\"../assets/studio/collision-groups-editor/Rename-Group.png\\\" width=\\\"500\\\" alt=\\\"Button and field indicated for renaming a group in the Collision Groups Editor\\\" />\\n\\n</TabItem>\\n<TabItem label=\\\"Scripting\\\">\\nTo create a new collision group through scripting, include the `Class.PhysicsService` service and register the group with `Class.PhysicsService:RegisterCollisionGroup()`. It may be helpful to pre-declare your group names in local variables, as the same strings can be used for [assigning objects](#assign-objects-to-groups) and [configuring groups](#configure-group-collisions) within the same script.\\n\\n```lua title=\\\"Collision Group Setup\\\" highlight=\\\"1,3,4,7,8\\\"\\nlocal PhysicsService = game:GetService(\\\"PhysicsService\\\")\\n\\nlocal cubes = \\\"Cubes\\\"\\nlocal doors = \\\"Doors\\\"\\n\\n-- Register two collision groups\\nPhysicsService:RegisterCollisionGroup(cubes)\\nPhysicsService:RegisterCollisionGroup(doors)\\n```\\n\\n<Alert severity=\\\"warning\\\">\\nSince scripts are not guaranteed to execute in any particular order, it's highly recommended that you register collision groups in a single script. Abstracting group registration among multiple scripts may result in a race condition where a group is not yet registered at the time you [configure groups](#configure-group-collisions) or [assign objects](#assign-objects-to-groups) to them.\\n</Alert>\\n\\n</TabItem>\\n</Tabs>\\n\\n#### Configure group collisions\\n\\n<Tabs>\\n<TabItem label=\\\"Studio Editor\\\">\\nUnder default configuration, objects in all groups collide with each other. To prevent objects in one group from colliding with objects in another group, **uncheck** the box in the respective row/column.\\n\\nIn the following example, objects in the **Cubes** group will **not** collide with objects in the **Doors** group.\\n\\n<Tabs>\\n  <TabItem label=\\\"List View\\\">\\n    <img src=\\\"../assets/studio/collision-groups-editor/Configure-Groups-List-View.png\\\" width=\\\"500\\\" height=\\\"176\\\" alt=\\\"Group configured in List View of Collision Groups Editor\\\" />\\n  </TabItem>\\n  <TabItem label=\\\"Table View\\\">\\n    <img src=\\\"../assets/studio/collision-groups-editor/Configure-Groups-Table-View.png\\\" width=\\\"500\\\" height=\\\"176\\\" alt=\\\"Group configured in Table View of Collision Groups Editor\\\" />\\n  </TabItem>\\n</Tabs>\\n</TabItem>\\n<TabItem label=\\\"Scripting\\\">\\nTo configure how objects in two collision groups interact, call `Class.PhysicsService:CollisionGroupSetCollidable()|CollisionGroupSetCollidable()`, providing the two collision groups and a boolean `true` (collidable) or `false` (non‑collidable). If objects in the same group should or shouldn't collide with each other, use that group name for both the first and second parameters.\\n\\n```lua title=\\\"Collision Group Setup\\\" highlight=\\\"15\\\"\\nlocal PhysicsService = game:GetService(\\\"PhysicsService\\\")\\n\\nlocal cubes = \\\"Cubes\\\"\\nlocal doors = \\\"Doors\\\"\\n\\n-- Register two collision groups\\nPhysicsService:RegisterCollisionGroup(cubes)\\nPhysicsService:RegisterCollisionGroup(doors)\\n\\n-- Set cubes to be non-collidable with doors\\nPhysicsService:CollisionGroupSetCollidable(cubes, doors, false)\\n```\\n\\n</TabItem>\\n</Tabs>\\n\\n#### Assign objects to groups\\n\\n<Tabs>\\n<TabItem label=\\\"Studio Editor\\\">\\nTo assign objects to groups you've [registered](#register-groups) through the Studio editor:\\n\\n1. Select one or more `Class.BasePart|BaseParts` that qualify as part of a collision group.\\n2. Assign them to the group by clicking the **&CirclePlus;** button for its row. Objects can belong to only one collision group at a time, so placing them in a new group removes them from their current group.\\n\\n   <img src=\\\"../assets/studio/collision-groups-editor/Add-To-Group.png\\\" width=\\\"500\\\" alt=\\\"Plus button indicated in Collision Groups Editor for adding selected parts to a group\\\" />\\n\\nOnce assigned, the new group is reflected under the object's `Class.BasePart.CollisionGroup|CollisionGroup` property.\\n\\n<img src=\\\"../assets/physics/collisions/BasePart-CollisionGroup.png\\\" width=\\\"320\\\" alt=\\\"Chosen collision group indicated as the part's CollisionGroup property\\\" />\\n</TabItem>\\n<TabItem label=\\\"Scripting\\\">\\nTo add a `Class.BasePart` to a collision group through scripting, simply assign the group's **string name**, previously registered through `Class.PhysicsService:RegisterCollisionGroup()|RegisterCollisionGroup()`, to the part's `Class.BasePart.CollisionGroup|CollisionGroup` property.\\n\\n```lua title=\\\"Collision Group Setup\\\" highlight=\\\"7,8,11,12\\\"\\nlocal PhysicsService = game:GetService(\\\"PhysicsService\\\")\\nlocal Workspace = game:GetService(\\\"Workspace\\\")\\n\\nlocal cubes = \\\"Cubes\\\"\\nlocal doors = \\\"Doors\\\"\\n\\n-- Register two collision groups\\nPhysicsService:RegisterCollisionGroup(cubes)\\nPhysicsService:RegisterCollisionGroup(doors)\\n\\n-- Set cubes to be non-collidable with doors\\nPhysicsService:CollisionGroupSetCollidable(cubes, doors, false)\\n\\n-- Assign an object to each group\\nWorkspace.Cube1.CollisionGroup = cubes\\nWorkspace.Door1.CollisionGroup = doors\\n```\\n\\n</TabItem>\\n</Tabs>\\n\\n#### StudioSelectable collision group\\n\\nTools in Studio use the collision filtering system to determine which objects are candidates for selection when clicking in the 3D viewport. Objects whose assigned collision group does **not** collide with **StudioSelectable** will be ignored.\\n\\nFor example, if you have checkpoints in a racing experience whose effective areas are defined by large transparent parts, you can assign them to a **Checkpoints** collision group and then make that group non‑collidable with **StudioSelectable** so that they don't get in the way when you're editing the underlying map geometry.\\n\\n<img src=\\\"../assets/studio/collision-groups-editor/StudioSelectable-Off.png\\\" width=\\\"500\\\" alt=\\\"Checkpoints group configured to be non-collidable with StudioSelectable group\\\" />\\n\\nFor plugin code, it's recommended that you assign `\\\"StudioSelectable\\\"` as the collision group filter of your `Datatype.RaycastParams` when finding parts under the cursor. This allows your plugins to match the selection mechanics that creators have learned to expect from built‑in Studio tools.\\n\\n```lua title=\\\"Recommended Plugin Selection Raycast\\\"\\nlocal UserInputService = game:GetService(\\\"UserInputService\\\")\\nlocal Workspace = game:GetService(\\\"Workspace\\\")\\n\\nlocal raycastParams = RaycastParams.new()\\nraycastParams.CollisionGroup = \\\"StudioSelectable\\\"  -- To follow the convention\\nraycastParams.BruteForceAllSlow = true  -- So that parts with CanQuery of \\\"false\\\" can be selected\\n\\nlocal mouseLocation = UserInputService:GetMouseLocation()\\nlocal mouseRay = Workspace.CurrentCamera:ViewportPointToRay(mouseLocation.X, mouseLocation.Y)\\nlocal filteredSelectionHit = Workspace:Raycast(mouseRay.Origin, mouseRay.Direction * 10000, raycastParams)\\n```\\n\\n### Part-to-part filtering\\n\\nTo prevent collisions between two specific parts without\\nsetting up [collision groups](#collision-groups), such as between a vehicle's wheel and its chassis, consider the\\n[No&nbsp;Collision](../physics/mechanical-constraints.md#nocollisionconstraint)\\nconstraint. Advantages include:\\n\\n- Collision groups and/or configuration scripts are not required, so you can easily create and share models with customized collision filtering.\\n- Connected parts will not collide with each other, but they can still\\n  collide with other objects.\\n\\n### Disable character collisions\\n\\nRoblox player characters collide with each other by default. This can lead to\\ninteresting but unintended gameplay, such as characters jumping on top of each other to reach specific areas. If this behavior is undesirable, you can prevent it through the following `Class.Script` in `Class.ServerScriptService`.\\n\\n```lua title=\\\"Script - Disable Character Collisions\\\"\\nlocal PhysicsService = game:GetService(\\\"PhysicsService\\\")\\nlocal Players = game:GetService(\\\"Players\\\")\\n\\nPhysicsService:RegisterCollisionGroup(\\\"Characters\\\")\\nPhysicsService:CollisionGroupSetCollidable(\\\"Characters\\\", \\\"Characters\\\", false)\\n\\nlocal function onDescendantAdded(descendant)\\n\\t-- Set collision group for any part descendant\\n\\tif descendant:IsA(\\\"BasePart\\\") then\\n\\t\\tdescendant.CollisionGroup = \\\"Characters\\\"\\n\\tend\\nend\\n\\nlocal function onCharacterAdded(character)\\n\\t-- Process existing and new descendants for physics setup\\n\\tfor _, descendant in character:GetDescendants() do\\n\\t\\tonDescendantAdded(descendant)\\n\\tend\\n\\tcharacter.DescendantAdded:Connect(onDescendantAdded)\\nend\\n\\nPlayers.PlayerAdded:Connect(function(player)\\n\\t-- Detect when the player's character is added\\n\\tplayer.CharacterAdded:Connect(onCharacterAdded)\\nend)\\n```\\n\\n## Model collisions\\n\\n`Class.Model` objects are containers for parts rather than inheriting from `Class.BasePart`, so they can't directly connect to `Class.BasePart.Touched` or `Class.BasePart.TouchEnded` events. To determine whether a model triggers a collision events, you need to loop through its children and connect the custom `onTouched()` and `onTouchEnded()` functions to each child `Class.BasePart`.\\n\\n<Alert severity='info'>\\nFor joined parts by [solid modeling](../parts/solid-modeling.md) instead of `Class.Model` objects, see [Mesh and Solid Modeling Collisions](#mesh-and-solid-model-collisions).\\n</Alert>\\n\\nThe following code sample connects all `Class.BasePart|BaseParts` of a multi‑part model to collision events and tracks the total number of collisions with other parts.\\n\\n```lua title=\\\"Model Collision\\\"\\nlocal model = script.Parent\\n\\nlocal numTouchingParts = 0\\n\\nlocal function onTouched(otherPart)\\n\\t-- Ignore instances of the model intersecting with itself\\n\\tif otherPart:IsDescendantOf(model) then return end\\n\\t-- Increase count of model parts touching\\n\\tnumTouchingParts += 1\\n\\n\\tprint(model.Name, \\\"intersected with\\\", otherPart.Name, \\\"| Model parts touching:\\\", numTouchingParts)\\nend\\n\\nlocal function onTouchEnded(otherPart)\\n\\t-- Ignore instances of the model un-intersecting with itself\\n\\tif otherPart:IsDescendantOf(model) then return end\\n\\t-- Decrease count of model parts touching\\n\\tnumTouchingParts -= 1\\n\\n\\tprint(model.Name, \\\"un-intersected from\\\", otherPart.Name, \\\"| Model parts touching:\\\", numTouchingParts)\\nend\\n\\nfor _, child in model:GetChildren() do\\n\\tif child:IsA(\\\"BasePart\\\") then\\n\\t\\tchild.Touched:Connect(onTouched)\\n\\t\\tchild.TouchEnded:Connect(onTouchEnded)\\n\\tend\\nend\\n```\\n\\n## Mesh and solid model collisions\\n\\n`Class.MeshPart` and `Class.PartOperation` (parts joined by [solid modeling](../parts/solid-modeling.md)) are subclasses of `Class.BasePart`, so meshes and solid modeled parts inherit the same [collision events](#collision-events) and [collision filtering](#collision-filtering) options as regular parts. However, since meshes and solid modeled parts usually have more complex geometries, they have a distinctive `Class.TriangleMeshPart.CollisionFidelity|CollisionFidelity` property which determines how precisely the physical bounds align with the visual representation for collision handling.\\n\\nThe `Class.TriangleMeshPart.CollisionFidelity|CollisionFidelity` property has the following options, in order of fidelity and performance impact from lowest to highest:\\n\\n- **Box** — Creates a bounding collision box, ideal for small or non‑interactive objects.\\n- **Hull** — Generates a convex hull, suitable for objects with less pronounced indentations or cavities.\\n- **Default** — Produces an approximate collision shape that supports concavity, suitable for complex objects with semi-detailed interaction needs.\\n- **PreciseConvexDecomposition** — Offers the most precise fidelity but still not a 1:1 representation of the visual. This option has the most expensive performance cost and takes longer for the engine to compute.\\n\\n<Tabs>\\n  <TabItem label=\\\"Original Mesh\\\">\\n    <img src=\\\"../assets/physics/collisions/Collision-Fidelity-MeshPart.jpg\\\" width=\\\"600\\\" height=\\\"500\\\" alt=\\\"Original mesh of castle tower\\\" />\\n  </TabItem>\\n\\t<TabItem label=\\\"Default\\\">\\n    <img src=\\\"../assets/physics/collisions/Collision-Fidelity-Default.jpg\\\" width=\\\"600\\\" height=\\\"500\\\" alt=\\\"Collision fidelity of Default shown for mesh\\\" />\\n  </TabItem>\\n  <TabItem label=\\\"Box\\\">\\n    <img src=\\\"../assets/physics/collisions/Collision-Fidelity-Box.jpg\\\" width=\\\"600\\\" height=\\\"500\\\" alt=\\\"Collision fidelity of Box shown for mesh\\\"/>\\n  </TabItem>\\n\\t<TabItem label=\\\"Hull\\\">\\n    <img src=\\\"../assets/physics/collisions/Collision-Fidelity-Hull.jpg\\\" width=\\\"600\\\" height=\\\"500\\\" alt=\\\"Collision fidelity of Hull shown for mesh\\\" />\\n  </TabItem>\\n\\t<TabItem label=\\\"Precise\\\">\\n    <img src=\\\"../assets/physics/collisions/Collision-Fidelity-Precise.jpg\\\" width=\\\"600\\\" height=\\\"500\\\" alt=\\\"Collision fidelity of PreciseConvexDecomposition shown for mesh\\\" />\\n  </TabItem>\\n</Tabs>\\n\\n<Alert severity=\\\"success\\\">\\nTo view collision fidelity in Studio, toggle on **Collision&nbsp;fidelity** from the [Visualization&nbsp;Options](../studio/ui-overview.md#visualization-options) widget in the upper‑right corner of the 3D viewport.\\n</Alert>\\n\\nFor more information on the performance impact of collision fidelity options and how to mitigate them, see [Performance optimization](../performance-optimization/improve.md#physics-computation).\"\n}"
}