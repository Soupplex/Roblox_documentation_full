{
    "title": "Metatables",
    "description": "Metatables attach powerful metamethods to tables, allowing for manipulation like indexing, addition, and concatenation.",
    "content": "Metatables allow tables to become more powerful than before. They are attached to data and contain values called metamethods. Metamethods are fired when a certain action is used with the datum that it is attached to.\n\nManipulate metatables\n\nThe two primary functions for adding and finding a table's metatable are Global.LuaGlobals.setmetatable() and Global.LuaGlobals.getmetatable().\n\nlua\nlocal x = {}\nlocal metaTable = {} -- metaTables are tables, too!\nsetmetatable(x, metaTable) -- Give x a metatable called metaTable!\nprint(getmetatable(x)) --> table: [hexadecimal memory address]\n\nThe Global.LuaGlobals.setmetatable() function also returns the table that you're setting the metatable of, so these two scripts do the same thing:\n\nlua\nlocal x = {}\nsetmetatable(x, {})\n\nlua\nlocal x = setmetatable({}, {})\n\nMetamethods\n\nMetamethods are the functions that are stored inside a metatable. They can go\nfrom calling a table, to adding a table, to even dividing tables as well.\nHere's the list of available metamethods:\n\n\n\n\t\t  Method\n\t\t  Description\n\n\n\n\n\t\t  index(table, index)\n\t\t  Fires when table[index] is indexed, if table[index] is nil. Can also be set to a table, in which case that table will be indexed.\n\n\n\t\t  newindex(table, index, value)\n\t\t  Fires when table[index] tries to be set (table[index] = value), if table[index] is nil. Can also be set to a table, in which case that table will be indexed.\n\n\n\t\t  call(table, ...)\n\t\t  Fires when the table is called like a function, ... is the arguments that were passed.\n\n\n\t\t  concat(table, value)\n\t\t  Fires when the .. concatenation operator is used on the table.\n\n\n\t\t  unm(table)\n\t\t  Fires when the unary – operator is used on the table.\n\n\n\t\t  add(table, value)\n\t\t  The + addition operator.\n\n\n\t\t  sub(table, value)\n\t\t  The – subtraction operator.\n\n\n\t\t  mul(table, value)\n\t\t  The  multiplication operator.\n\n\n\t\t  div(table, value)\n\t\t  The / division operator.\n\n\n\t\t  idiv(table, value)\n\t\t  The // floor division operator.\n\n\n\t\t  mod(table, value)\n\t\t  The % modulus operator.\n\n\n\t\t  pow(table, value)\n\t\t  The ^ exponentiation operator.\n\n\n\t\t  tostring(table)\n\t\t  Fired when tostring is called on the table.\n\n\n\t\t  metatable\n\t\t  If present, locks the metatable so Global.LuaGlobals.getmetatable() will return this instead of the metatable and Global.LuaGlobals.setmetatable() will error. Non-function value.\n\n\n\t\t  eq(table, value)\n\t\t  The == equal to operator¹\n\n\n\t\t  lt(table, value)\n\t\t  The\n\n\n\t\t  le(table, value)\n\t\t  The\n\n\n\t\t  mode\n\t\t  Used in weak tables, declaring whether the keys and/or values of a table are weak. Note that references to Roblox instances are never weak. Tables that hold such references will never be garbage collected.\n\n\n\t\t  len(table)\n\t\t  Fired when the # length operator is used on the object.\n\n\n\t\t  iter(table)\n\t\t  Used to denote a custom iterator when using generalized iteration.\n\n\n\n¹ Requires two values with the same metamethod function and basic type\n(table/userdata/etc.); does not work with a table and another random table, or\nwith a userdata and a table.\n\nIf you want to override relational comparison for your type, you must implement lt. By default, all four operators (, >=) will call it and interpret the result according to relational identities (aa, a= will use it instead of inverting the result of lt.\n\nIt should be noted that when writing functions for either arithmetic or relational metamethods the two function parameters are interchangeable between the table that fired the metamethod and the other value. For example, when doing vector operations with scalars division is not commutative. Therefore if you were writing metamethods for your own vector2 class, you'd want to be careful to account for either scenario.\n\nlua\nlocal vector2 = {type = \"vector2\"}\nlocal mt = {index = vector2}\n\nfunction mt.div(a, b)\n\tif type(a) == \"number\" then\n\t\t-- a is a scalar, b is a vector\n\t\tlocal scalar, vector = a, b\n\t\treturn vector2.new(scalar / vector.x, scalar / vector.y)\n\telseif type(b) == \"number\" then\n\t\t-- a is a vector, b is a scalar\n\t\tlocal vector, scalar = a, b\n\t\treturn vector2.new(vector.x / scalar, vector.y / scalar)\n\telseif (a.type and a.type == \"vector2\" and b.type and b.type == \"vector2\") then\n\t\t-- both a and b are vectors\n\t\treturn vector2.new(a.x / b.x, a.y / b.y)\n\tend\nend\n\nfunction mt.tostring(t)\n\treturn t.x .. \", \" .. t.y\nend\n\nfunction vector2.new(x, y)\n\tlocal self = setmetatable({}, mt)\n\tself.x = x or 0\n\tself.y = y or 0\n\treturn self\nend\n\nlocal a = vector2.new(10, 5)\nlocal b = vector2.new(-3, 4)\n\nprint(a / b) -- -3.3333333333333, 1.25\nprint(b / a) -- -0.3, 0.8\nprint(2 / a) -- 0.2, 0.4\nprint(a / 2) -- 5, 2.5\n\nUsage\n\nThere are many ways to use metatables, for example the unm metamethod to make a table negative:\n\nlua\nlocal metatable = {\n\tunm = function(t) -- unm is for the unary - operator\n    local negated = {}\n  \tfor key, value in t do\n  \t\tnegated[key] = -value -- negate all of the values in this table\n  \tend\n  \treturn negated -- return the table\n\tend\n}\n\nlocal table1 = setmetatable({10, 11, 12}, metatable)\nprint(table.concat(-table1, \"; \")) --> -10; -11; -12\n\nHere's an interesting way to declare things using index:\n\nlua\nlocal metatable = {\n\tindex = {x = 1}\n}\n\nlocal t = setmetatable({}, metatable)\nprint(t.x) --> 1\n\nindex was fired when x was indexed in the table and not found. Luau then searched through the index table for an index called x, and, finding one, returned that.\n\nNow you can easily do that with a simple function, but there's a lot more where\nthat came from. Take this for example:\n\nlua\nlocal t = {10, 20, 30}\nprint(t(5))\n\nTypically you can't call a table, but with metatables you can:\n\nlua\nlocal metatable = {\n\tcall = function(t, param)\n\tlocal sum = {}\n\t\tfor i, value in ipairs(t) do\n\t\t\tsum[i] = value + param -- Add the argument (5) to the value, then place it in the new table (t).\n\t\tend\n\t\treturn unpack(sum) -- Return the individual table values\n\tend\n}\n\nlocal t = setmetatable({10, 20, 30}, metatable)\nprint(t(5)) --> 15 25 35\n\nYou can do a lot more as well, such as adding tables:\n\nlua\nlocal table1 = {10, 11, 12}\nlocal table2 = {13, 14, 15}\n\nfor k, v in table1 + table2 do\n\tprint(k, v)\nend\n\nThis will error saying that you're attempting to perform arithmetic on a table, but it works when attempted with a metatable:\n\nlua\nlocal metatable = {\n\tadd = function(t1, t2)\n\t\tlocal sum = {}\n\t\tfor key, value in t1 do\n\t\t\tsum[key] = value\n\t\tend\n\n\t\tfor key, value in t2 do\n\t\t\tif sum[key] then\n\t\t\t\tsum[key] += value\n\t\t\telse\n\t\t\t\tsum[key] = value\n\t\t\tend\n\t\tend\n\t\treturn sum\n\tend\n}\n\nlocal table1 = setmetatable({10, 11, 12}, metatable)\nlocal table2 = setmetatable({13, 14, 15}, metatable)\n\nfor k, v in table1 + table2 do\n\tprint(k, v)\nend\n\nWhen playing with metatables, you may run into some problems. If you need to use the index metamethod to create new values in a table, but that table's metatable also has a newindex metamethod, you'll want to use the Luau built-in function Global.LuaGlobals.rawset() to set the value without invoking any metamethods. Take the following code as an example of what happens if you don't use these functions.\n\nlua\nlocal t = setmetatable({}, {\n    index = function(self, i)\n    \tself[i] = i  10\n    \treturn self[i]\n    end,\n    newindex = function(self, i, v)\n    \t-- Don't set values to the table the normal way\n    end\n})\nprint(t[1]) -- Causes a stack overflow\n\nStack overflows happen when you try to call a function from itself too many times. In the index function above, self[i] is set to a value, so when it gets to the next line, self[i] should exist and presumably won't call the index metamethod. The problem is that newindex doesn't let you set the value. Its presence stops values from being added to the table with the standard t[i] = v method. In order to get past this, use the Global.LuaGlobals.rawset() function:\n\nlua\nlocal t = setmetatable({}, {\n\tindex = function(self, i)\n\t\trawset(self, i, i  10)\n\t\treturn self[i]\n\tend,\n\tnewindex = function(self, i, v)\n\t\t-- Don't set values to the table the normal way\n\tend\n})\nprint(t[1]) --> 10\n\nUse the set datatype\n\nA set is a collection of items with no order and no duplicate elements. An item either is or is not contained within a set. Using metatables, you can construct and manipulate sets within Luau scripts.\n\nBasic methods\n\nThe following code includes basic set functionality, letting you construct new\nsets, add and remove an item, check if a set contains an item, and output the\ncontents of a set.\n\nlua\nlocal Set = {}\nSet.index = Set\n\n-- Function to construct a set from an optional list of items\nfunction Set.new(items)\n\tlocal newSet = {}\n\tfor key, value in items or {} do\n\t\tnewSet[value] = true\n\tend\n\treturn setmetatable(newSet, Set)\nend\n\n-- Function to add an item to a set\nfunction Set:add(item)\n\tself[item] = true\nend\n\n-- Function to remove an item from a set\nfunction Set:remove(item)\n\tself[item] = nil\nend\n\n-- Function to check if a set contains an item\nfunction Set:contains(item)\n\treturn self[item] == true\nend\n\n-- Function to output set as a comma-delimited list for debugging\nfunction Set:output()\n\tlocal elems = {}\n\tfor key, value in self do\n\t\ttable.insert(elems, tostring(key))\n\tend\n\tprint(table.concat(elems, \", \"))\nend\n\nCreate set\n\nA new set can be constructed by calling Set.new() with an optional array of items to add.\n\nlua\nlocal fruits = Set.new({\"Apple\", \"Lemon\", \"Orange\", \"Cherry\", \"Lime\", \"Peach\"})\n\nNote that by definition, a set has no concept of ordering.\n\nAdd item\n\nAdding an item to an existing set can be done via the Set:add() method.\n\nlua\nlocal fruits = Set.new({\"Apple\", \"Lemon\", \"Orange\", \"Cherry\", \"Lime\", \"Peach\"})\nfruits:add(\"Mango\")\n\nRemove item\n\nTo remove an item from a set, call Set:remove() with the item name.\n\nlua\nlocal fruits = Set.new({\"Apple\", \"Lemon\", \"Orange\", \"Cherry\", \"Lime\", \"Peach\"})\nfruits:remove(\"Orange\")\n\nCheck for item\n\nTo check if a set contains a specific item, use Set:contains().\n\nlua\nlocal fruits = Set.new({\"Apple\", \"Lemon\", \"Orange\", \"Cherry\", \"Lime\", \"Peach\"})\n\nlocal result1 = fruits:contains(\"Cherry\")\nprint(result1) -- true\n\nlocal result2 = fruits:contains(\"Watermelon\")\nprint(result2) -- false\n\nAdditional methods\n\nOther useful operations can be implemented for sets, letting you compare items between sets, combine sets, or subtract one set from another.\n\nIntersection\n\nWhen considering sets as Venn diagrams, you can get the intersection of two sets as follows, meaning the items that appear in both sets.\n\nlua\nlocal function getIntersection(set1, set2)\n\tlocal result = Set.new()\n\tfor key, value in set1 do\n\t\tif set2:contains(key) then\n\t\t\tresult:add(key)\n\t\tend\n\tend\n\treturn result\nend\n\nlocal freshFruits = Set.new({\"Mango\", \"Lemon\", \"Orange\", \"Cherry\", \"Lime\", \"Peach\"})\nlocal frozenFruits = Set.new({\"Mango\", \"Peach\", \"Pineapple\"})\n\nlocal commonFruits = getIntersection(freshFruits, frozenFruits)\ncommonFruits:output() -- Mango, Peach\n\nUnion\n\nYou can get the union of two sets with the following function, meaning a collection of the items in both sets with no duplicates. Note that this function uses the metatable add method to provide an addition shortcut of set1 + set2.\n\nlua\nfunction Set:add(otherSet)\n\tlocal result = Set.new()\n\tfor entry in self do\n\t\tresult[entry] = true\n\tend\n\tfor entry in otherSet do\n\t\tresult[entry] = true\n\tend\n\treturn result\nend\n\nlocal sweetFruits = Set.new({\"Apple\", \"Mango\", \"Cherry\", \"Peach\"})\nlocal sourFruits = Set.new({\"Lemon\", \"Lime\"})\n\nlocal allFruits = sweetFruits + sourFruits\nallFruits:output() -- Peach, Lime, Apple, Cherry, Lemon, Mango\n\nSubtraction\n\nYou can remove all items in one set from the items in another set via the following function. Similar to the function above, this uses the metatable sub method to provide a subtraction shortcut of set1 - set2.\n\nlua\nfunction Set:sub(otherSet)\n\tlocal result = Set.new()\n\tfor entry in self do\n\t\tresult[entry] = true\n\tend\n\tfor entry in otherSet do\n\t\tresult[entry] = nil\n\tend\n\treturn result\nend\n\nlocal allFruits = Set.new({\"Apple\", \"Lemon\", \"Mango\", \"Cherry\", \"Lime\", \"Peach\"})\nlocal sourFruits = Set.new({\"Lemon\", \"Lime\"})\n\nlocal sweetFruits = allFruits - sourFruits\nsweetFruits:output() -- Mango, Apple, Cherry, Peach",
    "source": "metatables.md"
}