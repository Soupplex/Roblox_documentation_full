{
    "title": "Data store versioning, listing, and caching",
    "description": "How to manage data stores (DataStores) through versioning, listing, and caching.",
    "content": "Manage your data using versioning, listing, and caching.\n\nVersioning\n\nVersioning happens when you set, update, and increment data. The functions Class.GlobalDataStore:SetAsync()|SetAsync(), Class.GlobalDataStore:UpdateAsync()|UpdateAsync(), and Class.GlobalDataStore:IncrementAsync()|IncrementAsync() create versioned backups of your data using the first write to each key in each UTC hour. Successive writes to a key in the same UTC hour permanently overwrite the previous data.\n\nVersioned backups expire 30 days after a new write overwrites them. The latest version never expires.\n\nThe following functions perform versioning operations:\n\n\n    Function\n    Description\n\n\n\n\n      Class.DataStore:ListVersionsAsync()|ListVersionsAsync()\n\n\n      Lists all versions for a key by returning a Class.DataStoreVersionPages instance that you can use to enumerate all version numbers. You can filter versions using a time range.\n\n\n\n\n      Class.DataStore:GetVersionAsync()|GetVersionAsync()\n\n\n      Retrieves a specific version of a key using the key's version number.\n\n\n\n\n      Class.DataStore:RemoveVersionAsync()|RemoveVersionAsync()\n\n\n      Deletes a specific version of a key.\n\n      This function also creates a tombstone version while retaining the previous version. For example, if you call RemoveAsync(\"User1234\") and then try to call GetAsync(\"User1234\"), you get nil back. However, you can still use Class.DataStore:ListVersionsAsync()|ListVersionsAsync() and Class.DataStore:GetVersionAsync()|GetVersionAsync() to retrieve older versions of the data.\n\n\n\n\nYou can use versioning to handle user requests. If a user reports that a problem occurred at 2020-10-09T01:42, you can revert data to a previous version using the following example:\n\nlua\nlocal DataStoreService = game:GetService(\"DataStoreService\")\n\nlocal experienceStore = DataStoreService:GetDataStore(\"PlayerExperience\")\n\nlocal DATASTOREKEY = \"User1234\"\n\nlocal maxDate = DateTime.fromUniversalTime(2020, 10, 09, 01, 42)\n\n-- Gets the version closest to the given time\nlocal listSuccess, pages = pcall(function()\n    return experienceStore:ListVersionsAsync(DATASTOREKEY, Enum.SortDirection.Descending, nil, maxDate.UnixTimestampMillis)\nend)\nif listSuccess then\n    local items = pages:GetCurrentPage()\n    if #items > 0 then\n        -- Reads the closest version\n        local closestEntry = items[1]\n        local success, value, info = pcall(function()\n            return experienceStore:GetVersionAsync(DATASTOREKEY, closestEntry.Version)\n        end)\n        -- Restores current value by overwriting it with the closest version\n        if success then\n            local setOptions = Instance.new(\"DataStoreSetOptions\")\n            setOptions:SetMetadata(info:GetMetadata())\n            experienceStore:SetAsync(DATASTOREKEY, value, nil, setOptions)\n        end\n    else\n        -- No entries found\n    end\nend\n\nSnapshots\n\nThe Snapshot Data Stores Open Cloud API lets you take a snapshot of all data stores in an experience once a day. Before you publish any experience update that changes your data storage logic, make sure to take a snapshot. Taking a snapshot guarantees that you have the most recent data available from the previous version of the experience.\n\nFor example, without a snapshot, if you publish an update at 3:30 UTC that causes data corruption, the corrupted data overwrites any data written between 3:00-3:30 UTC. If you take a snapshot at 3:29 UTC, though, the corrupted data doesn't overwrite anything written before 3:29 UTC, and the latest data for all keys written between 3:00-3:29 UTC is preserved.\n\nListing and prefixes\n\nData stores let you list by prefix. For example, listing by the first n characters of a name, like \"d\" , \"do\", or \"dog\" for any key or data store with a prefix of \"dog\".\n\nYou can specify a prefix when listing all data stores or keys, and get back only objects that match that prefix. Both Class.DataStoreService:ListDataStoresAsync()|ListDataStoresAsync() and Class.DataStore:ListKeysAsync()|ListKeysAsync() functions return a Class.DataStoreListingPages object that you can use to enumerate the list.\n\n\n    Function\n    Description\n\n\n\n    Class.DataStoreService:ListDataStoresAsync()|ListDataStoresAsync()\n    Lists all data stores.\n\n\n    Class.DataStore:ListKeysAsync()|ListKeysAsync()\n    Lists all keys in a data store.\n\n\nScopes\n\n  For new experiences, use listing and prefixes to organize keys in your data store instead of the legacy scopes feature. For existing experiences that use scopes, continue using them.\n\nYou can organize keys in a data store further by setting a unique string as a scope for the second parameter of Class.DataStoreService:GetDataStore()|GetDataStore(). The default scope (if no scope is given) is global. The scope is automatically prepended to the beginning of all keys in all operations done on the data store.\n\n\n    Key\n    Scope\n\n\n\n    houses/User1234\n    houses\n\n\n    pets/User1234\n    pets\n\n\n    inventory/User1234\n    inventory\n\n\nThe combination of data store name, scope, and key uniquely identifies a key. All three values are required to identify a key with a scope. For example, you can read a global-scoped key named User1234 as:\n\nlua\nlocal DataStoreService = game:GetService(\"DataStoreService\")\nlocal inventoryStore = DataStoreService:GetDataStore(\"PlayerInventory\")\nlocal success, currentGold = pcall(function()\n  return inventoryStore:GetAsync(\"User1234\")\nend)\n\nIf the key User1234 has a scope of gold, though, you can only read it as:\n\nlua\nlocal DataStoreService = game:GetService(\"DataStoreService\")\nlocal inventoryStore = DataStoreService:GetDataStore(\"PlayerInventory\", \"gold\")\nlocal success, currentGold = pcall(function()\n  return inventoryStore:GetAsync(\"User1234\")\nend)\n\nAllScopes property\n\nClass.DataStoreOptions contains an Class.DataStoreOptions.AllScopes|AllScopes property that lets you return keys from all scopes in a list. You can then use the Class.DataStoreKey.KeyName|KeyName property of a list item for common data store operations like reading data with Class.GlobalDataStore:GetAsync()|GetAsync() and removing data with Class.GlobalDataStore:RemoveAsync()|RemoveAsync().\n\nWhen you use the AllScopes property, the second parameter of Class.DataStoreService:GetDataStore()|GetDataStore() must be an empty string (\"\").\n\nlua\nlocal DataStoreService = game:GetService(\"DataStoreService\")\n\nlocal options = Instance.new(\"DataStoreOptions\")\noptions.AllScopes = true\n\nlocal ds = DataStoreService:GetDataStore(\"DS1\", \"\", options)\n\n  When you use the Class.DataStoreOptions.AllScopes|AllScopes property, Class.DataStore:ListKeysAsync()|ListKeysAsync() returns every key with their scope as the prefix argument, such as global/playerdata1234 or houses/house3. Remember that the default scope is global.\n\nIf you enable the Class.DataStoreOptions.AllScopes|AllScopes property and create a new key in the data store, you must always specify a scope for that key in the format of scope/keyname. If you don't, the APIs throw an error. For example, gold/player34545 is acceptable with gold as the scope, but player34545 leads to an error.\n\n\n    global/K1\n    house/K1\n\n\n    global/L2\n    house/L2\n\n\n    global/M3\n    house/M3\n\n\nCaching\n\nUse caching to temporarily store data from data stores to improve performance and reduce the number of requests made to the server. For example, an experience can cache a copy of its data so that it can access that data quickly without having to make another call to the data store.\n\nCaching applies to modifications you make to data store keys using:\n\n- Class.GlobalDataStore:GetAsync()|GetAsync() to read data.\n- Class.GlobalDataStore:SetAsync()|SetAsync() to create data.\n- Class.GlobalDataStore:UpdateAsync()|UpdateAsync() to update data.\n- Class.GlobalDataStore:IncrementAsync()|IncrementAsync() to increment data.\n- Class.GlobalDataStore:RemoveAsync()|RemoveAsync() to remove data.\n\nClass.DataStore:GetVersionAsync()|GetVersionAsync(), Class.DataStore:ListVersionsAsync()|ListVersionsAsync(), Class.DataStore:ListKeysAsync()|ListKeysAsync(), and Class.DataStoreService:ListDataStoresAsync()|ListDataStoresAsync() don't implement caching and always fetch the latest data from the service backend.\n\nBy default, the engine uses Class.GlobalDataStore:GetAsync()|GetAsync() to store values you retrieve from the backend in a local cache for four seconds. Also by default, Class.GlobalDataStore:GetAsync()|GetAsync() requests for cached keys return the cached value instead of continuing to the backend. Your Class.GlobalDataStore:GetAsync()|GetAsync() requests that return a cached value don't count towards your server limits and throughput limits.\n\nAll Class.GlobalDataStore:GetAsync()|GetAsync() calls that retrieve a value not being cached from the backend update the cache immediately and restart the four second timer.\n\n  Caching is local to a particular data store instance, so different data stores can have their caches in different states. For example, if you access a key twice through two different data store instances, like getting one data store with a specified scope and another through having the Class.DataStoreOptions.AllScopes|AllScopes property enabled, each data store instance has its own cache. If you change the value of that key in one data store instance and not the other, you end up with inconsistent data.\n\nDisable caching\n\nTo disable caching and opt out of using the cache to retrieve the most up-to-date value from the servers, add the Class.DataStoreGetOptions parameter to your Class.GlobalDataStore:GetAsync()|GetAsync() call and set the Class.DataStoreGetOptions.UseCache|UseCache property to false to make your request ignore any keys in the cache.\n\nDisabling caching is useful if you have multiple servers writing to a key with high frequency and need to get the latest value from servers. However, it can cause you to consume more of your data stores limits and quotas, since Class.GlobalDataStore:GetAsync()|GetAsync() requests bypassing caching always count towards your throughput and server limits.\n\nSerialization\n\nThe Class.DataStoreService stores data in JSON format. When you save Luau data in Studio, Roblox uses a process called serialization to convert that data into JSON to save it in data stores. Roblox then converts your data back to Luau and returns it to you in another process called deserialization.\n\nSerialization and deserialization support the following Luau data types:\n\n- Nil\n- Booleans\n- Numbers\n  - You should not store the special numeric values inf, -inf, and nan, because these values don't conform to JSON standards. You can't access keys that contain these values with Open Cloud.\n- Strings\n- Tables\n  - Tables must only contain other supported data types\n  - Numeric keys are translated into strings if the length of the table is 0\n- Buffers\n\nIf you try to store a data type that serialization doesn't support, you either:\n\n- Fail in storing that data type and get an error message.\n- Succeed in storing that data type as nil.\n\nTo debug why your data type is being stored as nil, you can use the Class.HttpService.JSONEncode|JSONEncode function. When you pass your Luau data type into this function, you receive it back in the format Roblox would have stored it with data stores, which lets you preview and investigate the returned data.\n\n  Serialization doesn't happen when you use the DataStore Open Cloud API because that data is already sent to Roblox in JSON format and doesn't need to be converted.",
    "source": "versioning-listing-and-caching.md"
}