{
    "title": "Type checking",
    "description": "Luau uses gradual typing through the use of type annotations and inference.",
    "content": "For the latest and most complete type checking documentation, see here.\n\nLuau supports a gradual type system through the use of type annotations and type inference. These types are used to provide better warnings, errors, and suggestions in the Script Editor.\n\nDefine a type\n\nUse the type keyword to define your own types:\n\nlua\ntype Vector2 = {x: number, y: number}\n\nInference modes\n\nThere are three Luau type inference modes that can be set on the first line of a Class.Script:\n\n- --!nocheck — Don't check types.\n- --!nonstrict — Only asserts variable types if they are explicitly annotated.\n- --!strict — Asserts all types based off the inferred or explicitly annotated type.\n\nThe --!nonstrict and --!strict modes control how strict the type checker is with inferring and checking types for variables and functions. Any type mismatches in scripts are highlighted in the Script Editor and surfaced as warnings in the Script Analysis window.\n\nTo set a default mode for all scripts that you can override as needed, see Class.Workspace.LuauTypeCheckMode.\n\nTypes\n\nA type annotation can be defined using the : operator after a local variable, followed by a type definition. By default, in nonstrict mode, all variables are assigned the type any.\n\nlua\nlocal foo: string = \"bar\"\nlocal x: number = 5\n\nThere are four primitive types that can be used in an annotation:\n\n- nil - no value\n- boolean - true or false\n- number - a numeric value\n- string - text\n\nWithin Roblox, all classes, data types, and enums have their own types that you can check against:\n\nlua\nlocal somePart: Part = Instance.new(\"Part\")\nlocal brickColor: BrickColor = somePart.BrickColor\nlocal material: Enum.Material = somePart.Material\n\nTo make a type optional, use a ? at the end of the annotation:\n\nlua\nlocal foo: string? = nil\n\nThis will allow the variable to be either the specified type (in this case string) or nil.\n\nLiteral types\n\nYou can also cast strings and booleans to literal values instead of using string and boolean:\n\nlua\nlocal alwaysHelloWorld: \"Hello world!\" = \"Hello world!\"\nalwaysHelloWorld = \"Just hello!\"  -- Type error: Type '\"Just hello!\"' could not be converted into '\"Hello world!\"'\n\nlocal alwaysTrue: true = false  -- Type error: Type 'false' could not be converted into 'true'\n\nType casts\n\nSometimes, you might need to assist the typechecker by explicitly casting a value to a different type with the :: operator:\n\nlua\nlocal myNumber = 1\nlocal myString: string\n\nmyString = myNumber  -- Not OK; type conversion error\nmyString = myNumber :: any  -- OK; all expressions can be cast to 'any'\nlocal myFlag = myNumber :: boolean  -- Not OK; types are unrelated\n\nFunction typing\n\nConsider the following function:\n\nlua\nlocal function add(x, y)\n\treturn x + y\nend\n\nThis function adds x to y, but errors if one or both of them is a string. Luau doesn't know that this function can only use numbers. To prevent this category of problem, add types to the parameters:\n\nlua\nlocal function add(x: number, y: number)\n\treturn x + y\nend\n\nLuau now knows that the function takes two numbers and throws a warning if you try to pass anything that isn't a number into the function:\n\nlua\nadd(5, 10)\nadd(5, \"foo\")  -- Type error: string could not be converted into number\n\nTo define a return type, put a : operator at the end of the function definition:\n\nlua\nlocal function add(x: number, y: number): number\n\nTo return multiple types, place the types in parentheses:\n\nlua\nlocal function FindSource(script: BaseScript, pattern: string): (string, number)\n\treturn 42, true  -- Type errors\nend\n\nDefine a functional type\n\nA functional type can be defined by using the syntax (in) -> out. Using the functions from the previous examples, the types of the functions are:\n\nlua\ntype add = (x: number, y: number) -> number\ntype FindSource = (script: BaseScript, pattern: string) -> (string, number)\n\nTable types\n\nLuau does not have a table type; instead, table types are defined using {} syntax. One way of defining tables is using the {type} syntax, which defines a list type.\n\nlua\nlocal numbers: {number} = {1, 2, 3, 4, 5}\nlocal characterParts: {Instance} = LocalPlayer.Character:GetChildren()\n\nDefine index types using {[indexType]: valueType}:\n\nlua\nlocal numberList: {[string]: number} = {\n\tFoo = 1,\n\tBaz = 10\n}\n\nnumberList[\"bar\"] = true  -- Type error: boolean can't convert to number\n\nTables can also have explicit string indices defined in a type.\n\nlua\ntype Car = {\n\tSpeed: number,\n\tDrive: (Car) -> ()\n}\n\nlocal function drive(car)\n\t-- Always go the speed limit\nend\n\nlocal taxi: Car = {Speed = 30, Drive = drive}\n\nVariadics\n\nHere's a function that calculates the sum of an arbitrary amount of numbers:\n\nlua\nlocal function addLotsOfNumbers(...)\n\tlocal sum = 0\n\n\tfor , v in {...} do\n\t\tsum += v\n\tend\n\n\treturn sum\nend\n\nAs expected, this function can take any value, and the typechecker won't raise a warning if you provide an invalid type, such as a string.\n\nlua\nprint(addLotsOfNumbers(1, 2, 3, 4, 5))  -- 15\nprint(addLotsOfNumbers(1, 2, \"car\", 4, 5))  -- Attempt to add string to number\n\nInstead, assign a type to the ..., just like how you assign any other type:\n\nlua\nlocal function addLotsOfNumbers(...: number)\n\nAnd now, the second line raises a type error.\n\nlua\nprint(addLotsOfNumbers(1, 2, 3, 4, 5))\nprint(addLotsOfNumbers(1, 2, \"car\", 4, 5))  -- Type error: string could not be converted into number\n\nHowever, this does not work when writing a functional type definition:\n\nlua\ntype addLotsOfNumbers = (...: number) -> number  -- Expected type, got ':'\n\nInstead, use the syntax ...type to define a variadic type.\n\nlua\ntype addLotsOfNumbers = (...number) -> number\n\nUnions and intersections\n\nYou can even define a type as two or more types using a union or intersection:\n\nlua\ntype numberOrString = number | string\ntype type1 = {foo: string}\ntype type2 = {bar: number}\ntype type1and2 = type1 & type2  -- {foo: string} & {bar: number}\n\nlocal numString1: numberOrString = true  -- Type error\nlocal numString2: type1and2 = {foo = \"hello\", bar = 1}\n\nDefine an inferred type\n\nYou can use the typeof function in a type definition for inferred types:\n\nlua\ntype Car = typeof({\n\tSpeed = 0,\n\tWheels = 4\n})  --> Car: {Speed: number, Wheels: number}\n\nOne way to use typeof is to define a metatable type using setmetatable inside the typeof function:\n\nlua\ntype Vector = typeof(setmetatable({}::{\n\tx: number,\n\ty: number\n}, {}::{\n\tadd: (Vector, Vector|number) -> Vector\n}))\n\n-- Vector + Vector would return a Vector type\n\nGenerics\n\nGenerics are at a basic level parameters for types. Consider the following State object:\n\nlua\nlocal State = {\n\tKey = \"TimesClicked\",\n\tValue = 0\n}\n\nWithout generics, the type for this object would be as follows:\n\nlua\ntype State = {\n\tKey: string,\n\tValue: number\n}\n\nHowever, you might want the type for Value to be based on the incoming value, which is where generics come in:\n\nlua\ntype GenericType = T\n\nThe  denotes a type that can be set to anything. The best way to visualize this is as a substitution type.\n\nlua\ntype List = {T}\n\nlocal Names: List = {\"Bob\", \"Dan\", \"Mary\"}  -- Type becomes {string}\nlocal Fibonacci: List = {1, 1, 2, 3, 5, 8, 13}  -- Type becomes {number}\n\nGenerics can also have multiple substitutions inside the brackets.\n\nlua\ntype Map = {[K]: V}\n\nTo rework the State object from earlier to use a generic type:\n\nlua\ntype State = {\n\tKey: string,\n\tValue: T\n}\n\nFunction generics\n\nFunctions can also use generics. The State example infers the value of T from the function's incoming arguments.\n\nTo define a generic function, add a <> to the function name:\n\nlua\nlocal function State(key: string, value: T): State\n\treturn {\n\t\tKey = key,\n\t\tValue = value\n\t}\nend\n\nlocal Activated = State(\"Activated\", false)  -- State\nlocal TimesClicked = State(\"TimesClicked\", 0)  -- State\n\nType exports\n\nTo make it so a type can be used outside of a Class.ModuleScript, use the export keyword:\n\nlua title=\"Types Module in ReplicatedStorage\"\nexport type Cat = {\n\tName: string,\n\tMeow: (Cat) -> ()\n}\n\nlua title=\"Script Using the Types Module\"\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Types = require(ReplicatedStorage.Types)\n\nlocal newCat: Types.Cat = {\n\tName = \"metatablecat\",\n\tMeow = function(self)\n\t\tprint({self.Name} said meow)\n\tend\n}\n\nnewCat:Meow()",
    "source": "type-checking.md"
}