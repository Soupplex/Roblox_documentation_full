{
    "title": "Parallel Luau",
    "description": "Parallel Luau runs code on multiple threads simultaneously.",
    "content": "With the Parallel Luau programming model, you can run code on multiple threads simultaneously, which can improve the performance of your experience. As you expand your experience with more content, you can adopt this model to help maintain the performance and safety of your Luau scripts.\n\nParallel programming model\n\nBy default, scripts execute sequentially. If your experience has complex logic or content, such as non-player characters (NPCs), raycasting validation, and procedural generation, then sequential execution might cause lag for your users. With the parallel programming model, you can split tasks into multiple scripts and run them in parallel. This makes your experience code run faster, which improves the user experience.\n\nThe parallel programming model also adds safety benefits to your code. By splitting code into multiple threads, when you edit code in one thread, it doesn't affect other code running in parallel. This reduces the risk of having one bug in your code corrupting the entire experience, and minimizes the delay for users in live servers when you push an update.\n\nAdopting the parallel programming model doesn't mean to put everything in multiple threads. For example, the server-side raycasting validation sets each individual user a remote event in parallel but still requires the initial code to run serially to change global properties, which is a common pattern for parallel execution.\n\nMost times you need to combine serial and parallel phases to achieve your desired output, since currently there are some operations not supported in parallel that can prevent scripts from running, such as modifying instances in parallel phases. For more information on the level of usage of APIs in parallel, see thread safety.\n\nSplit code into multiple threads\n\nTo run your experience's scripts in multiple threads concurrently, you need to split them into logical chunks under different actors in the data model. Actors are represented by Class.Actor instances inheriting from Class.DataModel. They work as units of execution isolation that distribute the load across multiple cores running simultaneously.\n\nPlace actor instances\n\nYou can put actors in proper containers or use them to replace the top-level instance types of your 3D entities such as NPCs and raycasters, then add corresponding scripts.\n\nFor most situations, you shouldn't put an actor as a child of another actor in the data model. However, if you decide to place a script nested within multiple actors for your specific use case, the script is owned by its closest ancestor actor.\n\nDesynchronize threads\n\nThough putting scripts under actors grants them the capability for parallel execution, by default the code still runs on the single thread serially, which doesn't improve the runtime performance. You need to call Library.task.desynchronize(), a yieldable function that suspends the execution of the current coroutine for running code in parallel and resumes it at the next parallel execution opportunity. To switch a script back to serial execution, call Library.task.synchronize().\n\nAlternatively, you can use Datatype.RBXScriptSignal:ConnectParallel() method when you want to schedule a signal callback to immediately run your code in parallel upon triggering. You don't need to call Library.task.desynchronize() inside the signal callback.\n\nlua title=\"Desynchronize a Thread\"\nlocal RunService = game:GetService(\"RunService\")\n\nRunService.Heartbeat:ConnectParallel(function()\n\t...  -- Some parallel code that computes a state update\n\n\ttask.synchronize()\n\n\t...  -- Some serial code that changes the state of instances\nend)\n\nYou can't use require() in a desynchronized parallel phase. Require scripts you want to use first in a serial context.\n\nScripts that are part of the same actor always execute sequentially with respect to each other, so you need multiple actors. For example, if you put all parallel-enabled behavior scripts for your NPC in one actor, they still run serially on a single thread, but if you have multiple actors for different NPC logic, each of them runs in parallel on its own thread. For more information, see Best practices.\n\n\n\n    Parallel code in Actors running serially in a single thread\n\n\n\n    Parallel code in Actors running simultaneously in multiple threads\n\n\nThread safety\n\nDuring the parallel execution, you can access most instances of the Class.DataModel hierarchy as usual, but some API properties and functions aren't safe to read or write. If you use them in your parallel code, the Roblox engine can automatically detect and prevent these accesses from occurring.\n\nAPI members have a thread safety level that indicates whether and how you can use them in your parallel code, as the following table shows:\n\n\n\n\t\t\tSafety level\n\t\t\tFor properties\n\t\t\tFor functions\n\n\n\n\n\t\t\tUnsafe\n\t\t\tCannot be read or written in parallel.\n\t\t\tCannot be called in parallel.\n\n\n\t\t\tRead Parallel\n\t\t\tCan be read but not written in parallel.\n\t\t\tN/A\n\n\n\t\t\tLocal Safe\n\t\t\tCan be used within the same Actor; can be read but not written to by other Class.Actor|Actors in parallel.\n\t\t\tCan be called within the same Actor; cannot be called by other Class.Actor|Actors in parallel.\n\n\n\t\t\tSafe\n\t\t\tCan be read and written.\n\t\t\tCan be called.\n\n\n\nYou can find thread safety tags for API members on the API reference. When using them, you should also consider how API calls or property changes might interact between parallel threads. Usually it's safe for multiple actors to read the same data as other actors but not modify the state of other actors.\n\nIf an API member doesn't specify a thread safety level, by default its thread safety level is Unsafe.\n\nCross-thread communication\n\nUnder the multithreading context, you can still allow scripts in different actors to communicate with each other to exchange data, coordinate tasks, and synchronize activities. The engine supports the following mechanisms for cross-thread communication:\n\n- Actor messaging API for sending messages to an actor using scripts.\n- Shared table data structure for efficiently sharing a large amount of data between multiple actors on a shared state.\n- Direct data model communication for simple communication with restrictions.\n\nYou can support multiple mechanisms to accommodate your cross-thread communication needs. For example, you can send a shared table through the Actor Messaging API.\n\nActor messaging\n\nThe actor messaging API allows a script, either in a serial or parallel context, to send data to an actor in the same data model. Communication through this API is asynchronous, in which the sender doesn't block until the receiver receives the message.\n\nWhen sending messages using this API, you need to define a topic for categorizing the message. Each message can only be sent to a single actor, but that actor can internally have multiple callbacks bound to a message. Only scripts that are descendants of an actor can receive messages.\n\nThe API has the following methods:\n\n- Class.Actor:SendMessage() for sending a message to an actor.\n- Class.Actor:BindToMessage() for binding a Luau callback to a message with the specified topic in a serial context.\n- Class.Actor:BindToMessageParallel() for binding a Luau callback to a message with the specified topic in a parallel context.\n\nThe following example shows how to use Class.Actor:SendMessage() to define a topic and send a message on the sender's end:\n\nlua title=\"Example Message Sender\"\nlocal Workspace = game:GetService(\"Workspace\")\n\n-- Send two messages to the worker actor with a topic of \"Greeting\"\nlocal workerActor = Workspace.WorkerActor\nworkerActor:SendMessage(\"Greeting\", \"Hello World!\")\nworkerActor:SendMessage(\"Greeting\", \"Welcome\")\n\nprint(\"Sent messages\")\n\nThe following example shows how to use Class.Actor:BindToMessageParallel() to bind a callback for certain topic in a parallel context on the receiver's end:\n\nlua title=\"Example Message Receiver\"\n-- Get the actor this script is parented to\nlocal actor = script:GetActor()\n\n-- Bind a callback for the \"Greeting\" message topic\nactor:BindToMessageParallel(\"Greeting\", function(greetingString)\n\tprint(actor.Name, \"-\", greetingString)\nend)\n\nprint(\"Bound to messages\")\n\nShared table\n\nDatatype.SharedTable is a table-like data structure accessible from scripts running under multiple actors. It's useful for situations that involve a large amount of data and require a common shared state between multiple threads. For example, when multiple actors work on a common world state that is not stored in the data model.\n\nSending a shared table to another actor doesn't make a copy of the data. Instead, shared tables allow safe and atomic updates by multiple scripts simultaneously. Every update to a shared table by one actor is immediately visible to all actors. Shared tables can also be cloned in a resource-efficient process that utilizes structural sharing instead of copying the underlying data.\n\nDirect data model communication\n\nYou can also facilitate communication between multiple threads directly using the data model, in which different actors can write and subsequently read properties or attributes. However, to maintain the thread-safety, scripts running in parallel generally can't write to the data model. So directly using the data model for communication comes with restrictions and may force scripts to synchronize frequently, which can impact performance of your scripts.\n\nExamples\n\nServer-side raycasting validation\n\nFor a fighting and battle experience, you need to enable raycasting for your users' weapons. With the client simulating the weapons to achieve good latency, the server has to confirm the hit, which involves doing raycasts and some amount of heuristics that compute expected character velocity, and look at past behavior.\n\nInstead of using a single centralized script that connects to a remote event that clients use to communicate hit information, you can run each hit validation process on the server side in parallel with every user character having a separate remote event.\n\nThe server-side script that runs under that character's Class.Actor connects to this remote event using a parallel connection to run the relevant logic for confirming the hit. If the logic finds a confirmation of a hit, the damage is deducted, which involves changing properties, so it runs serially initially.\n\nlua\nlocal Workspace = game:GetService(\"Workspace\")\n\nlocal tool = script.Parent.Parent\n\nlocal remoteEvent = Instance.new(\"RemoteEvent\")  -- Create new remote event and parent it to the tool\nremoteEvent.Name = \"RemoteMouseEvent\"  -- Rename it so that the local script can look for it\nremoteEvent.Parent = tool\nlocal remoteEventConnection  -- Create a reference for the remote event connection\n\n-- Function which listens for a remote event\nlocal function onRemoteMouseEvent(player: Player, clickLocation: CFrame)\n\t-- SERIAL: Execute setup code in serial\n\tlocal character = player.Character\n\t-- Ignore the user's character while raycasting\n\tlocal params = RaycastParams.new()\n\tparams.FilterType = Enum.RaycastFilterType.Exclude\n\tparams.FilterDescendantsInstances = { character }\n\n\t-- PARALLEL: Perform the raycast in parallel\n\ttask.desynchronize()\n\tlocal origin = tool.Handle.CFrame.Position\n\tlocal epsilon = 0.01  -- Used to extend the ray slightly since the click location might be slightly offset from the object\n\tlocal lookDirection = (1 + epsilon)  (clickLocation.Position - origin)\n\tlocal raycastResult = Workspace:Raycast(origin, lookDirection, params)\n\tif raycastResult then\n\t\tlocal hitPart = raycastResult.Instance\n\t\tif hitPart and hitPart.Name == \"block\" then\n\t\t\tlocal explosion = Instance.new(\"Explosion\")\n\n\t\t\t-- SERIAL: The code below modifies state outside of the actor\n\t\t\ttask.synchronize()\n\t\t\texplosion.DestroyJointRadiusPercent = 0  -- Make the explosion non-deadly\n\t\t\texplosion.Position = clickLocation.Position\n\n\t\t\t-- Multiple actors could get the same part in a raycast and decide to destroy it\n\t\t\t-- This is perfectly safe but it would result in two explosions at once instead of one\n\t\t\t-- The following double checks that execution got to this part first\n\t\t\tif hitPart.Parent then\n\t\t\t\texplosion.Parent = Workspace\n\t\t\t\thitPart:Destroy()  -- Destroy it\n\t\t\tend\n\t\tend\n\tend\nend\n\n-- Connect the signal in serial initially since some setup code is not able to run in parallel\nremoteEventConnection = remoteEvent.OnServerEvent:Connect(onRemoteMouseEvent)\n\nServer-side procedural terrain generation\n\nTo create a vast world for your experience, you can populate the world dynamically. Procedural generation typically creates independent terrain chunks, with the generator performing relatively intricate calculations for object placement, material usage, and voxel filling. Running generation code in parallel can enhance efficiency of the process. The following code sample serves as an example.\n\nlua\n-- Parallel execution requires the use of actors\n-- This script clones itself; the original initiates the process, while the clones act as workers\nlocal Workspace = game:GetService(\"Workspace\")\n\nlocal actor = script:GetActor()\nif actor == nil then\n\tlocal workers = {}\n\tfor i = 1, 32 do\n\t\tlocal actor = Instance.new(\"Actor\")\n\t\tscript:Clone().Parent = actor\n\t\ttable.insert(workers, actor)\n\tend\n\n\t-- Parent all actors under self\n\tfor , actor in workers do\n\t\tactor.Parent = script\n\tend\n\n\t-- Instruct the actors to generate terrain by sending messages\n\t-- In this example, actors are chosen randomly\n\ttask.defer(function()\n\t\tlocal rand = Random.new()\n\t\tlocal seed = rand:NextNumber()\n\n\t\tlocal sz = 10\n\t\tfor x = -sz, sz do\n\t\t\tfor y = -sz, sz do\n\t\t\t\tfor z = -sz, sz do\n\t\t\t\t\tworkers[rand:NextInteger(1, #workers)]:SendMessage(\"GenerateChunk\", x, y, z, seed)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend)\n\n\t-- Exit from the original script; the rest of the code runs in each actor\n\treturn\nend\n\nfunction makeNdArray(numDim, size, elemValue)\n\tif numDim == 0 then\n\t\treturn elemValue\n\tend\n\tlocal result = {}\n\tfor i = 1, size do\n\t\tresult[i] = makeNdArray(numDim - 1, size, elemValue)\n\tend\n\treturn result\nend\n\nfunction generateVoxelsWithSeed(xd, yd, zd, seed)\n\tlocal matEnums = {Enum.Material.CrackedLava, Enum.Material.Basalt, Enum.Material.Asphalt}\n\tlocal materials = makeNdArray(3, 4, Enum.Material.CrackedLava)\n\tlocal occupancy = makeNdArray(3, 4, 1)\n\n\tlocal rand = Random.new()\n\n\tfor x = 0, 3 do\n\t\tfor y = 0, 3 do\n\t\t\tfor z = 0, 3 do\n\t\t\t\toccupancy[x + 1][y + 1][z + 1] = math.noise(xd + 0.25  x, yd + 0.25  y, zd + 0.25  z)\n\t\t\t\tmaterials[x + 1][y + 1][z + 1] = matEnums[rand:NextInteger(1, #matEnums)]\n\t\t\tend\n\t\tend\n\tend\n\n\treturn {materials = materials, occupancy = occupancy}\nend\n\n-- Bind the callback to be called in parallel execution context\nactor:BindToMessageParallel(\"GenerateChunk\", function(x, y, z, seed)\n\tlocal voxels = generateVoxelsWithSeed(x, y, z, seed)\n\tlocal corner = Vector3.new(x  16, y  16, z  16)\n\n\t-- Currently, WriteVoxels() must be called in the serial phase\n\ttask.synchronize()\n\tWorkspace.Terrain:WriteVoxels(\n\t\tRegion3.new(corner, corner + Vector3.new(16, 16, 16)),\n\t\t4,\n\t\tvoxels.materials,\n\t\tvoxels.occupancy\n\t)\nend)\n\nBest practices\n\nTo apply the maximum benefits of parallel programming, refer to the following best practices when adding your Luau code:\n\n- Avoid Long Computations — Even in parallel, long computations can block execution of other scripts and cause lag. Avoid using parallel programming to handle a large volume of long, unyielding calculations.\n\n\n\n- Use the Right Number of Actors — For the best performance, use more Class.Actor|Actors. Even if the device has fewer cores than Class.Actor|Actors, the granularity allows for more efficient load balancing between the cores.\n\n\n\n  This doesn't mean you should use as many Class.Actor|Actors as possible. You should still divide code into Class.Actor|Actors based on logic units rather than breaking code with connected logic to different Class.Actor|Actors. For example, if you want to enable raycasting validation in parallel, it's reasonable to use 64 Class.Actor|Actors and more instead of just 4, even if you're targeting 4-core systems. This is valuable for scalability of the system and allows it to distribute the work based on the capability of the underlying hardware. However, you also shouldn't use too many Class.Actor|Actors, which are hard to maintain.",
    "source": "multithreading.md"
}