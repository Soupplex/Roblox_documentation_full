{
    "title": "Memory store hash map",
    "description": "Explains how to implement the hash map data structure for memory stores.",
    "content": "Hash maps, similar to sorted maps, let you store in-memory data as key-value pairs. Unlike sorted maps, they maintain no ordering guarantees. This data structure is useful for cases that require simple data caching and rapid access, such as shared inventories, physical auction houses, and more. Hash maps automatically handle partitioning your data and are very useful if you have more than 1,000 keys. For smaller key spaces, we recommend sorted maps.\n\nLimits\n\nHash maps have a key size limit of 128 characters and a value size limit of 32 KB.\n\nOtherwise, hash maps use the same API request and memory quota limits as the other memory store data structures.\n\nGet a hash map\n\nTo get a hash map, call Class.MemoryStoreService:GetHashMap() with a name for the hash map. The name is global within the experience, so you can access the same hash map on any script using this name.\n\nlua title=\"Getting a Hash Map\"\nlocal MemoryStoreService = game:GetService(\"MemoryStoreService\")\n\nlocal hashMap = MemoryStoreService:GetHashMap(\"HashMap1\")\n\nAfter you get a hash map, call any of the following functions to read or write data in it:\n\n\n    Function\n    Action\n\n\n\n    Class.MemoryStoreHashMap:SetAsync()\n    Add a new key or overwrite the value if the key already exists.\n\n\n    Class.MemoryStoreHashMap:GetAsync()\n    Read a particular key.\n\n\n    Class.MemoryStoreHashMap:ListItemsAsync()\n    List items in a hash map.\n\n\n    Class.MemoryStoreHashMap:UpdateAsync()\n    Update the value of a key after retrieving it from a hash map.\n\n\n    Class.MemoryStoreHashMap:RemoveAsync()\n    Remove a key from the hash map.\n\n\nFor in-depth documentation about each function, see Class.MemoryStoreHashMap.\n\nAll functions accessing data structures in memory stores are asynchronous network calls that might occasionally fail. You should wrap these calls in Global.LuaGlobals.pcall() to catch and handle errors, as shown in the code samples.\n\nAdd or overwrite data\n\nTo add a new key or overwrite the value of a key in the hash map, call Class.MemoryStoreHashMap:SetAsync() with the key name, its value, and an expiration time in seconds. The memory automatically cleans up once the key expires. The maximum expiration time is 3,888,000 seconds (45 days).\n\nUnder the EU General Data Protection Regulation (GDPR), if your memory stores have user data subject to the right to be forgotten you must remove the data within 30 days, even if you set your memory store key's expiration up to 45 days.\n\nlua title=\"Adding Data to a Hash Map\"\nlocal MemoryStoreService = game:GetService(\"MemoryStoreService\")\n\nlocal hashMap = MemoryStoreService:GetHashMap(\"HashMap1\")\n\nlocal setSuccess,  = pcall(function()\n\treturn hashMap:SetAsync(\"User1234\", 1000, 30)\nend)\nif setSuccess then\n\tprint(\"Set succeeded.\")\nend\n\nGet data\n\nYou can either get a value associated with a specific key or get multiple key-value pairs in the hash map.\n\nGet data with one key\n\nTo get a value associated with one key from the hash map, call Class.MemoryStoreHashMap:GetAsync() with the key name.\n\nlua title=\"Getting a Particular Key from a Hash Map\"\nlocal MemoryStoreService = game:GetService(\"MemoryStoreService\")\n\nlocal hashMap = MemoryStoreService:GetHashMap(\"HashMap1\")\n\nlocal setSuccess,  = pcall(function()\n\treturn hashMap:SetAsync(\"User1234\", 1000, 30)\nend)\nif setSuccess then\n\tprint(\"Set succeeded.\")\nend\n\nlocal item\nlocal getSuccess, getError = pcall(function()\n\titem = hashMap:GetAsync(\"User1234\")\nend)\nif getSuccess then\n\tprint(item)\nelse\n\twarn(getError)\nend\n\nGet data with multiple key-value pairs\n\nTo get all the key-value pairs from the hash map as a single operation, call Class.MemoryStoreHashMap:ListItemsAsync() with the desired page size. This function lists all existing keys in a paginated manner. For example, the following code sample retrieves up to 32 items from the hash map.\n\nlua title=\"Listing items in a Hash Map\"\nlocal MemoryStoreService = game:GetService(\"MemoryStoreService\")\n\nlocal hashMap = MemoryStoreService:GetHashMap(\"HashMap1\")\n\n-- Get list of items, 32 items at a time\nlocal success, pages = pcall(function()\n\treturn hashMap:ListItemsAsync(32)\nend)\nif success then\n\twhile true do\n\t\t-- Get the current page\n\t\tlocal entries = pages:GetCurrentPage()\n\t\t-- Iterate through all key-value pairs on page\n\t\tfor , entry in ipairs(entries) do\n\t\t\tprint(entry.key .. \" : \" .. tostring(entry.value))\n\t\tend\n\t\t-- Check if last page has been reached\n\t\tif pages.IsFinished then\n\t\t\tbreak\n\t\telse\n\t\t\tprint(\"----------\")\n\t\t\t-- Advance to next page\n\t\t\tpages:AdvanceToNextPageAsync()\n\t\tend\n\tend\nend\n\nUpdate data\n\nTo retrieve the value of a key from a hash map and update it, call Class.MemoryStoreHashMap:UpdateAsync() with the key name, a callback function to update the key, and an expiration time in seconds.\n\nFor most experiences, multiple servers can update the same key concurrently and change the value. As Class.MemoryStoreHashMap:UpdateAsync()|UpdateAsync() always modifies the latest value before updating, you should use it to read the latest value as the input for your callback function.\n\nFor example, the following code sample updates the resource count of a resource in a shared inventory. Class.MemoryStoreHashMap:UpdateAsync()|UpdateAsync() ensures that all player contributions will make their way into this shared inventory, even if these contributions are made simultaneously. In this function, it also enforces a max resource count of 500.\n\nlua title=\"Updating Resource Count for a Resource in a Shared Inventory\"\nlocal MemoryStoreService = game:GetService(\"MemoryStoreService\")\n\nlocal hashMap = MemoryStoreService:GetHashMap(\"ResourceInventory\")\n\nlocal function contributeResources(itemResource, addedCount)\n\tlocal success, newResourceCount = pcall(function()\n\t\treturn hashMap:UpdateAsync(itemResource, function(resource)\n\t\t\tresource = resource or {count = 0}\n\t\t\tresource.count = resource.count + addedCount\n\n\t\t\t-- ensure we don't exceed the maximum resource count\n\t\t\tif resource.count > 500 then\n\t\t\t\tresource.count = 500\n\t\t\tend\n\t\t\treturn resource\n\t\tend, 1200)\n\tend)\n\tif success then\n\t\tprint(newResourceCount)\n\tend\nend\n\nThe latency for Class.MemoryStoreHashMap:UpdateAsync()|UpdateAsync() is similar to Class.MemoryStoreHashMap:GetAsync()|GetAsync() and Class.MemoryStoreHashMap:SetAsync()|SetAsync() unless there is contention.\n\nWhen contention occurs, the system automatically retries the operation until one of these three happens: the operation succeeds, the callback function returns nil, or the maximum number of retries is reached. If the system reaches the maximum number of retries, it returns a conflict.\n\nRemove data\n\nYou can use Class.MemoryStoreHashMap:RemoveAsync() for both removing one key from the hash map and deleting all data in a memory store hash map.\n\nRemove a key\n\nTo remove a key from the hash map, call Class.MemoryStoreHashMap:RemoveAsync() with a key name.\n\nlua title=\"Remove a Key from a Hash Map\"\nlocal MemoryStoreService = game:GetService(\"MemoryStoreService\")\n\nlocal hashMap = MemoryStoreService:GetHashMap(\"HashMap1\")\n\nlocal setSuccess,  = pcall(function()\n\treturn hashMap:SetAsync(\"User1234\", 1000, 30)\nend)\nif setSuccess then\n\tprint(\"Set succeeded.\")\nend\n\nlocal removeSuccess, removeError = pcall(function()\n\thashMap:RemoveAsync(\"User1234\")\nend)\nif not removeSuccess then\n\twarn(removeError)\nend\n\nDelete all data\n\nTo delete all data in a hash map, list all your items with Class.MemoryStoreHashMap:ListItemsAsync(), then remove them with Class.MemoryStoreHashMap:RemoveAsync().\n\nlua title=\"Delete all data in a Hash Map\"\nlocal MemoryStoreService = game:GetService(\"MemoryStoreService\")\n\nlocal hashMap = MemoryStoreService:GetHashMap(\"HashMap1\")\n\n-- Get list of items, 32 items at a time\nlocal success, pages = pcall(function()\n\treturn hashMap:ListItemsAsync(32)\nend)\nif success then\n\twhile true do\n\t\t-- Get the current page\n\t\tlocal entries = pages:GetCurrentPage()\n\t\tlocal removeSuccess = true\n\t\tlocal removeError = nil\n\t\t-- Iterate through all key-value pairs on page\n\t\tfor , entry in ipairs(entries) do\n\t\t\tprint(entry.key .. \" : \" .. tostring(entry.value))\n\t\t\tremoveSuccess, removeError = pcall(function()\n\t\t\t\thashMap:RemoveAsync(entry.key)\n\t\t\tend)\n\n\t\t\tif not removeSuccess then\n\t\t\t\twarn(removeError)\n\t\t\tend\n\t\tend\n\t\t-- Check if last page has been reached\n\t\tif pages.IsFinished then\n\t\t\tprint(\"Finished deleting all data.\")\n\t\t\tbreak\n\t\telse\n\t\t\tprint(\"----------\")\n\t\t\t-- Advance to next page\n\t\t\tpages:AdvanceToNextPageAsync()\n\t\tend\n\tend\nend",
    "source": "hash-map.md"
}