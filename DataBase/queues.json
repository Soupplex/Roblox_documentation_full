{
    "title": "Queues",
    "description": "Queues are data structures that follow the First In First Out (FIFO) principle.",
    "content": "A queue is a linear data structure with a collection of items. There are two types of queues on Roblox: regular queues, which follow the first-in-first-out (FIFO) principle, and priority queues, which have priorities for items in the queue that determine the data accessing order. Items in both types of queues can be any Luau data type.\n\nQueue is a built-in data structure of the non-persistent data storage service named Class.MemoryStoreService, for which you can directly call the built-in functions to get a queue and add, read, or remove data from the queue. For any other usage, such as scheduling tasks and handling requests in your experience, you can use tables to implement queues on your own.\n\nRegular queues\n\nRegular queues are maintained in the FIFO sequence, in which all items are added to the back of the queue and read or removed in the same order as they are added, from the front to the end.\n\n\n  The order of how a regular queue adds, reads, and removes items\n\nPriority queues\n\nPriority queues are not following the FIFO rule, in which each item can be added with a priority number that indicates its order being read or removed. The item at the back of a priority queue has the default priority of 0, and the item at the front of the queue has the highest set priority, which is 5 in the following example.\n\n\n  An item's set priority changes the order in which a queue reads items\n\nFor this example, an item with a set priority of 3 is being added to a queue. The queue places the new item behind all existing items with the set priority of 3 or more. To place an item at the front of the queue, you need to set the priority higher than the current highest set priority. In this example, you need to set the priority to 6 or higher.\n\nPriority queues are useful for situations where you want to read or access data based on the order of importance instead of the order of being added. You can set a priority as an integer when adding an item, and the queue processes items with higher priority before items with lower priorities. For example, you can use priority queues for matchmaking by assigning higher priorities to users who have been waiting for a long time.\n\nImplement queues\n\nYou can use built-in queues of Class.MemoryStoreService or use tables to implement queues for all other usage. The following code sample shows the implementation a regular queue. To use this implementation for your experience, you should save it as a Class.ModuleScript and store it in Class.ReplicatedStorage, so your queue is accessible for both client and server.\n\nlua title=\"Implementing a Regular Queue Using Table\"\n--!strict\nlocal Queue = {}\nQueue.index = Queue\n\nexport type Queue = typeof(setmetatable(\n\t{} :: {\n\t\tfirst: number,\n\t\tlast: number,\n\t\tqueue: { T },\n\t},\n\tQueue\n))\n\nfunction Queue.new(): Queue\n\tlocal self = setmetatable({\n\t\tfirst = 0,\n\t\tlast = -1,\n\t\tqueue = {},\n\t}, Queue)\n\n\treturn self\nend\n\n-- Check if the queue is empty\nfunction Queue.isEmpty(self: Queue)\n\treturn self.first > self.last\nend\n\n-- Add a value to the queue\nfunction Queue.enqueue(self: Queue, value: T)\n\tlocal last = self.last + 1\n\tself.last = last\n\tself.queue[last] = value\nend\n\n-- Remove a value from the queue\nfunction Queue.dequeue(self: Queue): T\n\tif self:isEmpty() then\n\t\terror(\"Cannot dequeue from empty queue\")\n\tend\n\n\tlocal first = self.first\n\tlocal value = self.queue[first]\n\tself.queue[first] = nil\n\tself.first = first + 1\n\n\treturn value\nend\n\nreturn Queue\n\nThe following code sample is a usage example as a Class.Script under Class.Workspace. You can modify the code, type, and storage location to fit your own usage, as long as you have the previous implementation code sample properly stored.\n\nlua title=\"Regular Queue Usage Example\"\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Queue = require(ReplicatedStorage:WaitForChild(\"Queue\"))\n\nlocal myQueue = Queue.new()\n\n-- Add some values to the queue\nmyQueue:enqueue(5)\nmyQueue:enqueue(10)\nmyQueue:enqueue(15)\n\n-- myQueue = { 5, 10, 15 }\n\n-- Remove one value from the queue\nlocal first = myQueue:dequeue()\nprint(\"The first value added to the queue was\", first)\n\n-- myQueue = { 10, 15 }\n\n-- Add more values to the queue\nmyQueue:enqueue(20)\nmyQueue:enqueue(25)\nmyQueue:enqueue(30)\n\n-- myQueue = { 10, 15, 20, 25, 30 }\n\n-- Remove another value from the queue\nlocal second = myQueue:dequeue()\nprint(\"The second value added to the queue was\", second)\n\n-- myQueue = { 15, 20, 25, 30 }",
    "source": "queues.md"
}