{
    "title": "Memory store queue",
    "description": "Explains how to implement the queue data structure for memory stores.",
    "content": "A queue is a linear data structure with a collection of items that either follows the first-in-first-out (FIFO) principle or prioritizes elements based on predefined criteria. Memory stores support two types of queue, the FIFO regular queues and priority queues. Both types share the same set of functions for initializing an empty queue, adding data to the queue, reading data from the queue, and removing data from the queue.\n\nMemory store queues are useful for order-based processing and storing user information, such as skill levels, to facilitate matchmaking based on your desired criteria. For example, you can add a lobby place as the start place of your experience, use memory store queues as a centralized user information storage system accessible by multiple servers, manage the placement order of users using the queues, and teleport user who have completed the matchmaking to the main place of your experience.\n\nGet a queue\n\nTo get a queue, call Class.MemoryStoreService:GetQueue() with a name, which is global within the experience for any script to access, and an optional invisibility timeout in seconds, which prevents duplicated processing of the same queue item. Invisibility timeout is 30 seconds by default if you leave it empty like the following code sample.\n\nlua title=\"Getting an Empty Queue\"\nlocal MemoryStoreService = game:GetService(\"MemoryStoreService\")\n\nlocal queue = MemoryStoreService:GetQueue(\"Queue1\")\n\nWhen a queue is processing an item in it, the invisibility timeout applies to the item, turning it invisible from being processed by other servers, as multiple servers can update the queue concurrently. Though it's expected to complete both read and removal operations for an item during the invisibility timeout duration, if an error occurs that causes the item to remain in the queue after the timeout elapses, the items become visible for processing again. In doing this, the invisibility timeout guarantees that all items in a queue can still be processed even if unexpected issues occur.\n\nAfter you get a queue, call any of the following functions:\n\n\n    Function\n    Action\n\n\n\n    Class.MemoryStoreQueue:AddAsync()\n    Add a new item to the queue.\n\n\n    Class.MemoryStoreQueue:ReadAsync()\n    Read one or more items from the queue as a single operation.\n\n\n    Class.MemoryStoreQueue:RemoveAsync()\n    Remove one or more items previously read from the queue.\n\n\n    Class.MemoryStoreQueue:GetSizeAsync()\n    Get the number of items in the queue.\n\n\nAll functions accessing data structures in memory stores are asynchronous network calls that might occasionally fail. You should wrap these calls in Global.LuaGlobals.pcall() to catch and handle errors, like the code sample in each section shows.\n\nAdd data\n\nTo add a new item to the queue, call Class.MemoryStoreQueue:AddAsync() with the item value, an expiration time in seconds, and an optional priority of the item. If you want to keep your queue in the FIFO sequence, you can leave the priority empty or pass 0.\n\nlua title=\"Adding Data to a Queue\"\nlocal MemoryStoreService = game:GetService(\"MemoryStoreService\")\n\nlocal queue = MemoryStoreService:GetQueue(\"Queue1\")\n\nlocal addSuccess, addError = pcall(function()\n\tqueue:AddAsync(\"User1234\", 30, 1)\nend)\nif not addSuccess then\n\twarn(addError)\nend\n\nRead and remove data\n\nTo read one or more items from the queue at once, call Class.MemoryStoreQueue:ReadAsync(), which returns an id representing the read item. When you finish processing items, immediately call Class.MemoryStoreQueue:RemoveAsync() to delete them from the queue with its id. This ensures that you never process an item more than once. To capture and respond to all items that are continuously being added to a queue, include a loop like the following code sample:\n\nlua title=\"Reading and Removing Data from Queue with Loop\"\nlocal MemoryStoreService = game:GetService(\"MemoryStoreService\")\n\nlocal queue = MemoryStoreService:GetQueue(\"Queue1\")\n\nlocal addSuccess, addError = pcall(function()\n\tqueue:AddAsync(\"User1234\", 30, 1)\nend)\nif not addSuccess then\n\twarn(addError)\nend\n\n-- Queue processing loop\nwhile true do\n\tlocal readSuccess, items, id = pcall(function()\n\t\treturn queue:ReadAsync(1, false, 30)\n\tend)\n\tif not readSuccess then\n\t\ttask.wait(1)\n\telseif #items > 0 then\n\t\tprint(items, id)\n\t\tlocal removeSuccess, removeError = pcall(function()\n\t\t\tqueue:RemoveAsync(id)\n\t\tend)\n\t\tif not removeSuccess then\n\t\t\twarn(removeError)\n\t\tend\n\tend\nend\n\nGet size\n\nTo get the number of items in the queue, call\nClass.MemoryStoreQueue:GetSizeAsync(). This method takes an optional boolean excludeInvisible.\nWhen it is true, invisible items are excluded from the returned count.\nThis boolean defaults to false.\n\nlua title=\"Getting the Size of a Queue\"\nlocal MemoryStoreService = game:GetService(\"MemoryStoreService\")\n\nlocal queue = MemoryStoreService:GetQueue(\"Queue1\")\n\nlocal addSuccess, addError = pcall(function()\n\treturn queue:AddAsync(\"User1234\", 30, 1)\nend)\n\nif not addSuccess then\n\twarn(addError)\nend\n\nlocal size\nlocal success, sizError = pcall(function()\n\tsize = queue:GetSizeAsync(true)\nend)\n\nif success then\n\tprint(size)\nelse\n\twarn(sizeError)\nend",
    "source": "queue.md"
}