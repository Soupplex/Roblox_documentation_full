{
    "title": "IKControl",
    "description": "",
    "content": "This file is automatically generated. Please don't edit it manually.\nTo submit a bug report on the content, see\nhttps://devforum.roblox.com/c/bug-reports/documentation-issues/72\n\nname: IKControl\ntype: class\nmemorycategory: Animation\nsummary: |\n  Specifies a control to generate a procedural animation pose using Inverse\n  Kinematics.\ndescription: |\n  IKControl instances generate procedural animation poses using Inverse\n  Kinematics (IK). They allow you to make characters respond realistically to\n  their environment.\n\n  For example, you can make a character place its hand on a door handle exactly,\n  and the character will do so independently of its position.\n  Class.IKControl|IKControls provide the advantage of needing to create much\n  fewer animations for your game while giving your experience a more realistic\n  and polished feel.\n\n  Class.IKControl|IKControls must be a child of a Class.Humanoid or\n  Class.AnimationController with an Class.Animator and have all of their\n  required properties set properly, otherwise they don't have any effect. The\n  required properties are Class.IKControl.Type|Type,\n  Class.IKControl.EndEffector|EndEffector, Class.IKControl.Target|Target,\n  Class.IKControl.ChainRoot|ChainRoot. As soon as those are set, the\n  Class.IKControl modifies the pose of your character as you specify. The\n  following code sample demonstrates how to set up your first Class.IKControl\n  and get started with creating more realistic animations for your game.\n\n  You can use Class.IKControl|IKControls to make a character:\n\n  - Rotate its head and torso to look at a point of interest in the world.\n  - Modify its feet positions to respond to dynamic terrain. Adjust its legs and\n    feet to place them accordingly on terrain with rocks and slopes.\n  - Hold a gun and place its hands appropriately on the grip without needing to\n    create animations for each gun in the game.\n  - Aim at a point in the world, so that the tip of the gun point exactly at\n    what you want to shoot. Especially useful in third person shooters.\n  - Place its hands on the steering wheel of a car and follow it when it\n    rotates.\n  - Much more!\n\n  Class.IKControl will override the animation for all the parts between the\n  Class.IKControl.ChainRoot|ChainRoot and the\n  Class.IKControl.EndEffector|EndEffector. You can enable/disable it using\n  Class.IKControl.Enabled|Enabled or change how much they have an effect over\n  the underlying animation using the Class.IKControl.Weight|Weight. Be\n  careful: if you do not set up your Class.IKControl|IKControls correctly, you\n  might generate bad and unrealistic poses!\ncodesamples:\n  - IKControl-Setup\ninherits:\n  - Instance\ndescendants: []\ntags: []\ndeprecationmessage: ''\nproperties:\n  - name: IKControl.ChainRoot\n    summary: |\n      The last part that you are interested in moving your character. For\n      example, the upper arm. Must be an ancestor of\n      Class.IKControl.EndEffector|EndEffector and be a Class.BasePart or a\n      Class.Bone in your character.\n    description: |\n      By specifying a Class.IKControl.ChainRoot|ChainRoot and an\n      Class.IKControl.EndEffector|EndEffector, you instruct the\n      Class.IKControl that it's allowed to move and rotate all parts between\n      the two to move the Class.IKControl.EndEffector|EndEffector to the\n      Class.IKControl.Target|Target. For example, if you specify the LeftHand\n      as Class.IKControl.EndEffector|EndEffector and LeftUpperArm as the\n      Class.IKControl.ChainRoot|ChainRoot, the control moves 3 parts: the\n      LeftHand, the LeftLowerArm, and the LeftUpperArm. Avoid setting\n      Class.IKControl.ChainRoot|ChainRoot as the actual root of the character\n      because that produces unrealistic results.\n    codesamples: []\n    type: Instance\n    tags: []\n    deprecationmessage: ''\n    security:\n      read: None\n      write: None\n    threadsafety: ReadSafe\n    category: Behavior\n    serialization:\n      canload: true\n      cansave: true\n    capabilities:\n      - Animation\n  - name: IKControl.Enabled\n    summary: |\n      Toggles the control on and off. True by default.\n    description: |\n      This property allows you to toggle the IK control on and off. It's on by\n      default. When Class.IKControl.Enabled|Enabled is false, the IK control\n      is off and isn't resolved by the underlying solver.\n    codesamples: []\n    type: boolean\n    tags: []\n    deprecationmessage: ''\n    security:\n      read: None\n      write: None\n    threadsafety: ReadSafe\n    category: Behavior\n    serialization:\n      canload: true\n      cansave: true\n    capabilities:\n      - Animation\n  - name: IKControl.EndEffector\n    summary: |\n      The part that you are interested in moving to reach the\n      Class.IKControl.Target|Target. For example, the hand of your character.\n      Must be a descendant of Class.IKControl.ChainRoot|ChainRoot and be a\n      Class.BasePart or a Class.Bone in your character.\n    description: |\n      The Class.IKControl.EndEffector|EndEffector describes the last part in\n      the chain of your character that you want to affect. For example, it could\n      be the hand when you want to move the whole arm to reach a point. It can\n      be a Class.BasePart on a character, that has a Class.Motor6D as its\n      child, a Class.Motor6D directly, a Class.Bone, or a\n      Class.Attachment. The pivot of the selected\n      Class.IKControl.EndEffector|EndEffector moves to the\n      Class.IKControl.Target|Target, so you can use\n      Class.Attachment|Attachments to modify which point of a Class.BasePart\n      should reach the Class.IKControl.Target|Target.\n    codesamples: []\n    type: Instance\n    tags: []\n    deprecationmessage: ''\n    security:\n      read: None\n      write: None\n    threadsafety: ReadSafe\n    category: Behavior\n    serialization:\n      canload: true\n      cansave: true\n    capabilities:\n      - Animation\n  - name: IKControl.EndEffectorOffset\n    summary: |\n      An additional offset applied on top of the\n      Class.IKControl.EndEffector|EndEffector in its local space to change\n      where it moves.\n    description: |\n      The end-effector offset is an additional Datatype.CFrame applied on top\n      of the Class.IKControl.Target|Target Datatype.CFrame that produces the\n      final Datatype.CFrame used to place the\n      Class.IKControl.EndEffector|EndEffector. By default, it's the identity\n      CFrame, so if you don't set it, it has no effect and the\n      Class.IKControl.EndEffector|EndEffector uses the\n      Class.IKControl.Target|Target Datatype.CFrame directly, which is\n      specified in the local space of the\n      Class.IKControl.EndEffector|EndEffector.\n\n      Alternatively, you can use Attachments by setting an Attachment as\n      Class.IKControl.EndEffector|EndEffector, which moves it to the\n      Class.IKControl.Target|Target instead of the parts it's attached to,\n      effectively obtaining the same result.\n\n      You can also use Class.IKControl.EndEffectorOffset|EndEffectorOffset to\n      modify which axis of the Class.IKControl.EndEffector|EndEffector should\n      point at the Class.IKControl.Target|Target when using LookAt as\n      Class.IKControl.Type|Type.\n    codesamples: []\n    type: CFrame\n    tags: []\n    deprecationmessage: ''\n    security:\n      read: None\n      write: None\n    threadsafety: ReadSafe\n    category: Behavior\n    serialization:\n      canload: true\n      cansave: true\n    capabilities:\n      - Animation\n  - name: IKControl.Offset\n    summary: |\n      An additional offset applied on top of the Class.IKControl.Target|Target\n      to change where the Class.IKControl.EndEffector|EndEffector moves.\n    description: |\n      The offset is an additional Datatype.CFrame applied on top of the\n      Class.IKControl.Target|Target Datatype.CFrame that produces the final\n      Datatype.CFrame used to place the\n      Class.IKControl.EndEffector|EndEffector. It's identity by default, so if\n      you don't set it, it has no effect and the\n      Class.IKControl.EndEffector|EndEffector will use the\n      Class.IKControl.Target|Target Datatype.CFrame directly. You can\n      animate it to create procedural animations such as typing on a keyboard.\n      It's useful when the Class.IKControl.Target|Target and\n      Class.IKControl.EndEffector|EndEffector aren't aligned and you need to\n      fix it with an additional rotation or translation.\n    codesamples: []\n    type: CFrame\n    tags: []\n    deprecationmessage: ''\n    security:\n      read: None\n      write: None\n    threadsafety: ReadSafe\n    category: Behavior\n    serialization:\n      canload: true\n      cansave: true\n    capabilities:\n      - Animation\n  - name: IKControl.Pole\n    summary: |\n      An optional instance that determines which way the chain bends. You can\n      use this to specify which way an elbow or knee bends.\n    description: |\n      The Class.IKControl.Pole|Pole is an optional Class.Instance that gives\n      you control over how intermediate parts in your character should bend. It\n      can be anything that has a position in the world, such as\n      Class.BasePart, Class.Attachment, Class.Bone, Class.Motor6D. It is\n      by default nil. When you specify it, the underlying solver will make the\n      parts bend towards it. When it is nil, the solver will try to make\n      elbows and knees bend appropriately based on the limb of the character.\n      The limb will be \"Arm\" when you select as\n      Class.IKControl.EndEffector|EndEffector either the LeftHand or\n      RightHand and as Class.IKControl.ChainRoot|ChainRoot the corresponding\n      LeftUpperArm or RightUpperArm, and it will be \"Leg\" when you select as\n      Class.IKControl.EndEffector|EndEffector either the LeftFoot or\n      RightFoot and as Class.IKControl.ChainRoot|ChainRoot the corresponding\n      LeftUpperLeg or RightUpperLeg. In all other cases, if you don't\n      specify a pole, the chain might not bend as you expect.\n    codesamples: []\n    type: Instance\n    tags: []\n    deprecationmessage: ''\n    security:\n      read: None\n      write: None\n    threadsafety: ReadSafe\n    category: Behavior\n    serialization:\n      canload: true\n      cansave: true\n    capabilities:\n      - Animation\n  - name: IKControl.Priority\n    summary: |\n      Specifies the order in which controls are solved. Higher values have\n      higher priority.\n    description: |\n      When multiple controls are active on a character, the order in which they\n      are solved by the underlying system affects the final generated pose. By\n      changing this value, you specify the ordering in which controls are\n      satisfied. Higher values have higher priority, and higher-priority\n      controls are resolved later because their result might override the\n      previous result of other controls. If you have multiple IK controls on a\n      character and one is more important than the other, specify a lower\n      priority for it. It is 0 by default, meaning all controls have the same\n      priority.\n    codesamples: []\n    type: int\n    tags: []\n    deprecationmessage: ''\n    security:\n      read: None\n      write: None\n    threadsafety: ReadSafe\n    category: Behavior\n    serialization:\n      canload: true\n      cansave: true\n    capabilities:\n      - Animation\n  - name: IKControl.SmoothTime\n    summary: |\n      Specifies the average number of seconds that it takes for the\n      Class.IKControl.EndEffector|EndEffector to smoothly reach the\n      Class.IKControl.Target|Target.\n    description: |\n      This value specifies the average number of seconds that it takes for the\n      Class.IKControl.EndEffector|EndEffector to reach the\n      Class.IKControl.Target|Target. The behavior is that of a\n      critically-damped spring, where the rate of change is proportional to the\n      distance to the target and no oscillations are present when approaching\n      the target. Smaller values create a quicker convergence, and larger values\n      create a slower convergence. A value of 0 disables smoothing. The default\n      value is 0.05 to provide a very slight smoothing that makes the motion\n      feel realistic.\n    codesamples: []\n    type: float\n    tags: []\n    deprecationmessage: ''\n    security:\n      read: None\n      write: None\n    threadsafety: ReadSafe\n    category: Behavior\n    serialization:\n      canload: true\n      cansave: true\n    capabilities:\n      - Animation\n  - name: IKControl.Target\n    summary: |\n      The object that the Class.IKControl.EndEffector|EndEffector reaches for\n      or points at. It can be anything that has a position in the world, such as\n      Class.BasePart, Class.Attachment, Class.Bone, or Class.Motor6D.\n    description: |\n      The Class.IKControl.Target|Target represents a point (Datatype.CFrame)\n      in the world that you want your Class.IKControl.EndEffector|EndEffector\n      to reach. The exact behavior of reaching can be set via the\n      Class.IKControl.Type|Type property, and an additional\n      Class.IKControl.Offset|Offset can be applied on top of it to modify it.\n      If you set a Class.IKControl.Target|Target that will be moved either by\n      physics or a script, at each frame the Class.IKControl will try to\n      satisfy it, automatically updating the point to reach.\n    codesamples: []\n    type: Instance\n    tags: []\n    deprecationmessage: ''\n    security:\n      read: None\n      write: None\n    threadsafety: ReadSafe\n    category: Behavior\n    serialization:\n      canload: true\n      cansave: true\n    capabilities:\n      - Animation\n  - name: IKControl.Type\n    summary: |\n      Specifies how the solver satisfies this control.\n    description: |\n      By changing the Class.IKControl.Type|Type, you can change the behavior\n      of the control. These are the available options:\n\n      - Transform: it's a full 6-DoF constraint. Aligns the\n        Class.IKControl.EndEffector|EndEffector Datatype.CFrame to that of\n        the Class.IKControl.Target|Target.\n      - Position: aligns the Class.IKControl.EndEffector|EndEffector position\n        to that of the Class.IKControl.Target|Target.\n      - Rotation: aligns the Class.IKControl.EndEffector|EndEffector rotation\n        to that of the Class.IKControl.Target|Target.\n      - LookAt: moves and orients the whole chain to make an axis (by default\n        the forward axis) on the Class.IKControl.EndEffector|EndEffector point\n        at a position in the world specified by Class.IKControl.Target|Target.\n    codesamples: []\n    type: IKControlType\n    tags: []\n    deprecationmessage: ''\n    security:\n      read: None\n      write: None\n    threadsafety: ReadSafe\n    category: Behavior\n    serialization:\n      canload: true\n      cansave: true\n    capabilities:\n      - Animation\n  - name: IKControl.Weight\n    summary: |\n      Specifies the weight of the IK control target. Should be in the [0, 1]\n      range.\n    description: |\n      You can control how much a given control affects the character pose by\n      using this property. Values should be in the [0, 1] range. 0 means no\n      effect, and 1 means full effect of the IK control. Values outside this\n      range are truncated. Smoothly varying this value allows you to blend in or\n      out a specific control to avoid jarring motion. It is 1 by default.\n\n      The weight determines the interpolation factor between the End-Effector\n      and the IK target. Setting the weight to 0 doesn't disable the IK Control\n      because other factors, including the SmoothTime smoothing factor and Pole,\n      can still change the pose. To truly disable the IK Control, turn the\n      Class.IKControl.Enabled|Enabled property to false.\n    codesamples: []\n    type: float\n    tags: []\n    deprecationmessage: ''\n    security:\n      read: None\n      write: None\n    threadsafety: ReadSafe\n    category: Behavior\n    serialization:\n      canload: true\n      cansave: true\n    capabilities:\n      - Animation\nmethods:\n  - name: IKControl:GetChainCount\n    summary: ''\n    description: ''\n    codesamples: []\n    parameters: []\n    returns:\n      - type: int\n        summary: ''\n    tags: []\n    deprecationmessage: ''\n    security: None\n    threadsafety: Unsafe\n    capabilities:\n      - Animation\n  - name: IKControl:GetChainLength\n    summary: ''\n    description: ''\n    codesamples: []\n    parameters: []\n    returns:\n      - type: float\n        summary: ''\n    tags: []\n    deprecationmessage: ''\n    security: None\n    threadsafety: Unsafe\n    capabilities:\n      - Animation\n  - name: IKControl:GetNodeLocalCFrame\n    summary: ''\n    description: ''\n    codesamples: []\n    parameters:\n      - name: index\n        type: int\n        default:\n        summary: ''\n    returns:\n      - type: CFrame\n        summary: ''\n    tags: []\n    deprecationmessage: ''\n    security: None\n    threadsafety: Unsafe\n    capabilities:\n      - Animation\n  - name: IKControl:GetNodeWorldCFrame\n    summary: ''\n    description: ''\n    codesamples: []\n    parameters:\n      - name: index\n        type: int\n        default:\n        summary: ''\n    returns:\n      - type: CFrame\n        summary: ''\n    tags: []\n    deprecationmessage: ''\n    security: None\n    threadsafety: Unsafe\n    capabilities:\n      - Animation\n  - name: IKControl:GetRawFinalTarget\n    summary: ''\n    description: ''\n    codesamples: []\n    parameters: []\n    returns:\n      - type: CFrame\n        summary: ''\n    tags: []\n    deprecationmessage: ''\n    security: None\n    threadsafety: Unsafe\n    capabilities:\n      - Animation\n  - name: IKControl:GetSmoothedFinalTarget\n    summary: ''\n    description: ''\n    codesamples: []\n    parameters: []\n    returns:\n      - type: CFrame\n        summary: ''\n    tags: []\n    deprecationmessage: ''\n    security: None\n    threadsafety: Unsafe\n    capabilities:\n      - Animation\nevents: []\ncallbacks: []",
    "source": "IKControl.yaml"
}