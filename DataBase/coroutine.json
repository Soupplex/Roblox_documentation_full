{
    "title": "coroutine",
    "description": "",
    "content": "{\n    \"title\": \"coroutine\",\n    \"description\": \"\",\n    \"content\": \"This file is automatically generated. Please don't edit it manually.\\nTo submit a bug report on the content, see\\nhttps://devforum.roblox.com/c/bug-reports/documentation-issues/72\\n\\nname: coroutine\\ntype: library\\nsummary: |\\n  A function that executes alongside the main thread.\\ndescription: |\\n  A coroutine is used to perform multiple tasks at the same time from within\\n  the same script. Such tasks might include producing values from inputs or\\n  performing work on a subroutine when solving a larger problem. A task doesn't\\n  even need to have a defined ending point, but it does need to define\\n  particular times at which it yields (pause) to let other things be worked\\n  on.\\n\\n  ## Using Coroutines\\n\\n  A new coroutine can be created by providing a function to\\n  Library.coroutine.create(). Once created, a coroutine doesn't begin running\\n  until the first call to Library.coroutine.resume() which passes the\\n  arguments to the function. This call returns when the function either halts or\\n  calls Library.coroutine.yield() and, when this happens,\\n  Library.coroutine.resume() returns either the values returned by the\\n  function, the values sent to Library.coroutine.yield(), or an error message.\\n  If it does error, the second return value is the thrown error.\\n\\n  lua\\n  local function task(...)\\n  \\t-- This function might do some work for a bit then yield some value\\n  \\tcoroutine.yield(\\\"first\\\")  -- To be returned by coroutine.resume()\\n  \\t-- The function continues once it is resumed again\\n  \\treturn \\\"second\\\"\\n  end\\n\\n  local taskCoro = coroutine.create(task)\\n  -- Call resume for the first time, which runs the function from the beginning\\n  local success, result = coroutine.resume(taskCoro, ...)\\n  print(success, result)  --> true, first (task called coroutine.yield())\\n  -- Continue running the function until it yields or halts\\n  success, result = coroutine.resume(taskCoro)\\n  print(success, result)  --> true, second (task halted because it returned \\\"second\\\")\\n\\n\\n  During the lifetime of the coroutine, you can call\\n  Library.coroutine.status() to inspect its status:\\n\\n\\n\\n\\n              Status\\n              Meaning\\n\\n\\n\\n\\n              suspended The coroutine is waiting to be\\n              resumed. Coroutines begin in this state and enter it when their\\n              function calls coroutine.yield().\\n\\n\\n              running\\n              The coroutine is running right now.\\n\\n\\n              normal The coroutine is awaiting the yield of\\n              another coroutine; in other words, it has resumed another\\n              coroutine.\\n\\n\\n              dead The function has halted (returned or\\n              thrown an error). The coroutine cannot be used further.\\n\\n\\n\\n\\n  ### Wrapping Coroutines\\n\\n  When working with coroutines, you can also forgo the use of the coroutine\\n  object and instead use a wrapper function. Such a wrapper function will resume\\n  a particular coroutine when it is called and will return only the yielded\\n  values. You can do this using Library.coroutine.wrap():\\n\\n  lua\\n  -- Create coroutine and return a wrapper function that resumes it\\n  local f = coroutine.wrap(task)\\n  -- Resume the coroutine as if we called coroutine.resume()\\n  local result = f()\\n  -- If an error occurs it will be raised here!\\n  -- This differs from coroutine.resume() which acts similar to pcall()\\n\\n\\n  The first value returned from Library.coroutine.resume() describes whether a\\n  coroutine ran without errors. However, functions returned by\\n  Library.coroutine.wrap() will not do this: instead they directly return the\\n  values returned or passed to Library.coroutine.yield(), if any. Should an\\n  error have occurred while running the coroutine function, the error is raised\\n  on the call of the returned function.\\n\\n  ### Producer Pattern Example\\n\\n  Imagine a task that produces repetitions of a word: each time it produces a\\n  repetition, the next one will produce one more. For example, providing Hello\\n  will produce Hello, HelloHello, HelloHelloHello, etc. To do this, you\\n  can define repeatThis():\\n\\n  lua\\n  -- This function repeats a word every time its coroutine is resumed\\n  local function repeatThis(word)\\n  \\tlocal repetition = \\\"\\\"\\n  \\twhile true do\\n  \\t\\t-- Do one repetition then yield the result\\n  \\t\\trepetition = repetition .. word\\n  \\t\\tcoroutine.yield(repetition)\\n  \\tend\\n  end\\n\\n\\n  To run this function as a coroutine, you can use Library.coroutine.create()\\n  followed by multiple calls to Library.coroutine.resume():\\n\\n  lua\\n  local repetitionCoro = coroutine.create(repeatThis)\\n  print(coroutine.resume(repetitionCoro, \\\"Hello\\\"))  -- true, Hello\\n  print(coroutine.resume(repetitionCoro))           -- true, HelloHello\\n  print(coroutine.resume(repetitionCoro))           -- true, HelloHelloHello\\n\\n\\n  For this producer function, you can also use Library.coroutine.wrap() to get\\n  a function that produces values:\\n\\n  lua\\n  local f = coroutine.wrap(repeatThis)\\n  print(f(\\\"Hello\\\"))  -- Hello\\n  print(f())         -- HelloHello\\n  print(f())         -- HelloHelloHello\\n\\ntags: []\\ncodesamples: []\\nproperties: []\\nfunctions:\\n  - name: coroutine.close\\n    summary: |\\n      Closes and puts the provided coroutine in a dead state.\\n    description: |\\n      Closes and puts the provided coroutine in a dead state. This function\\n      returns true unless the coroutine is in an error state, in which case it\\n      returns false and the error message. A coroutine that is currently\\n      running cannot be closed. A coroutine cannot be resumed after it is\\n      closed.\\n    parameters:\\n      - name: co\\n        type: thread\\n        default:\\n        summary: ''\\n    returns:\\n      - type: bool\\n        summary: |\\n          true unless the coroutine being closed is in an error state.\\n      - type: Variant\\n        summary: |\\n          The error message, if any.\\n    tags: []\\n    codesamples: []\\n    deprecationmessage: ''\\n  - name: coroutine.create\\n    summary: |\\n      Creates a new coroutine, with body f. f must be a Luau function.\\n    description: |\\n      Creates a new coroutine, with body f. f must be a Luau function.\\n    parameters:\\n      - name: f\\n        type: function\\n        default:\\n        summary: ''\\n    returns:\\n      - type: thread\\n        summary: ''\\n    tags: []\\n    codesamples: []\\n    deprecationmessage: ''\\n  - name: coroutine.isyieldable\\n    summary: |\\n      Returns true if the coroutine this function is called within can safely\\n      yield.\\n    description: |\\n      Returns true if the coroutine this function is called within can safely\\n      yield. Yielding a coroutine inside metamethods or C functions is\\n      prohibited, with the exception of pcall and xpcall.\\n    parameters: []\\n    returns:\\n      - type: bool\\n        summary: |\\n          Whether or not the coroutine can safely yield at this point.\\n    tags: []\\n    codesamples: []\\n    deprecationmessage: ''\\n  - name: coroutine.resume\\n    summary: |\\n      Starts or continues the execution of coroutine co.\\n    description: |\\n      Starts or continues the execution of coroutine co. The first time you\\n      resume a coroutine, it starts running its body. The values ... are\\n      passed as the arguments to the body function. If the coroutine has\\n      yielded, resume restarts it; the values ... are passed as the results\\n      from the yield. If the coroutine runs without any errors, resume returns\\n      true plus any values passed to yield (if the coroutine yields) or any\\n      values returned by the body function (if the coroutine terminates). If\\n      there is any error, resume returns false plus the error message.\\n    parameters:\\n      - name: co\\n        type: thread\\n        default:\\n        summary: ''\\n      - name: ...\\n        type: Variant\\n        default:\\n        summary: ''\\n    returns:\\n      - type: bool\\n        summary: ''\\n      - type: Variant\\n        summary: ''\\n    tags: []\\n    codesamples: []\\n    deprecationmessage: ''\\n  - name: coroutine.running\\n    summary: |\\n      Returns the running coroutine.\\n    description: |\\n      Returns the running coroutine.\\n    parameters: []\\n    returns:\\n      - type: thread\\n        summary: ''\\n    tags: []\\n    codesamples: []\\n    deprecationmessage: ''\\n  - name: coroutine.status\\n    summary: |\\n      Returns the status of coroutine co as a string.\\n    description: |\\n      Returns the status of coroutine co, as a string: 'running', if the\\n      coroutine is running (that is, it called status); 'suspended', if the\\n      coroutine is suspended in a call to yield, or if it has not started\\n      running yet; 'normal' if the coroutine is active but not running (that is,\\n      it has resumed another coroutine); and 'dead' if the coroutine has\\n      finished its body function, or if it has stopped with an error.\\n    parameters:\\n      - name: co\\n        type: thread\\n        default:\\n        summary: ''\\n    returns:\\n      - type: string\\n        summary: ''\\n    tags: []\\n    codesamples: []\\n    deprecationmessage: ''\\n  - name: coroutine.wrap\\n    summary: |\\n      Creates a new coroutine and returns a function that, when called, resumes\\n      the coroutine.\\n    description: |\\n      Creates a new coroutine, with body f. f must be a Luau function. Returns a\\n      function that resumes the coroutine each time it is called. Any arguments\\n      passed to the function behave as the extra arguments to resume. Returns\\n      the same values returned by resume, except the first boolean. In case of\\n      error, propagates the error.\\n    parameters:\\n      - name: f\\n        type: function\\n        default:\\n        summary: ''\\n    returns:\\n      - type: function\\n        summary: ''\\n    tags: []\\n    codesamples: []\\n    deprecationmessage: ''\\n  - name: coroutine.yield\\n    summary: |\\n      Suspends execution of the coroutine.\\n    description: |\\n      Suspends the execution of the calling coroutine. Any arguments to yield\\n      are passed as extra results to resume. Yielding a coroutine inside\\n      metamethods or C functions is prohibited, with the exception of pcall\\n      and xpcall.\\n    parameters:\\n      - name: ...\\n        type: Tuple\\n        default:\\n        summary: ''\\n    returns:\\n      - type: Tuple\\n        summary: ''\\n    tags: []\\n    codesamples: []\\n    deprecationmessage: ''\",\n    \"source\": \"coroutine.yaml\"\n}",
    "source": "coroutine.json"
}