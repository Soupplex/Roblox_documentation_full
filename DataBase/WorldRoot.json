{
    "title": "WorldRoot",
    "description": "",
    "content": "This file is automatically generated. Please don't edit it manually.\nTo submit a bug report on the content, see\nhttps://devforum.roblox.com/c/bug-reports/documentation-issues/72\n\nname: WorldRoot\ntype: class\nmemorycategory: BaseParts\nsummary: |\n  Base class for handling physics simulation and 3D spatial queries.\ndescription: |\n  This base class provides an API for any instance intended for handling 3D\n  spatial queries and simulation, such as Class.Workspace and\n  Class.WorldModel.\ncodesamples: []\ninherits:\n  - Model\ndescendants:\n  - Workspace\n  - WorldModel\ntags:\n  - NotCreatable\ndeprecationmessage: ''\nproperties: []\nmethods:\n  - name: WorldRoot:ArePartsTouchingOthers\n    summary: |\n      Returns true if any of the given Class.BasePart are touching any other\n      parts.\n    description: |\n      ArePartsTouchingOthers returns true if at least one of the given\n      Class.BasePart are touching any other parts. Two parts are considered\n      \"touching\" if they are within the distance threshold, overlapIgnored.\n\n      If no parts are provided, false is returned.\n    codesamples:\n      - checking-for-touching-parts\n    parameters:\n      - name: partList\n        type: Instances\n        default:\n        summary: |\n          A list of parts checks to see if any parts in the list are touching\n          any parts not in the list.\n      - name: overlapIgnored\n        type: float\n        default: 0.000199999995\n        summary: |\n          The part overlap threshold in studs that is ignored before parts are\n          considered to be touching.\n    returns:\n      - type: boolean\n        summary: |\n          True if and only if any of the Class.Part|parts in partList are\n          touching any other parts (parts not in the partList). False if no\n          parts are passed.\n    tags: []\n    deprecationmessage: ''\n    security: None\n    threadsafety: Unsafe\n    capabilities: []\n  - name: WorldRoot:Blockcast\n    summary: |\n      Casts a block shape in a given direction and returns a\n      Datatype.RaycastResult if the shape hits a Class.BasePart or\n      Class.Terrain cell.\n    description: |\n      Casts a block shape in a given direction and returns the first collision\n      with a Class.BasePart or Class.Terrain cell. This is analogous to how\n      Class.WorldRoot:Raycast() casts a linear ray in a direction to find a\n      collision, but it uses a 3D shape instead of a ray.\n\n      Unlike Class.WorldRoot:GetPartsInPart(), this method does not detect\n      Class.BasePart|BaseParts that initially intersect the shape.\n\n      If a hit is detected, a Datatype.RaycastResult is returned containing\n      the hit information. The Datatype.RaycastResult.Distance|Distance\n      property represents the distance the shape has to travel to find a hit,\n      and the Datatype.RaycastResult.Position|Position property represents the\n      intersection point that causes the hit.\n\n      This method throws an error if it is passed invalid Datatype.CFrame,\n      size, or direction inputs.\n    codesamples:\n      - worldroot---blockcast\n    parameters:\n      - name: cframe\n        type: CFrame\n        default:\n        summary: |\n          The initial position and rotation of the cast block shape.\n      - name: size\n        type: Vector3\n        default:\n        summary: |\n          The size of the cast block shape in studs. The maximum size is 512\n          studs.\n      - name: direction\n        type: Vector3\n        default:\n        summary: |\n          Direction of the shapecast, with the magnitude representing the\n          maximum distance the shape can travel. The maximum distance is 1024\n          studs.\n      - name: params\n        type: RaycastParams\n        default: RaycastParams{IgnoreWater=false, BruteForceAllSlow=false, RespectCanCollide=false, CollisionGroup=Default, FilterDescendantsInstances={}}\n        summary: ''\n    returns:\n      - type: RaycastResult?\n        summary: |\n          Contains the result of the shapecast operation, or nil if no\n          eligible Class.BasePart or Class.Terrain cell was hit.\n    tags: []\n    deprecationmessage: ''\n    security: None\n    threadsafety: Safe\n    capabilities: []\n  - name: WorldRoot:BulkMoveTo\n    summary: |\n      Moves a table of Class.BasePart|BaseParts to a table of\n      Datatype.CFrame|CFrames.\n    description: |\n      This function moves a table of Class.BasePart|BaseParts to a table of\n      Datatype.CFrame|CFrames without necessarily firing the default property\n      Class.Object.Changed|Changed events. This provides a very fast way to\n      move large numbers of parts, as you don't have to pay the cost of separate\n      property sets for each individual part.\n\n      The third argument allows you to further optimize the movement operation.\n      By default, the Class.Object.Changed|Changed event of each part fires\n      for Class.BasePart.Position|Position,\n      Class.BasePart.Orientation|Orientation, and\n      Class.BasePart.CFrame|CFrame. However, if you specify\n      Enum.BulkMoveMode|FireCFrameChanged as the third argument, only the\n      Class.Object.Changed|Changed event for the\n      Class.BasePart.CFrame|CFrame property will fire.\n\n      Note that you should only use this function if you're sure that part\n      movement is a bottleneck in your code. Simply setting the\n      Class.BasePart.CFrame|CFrame property of individual parts and welded\n      models is fast enough in the majority of cases.\n    codesamples: []\n    parameters:\n      - name: partList\n        type: Instances\n        default:\n        summary: ''\n      - name: cframeList\n        type: Array\n        default:\n        summary: ''\n      - name: eventMode\n        type: BulkMoveMode\n        default: FireAllEvents\n        summary: ''\n    returns:\n      - type: ()\n        summary: ''\n    tags: []\n    deprecationmessage: ''\n    security: None\n    threadsafety: Unsafe\n    capabilities: []\n  - name: WorldRoot:FindPartOnRay\n    summary: |\n      Returns the first Class.BasePart or Class.Terrain cell intersecting\n      with the given Datatype.Ray.\n    description: |\n      FindPartOnRay uses raycasting to\n      find the first Class.BasePart or Class.Terrain cell intersecting with\n      a given Datatype.Ray. This function returns the Class.BasePart or\n      terrain cell hit, the point of intersection, the surface normal at the\n      point of intersection, and the associated Enum.Material hit.\n\n      If the ignoreDescendantsInstance parameter is provided, the raycasting\n      calculation will ignore the given object and all of its descendants. It\n      behaves similar to the Class.Mouse.TargetFilter property.\n\n      The terrainCellsAreCubes and ignoreWater parameters determine whether\n      Class.Terrain cells should be treated as cubes or not, and whether water\n      should be ignored or not.\n\n      In order to include or exclude multiple objects and their descendants, use\n      the Class.WorldRoot:FindPartOnRayWithWhitelist() and\n      Class.WorldRoot:FindPartOnRayWithIgnoreList() variants.\n\n      #### Notes\n\n      - Theoretically, a ray extends infinitely in one direction. However, the\n        max length of the direction vector on Roblox is 15000 studs.\n      - The length (magnitude) of the directional vector is important, as parts\n        further away than its length will not be tested.\n      - If the ray does not intersect anything, the return values will be nil\n        and the point at the end of the ray, respectively.\n      - Parts that are in a\n        collision group\n        that does not collide with the \"Default\" collision group are ignored\n        implicitly.\n    codesamples: []\n    parameters:\n      - name: ray\n        type: Ray\n        default:\n        summary: ''\n      - name: ignoreDescendantsInstance\n        type: Instance\n        default: nil\n        summary: ''\n      - name: terrainCellsAreCubes\n        type: boolean\n        default: false\n        summary: ''\n      - name: ignoreWater\n        type: boolean\n        default: false\n        summary: ''\n    returns:\n      - type: Tuple\n        summary: |\n          The Class.BasePart or Class.Terrain cell hit, the\n          Datatype.Vector3 point of intersection, the Datatype.Vector3\n          surface normal at the point of intersection, and the Enum.Material\n          of the Class.BasePart or terrain cell hit.\n    tags:\n      - Deprecated\n    deprecationmessage: |\n      This function has been deprecated. Use Class.WorldRoot:Raycast() along\n      with Datatype.RaycastParams for new work.\n    security: None\n    threadsafety: Unsafe\n    capabilities: []\n  - name: WorldRoot:findPartOnRay\n    summary: ''\n    description: ''\n    codesamples: []\n    parameters:\n      - name: ray\n        type: Ray\n        default:\n        summary: ''\n      - name: ignoreDescendantsInstance\n        type: Instance\n        default: nil\n        summary: ''\n      - name: terrainCellsAreCubes\n        type: boolean\n        default: false\n        summary: ''\n      - name: ignoreWater\n        type: boolean\n        default: false\n        summary: ''\n    returns:\n      - type: Tuple\n        summary: ''\n    tags:\n      - Deprecated\n    deprecationmessage: |\n      This deprecated function is a variant of Class.WorldRoot:FindPartOnRay()\n      which should be used instead.\n    security: None\n    threadsafety: Unsafe\n    capabilities: []\n  - name: WorldRoot:FindPartOnRayWithIgnoreList\n    summary: |\n      Returns the first Class.BasePart or Class.Terrain cell intersecting\n      with the given Datatype.Ray that isn't in, nor is a descendant of an\n      object in, the given ignore list.\n    description: |\n      This function is a variant of Class.WorldRoot:FindPartOnRay() with the\n      addition of an ignore list. This lets you ignore certain parts or\n      Class.Model|Models.\n\n      Those looking to include a specific group of objects should instead\n      use Class.WorldRoot:FindPartOnRayWithWhitelist().\n    codesamples: []\n    parameters:\n      - name: ray\n        type: Ray\n        default:\n        summary: ''\n      - name: ignoreDescendantsTable\n        type: Instances\n        default:\n        summary: ''\n      - name: terrainCellsAreCubes\n        type: boolean\n        default: false\n        summary: ''\n      - name: ignoreWater\n        type: boolean\n        default: false\n        summary: ''\n    returns:\n      - type: Tuple\n        summary: |\n          The Class.BasePart or Class.Terrain cell hit, the\n          Datatype.Vector3 point of intersection, the Datatype.Vector3\n          surface normal at the point of intersection, and the Enum.Material\n          of the Class.BasePart or terrain cell hit.\n    tags:\n      - Deprecated\n    deprecationmessage: |\n      This function has been deprecated. Use Class.WorldRoot:Raycast() along\n      with Datatype.RaycastParams for new work.\n    security: None\n    threadsafety: Unsafe\n    capabilities: []\n  - name: WorldRoot:FindPartOnRayWithWhitelist\n    summary: |\n      Returns the first Class.BasePart or Class.Terrain cell intersecting\n      with the given Datatype.Ray that is in, or is a descendant of an object\n      in, the given inclusion list.\n    description: |\n      This function is a variant of Class.WorldRoot:FindPartOnRay() with the\n      addition of an inclusion list. This lets you detect only certain parts or\n      Class.Model|Models and is particularly useful when, for example, looking\n      for points of intersection between a ray and a single part.\n\n      If a nil value is given in the inclusion list, instances after it will\n      be disregarded.\n\n      Those looking to exclude a specific group of objects should instead\n      use Class.WorldRoot:FindPartOnRayWithIgnoreList().\n    codesamples: []\n    parameters:\n      - name: ray\n        type: Ray\n        default:\n        summary: ''\n      - name: whitelistDescendantsTable\n        type: Instances\n        default:\n        summary: ''\n      - name: ignoreWater\n        type: boolean\n        default: false\n        summary: ''\n    returns:\n      - type: Tuple\n        summary: |\n          The Class.BasePart or Class.Terrain cell hit, the\n          Datatype.Vector3 point of intersection, the Datatype.Vector3\n          surface normal at the point of intersection, and the Enum.Material\n          of the Class.BasePart or terrain cell hit.\n    tags:\n      - Deprecated\n    deprecationmessage: |\n      This function has been deprecated. Use Class.WorldRoot:Raycast() along\n      with Datatype.RaycastParams for new work.\n    security: None\n    threadsafety: Unsafe\n    capabilities: []\n  - name: WorldRoot:FindPartsInRegion3\n    summary: |\n      Returns an array of Class.BasePart|BaseParts in the given\n      Datatype.Region3.\n    description: |\n      Returns an array of Class.BasePart|BaseParts in the given\n      Datatype.Region3.\n\n      This function takes an optional maxParts parameter (default 20) which\n      limits the number of Class.BasePart|BaseParts that can be returned. Once\n      this number has been reached, the search for Class.BasePart|BaseParts\n      will stop. This means some Class.BasePart|BaseParts may not be returned\n      even if they are within the Datatype.Region3\n\n      The optional ignoreDescendantsInstance parameter can be used to specify\n      a specific instance for whom itself and all of its descendants should be\n      ignored by this function. This can be useful when, for example, looking to\n      see if any Class.BasePart|BaseParts are inside a Class.BasePart other\n      than the Class.BasePart itself.\n\n\n      local min = part.Position - (0.5  part.Size)\n      local max = part.Position + (0.5  part.Size)\n      local region = Region3.new(min, max)\n      local parts = worldroot:FindPartsInRegion3(region, part)  -- Ignore part\n\n\n      The Class.WorldRoot:FindPartsInRegion3WithIgnoreList() and\n      Class.WorldRoot:FindPartsInRegion3WithWhiteList() variants of this\n      method exist to provide specific exclusion and inclusion functionality.\n\n      If no Class.BasePart|BaseParts are found, an empty array will be\n      returned.\n    codesamples: []\n    parameters:\n      - name: region\n        type: Region3\n        default:\n        summary: |\n          The Datatype.Region3 to be checked.\n      - name: ignoreDescendantsInstance\n        type: Instance\n        default: nil\n        summary: |\n          An Class.Instance to be ignored.\n      - name: maxParts\n        type: int\n        default: 20\n        summary: |\n          The maximum amount of Class.BasePart|BaseParts to be returned.\n    returns:\n      - type: Instances\n        summary: |\n          An array of Class.BasePart|BaseParts within the Datatype.Region3.\n    tags:\n      - Deprecated\n    deprecationmessage: |\n      This function has been deprecated. Use\n      Class.WorldRoot:GetPartBoundsInBox() along with Datatype.OverlapParams\n      for new work.\n    security: None\n    threadsafety: Unsafe\n    capabilities: []\n  - name: WorldRoot:findPartsInRegion3\n    summary: ''\n    description: ''\n    codesamples: []\n    parameters:\n      - name: region\n        type: Region3\n        default:\n        summary: ''\n      - name: ignoreDescendantsInstance\n        type: Instance\n        default: nil\n        summary: ''\n      - name: maxParts\n        type: int\n        default: 20\n        summary: ''\n    returns:\n      - type: Instances\n        summary: ''\n    tags:\n      - Deprecated\n    deprecationmessage: |\n      This deprecated function is a variant of\n      Class.WorldRoot:FindPartsInRegion3() which should be used instead.\n    security: None\n    threadsafety: Unsafe\n    capabilities: []\n  - name: WorldRoot:FindPartsInRegion3WithIgnoreList\n    summary: |\n      Returns an array of Class.BasePart|BaseParts in the given\n      Datatype.Region3 that aren't in, or a descendant of an entry in, the\n      given ignore list.\n    description: |\n      Returns an array of Class.BasePart|BaseParts in the given\n      Datatype.Region3 that aren't in, or a descendant of an entry in, the\n      given ignore list.\n\n      If a nil value is given in the ignore list, instances after this value\n      will not be ignored. If no Class.BasePart|BaseParts are found, an empty\n      array will be returned.\n\n      This function is a variant of Class.WorldRoot:FindPartsInRegion3() with\n      the addition of an ignore list. This allows the developer to exclude\n      certain Class.BasePart|BaseParts or Class.Model|Models from the\n      search. Those looking to find Class.BasePart|BaseParts in a\n      Datatype.Region3 using an inclusion list should use\n      Class.WorldRoot:FindPartsInRegion3WithWhiteList().\n    codesamples: []\n    parameters:\n      - name: region\n        type: Region3\n        default:\n        summary: |\n          The Datatype.Region3 to be checked.\n      - name: ignoreDescendantsTable\n        type: Instances\n        default:\n        summary: |\n          An array of objects to be ignored.\n      - name: maxParts\n        type: int\n        default: 20\n        summary: |\n          The maximum number of Class.BasePart|BaseParts to be returned.\n    returns:\n      - type: Instances\n        summary: |\n          An array of Class.BasePart|BaseParts found within the\n          Datatype.Region3.\n    tags:\n      - Deprecated\n    deprecationmessage: |\n      This function has been deprecated. Use\n      Class.WorldRoot:GetPartBoundsInBox() along with Datatype.OverlapParams\n      for new work.\n    security: None\n    threadsafety: Unsafe\n    capabilities: []\n  - name: WorldRoot:FindPartsInRegion3WithWhiteList\n    summary: |\n      Returns an array of Class.BasePart|BaseParts in the given\n      Datatype.Region3 that are in, or descendant of an entry in, the given\n      inclusion list.\n    description: |\n      Returns an array of Class.BasePart|BaseParts in the given\n      Datatype.Region3 that are in, or descendant of an entry in, the given\n      inclusion list.\n\n      If a nil value is given in the inclusion list, instances after this\n      value will not be ignored. If no Class.BasePart|BaseParts are found, an\n      empty array will be returned.\n\n      This function is a variant of Class.WorldRoot:FindPartsInRegion3() with\n      the addition of an inclusion list. This allows the developer to include\n      only certain Class.BasePart|BaseParts or Class.Model|Models in the\n      search. Those looking to find Class.BasePart|BaseParts in a\n      Datatype.Region3 using an exclusion list should use\n      Class.WorldRoot:FindPartsInRegion3WithIgnoreList().\n    codesamples: []\n    parameters:\n      - name: region\n        type: Region3\n        default:\n        summary: |\n          The Datatype.Region3 to be checked.\n      - name: whitelistDescendantsTable\n        type: Instances\n        default:\n        summary: |\n          An array of objects to check.\n      - name: maxParts\n        type: int\n        default: 20\n        summary: |\n          The maximum number of Class.BasePart|BaseParts to be returned.\n    returns:\n      - type: Instances\n        summary: |\n          An array of Class.BasePart|BaseParts within the Datatype.Region3.\n    tags:\n      - Deprecated\n    deprecationmessage: |\n      This function has been deprecated. Use\n      Class.WorldRoot:GetPartBoundsInBox() along with Datatype.OverlapParams\n      for new work.\n    security: None\n    threadsafety: Unsafe\n    capabilities: []\n  - name: WorldRoot:GetPartBoundsInBox\n    summary: |\n      Returns an array of parts whose bounding boxes overlap a given box.\n    description: |\n      Class.WorldRoot:GetPartBoundsInBox() returns an array of parts whose\n      bounding boxes overlap a box whose volume is described using the given\n      center (Datatype.CFrame) and size (Datatype.Vector3).\n\n      As emphasized, this spatial query method efficiently considers the volume\n      of parts' bounding boxes rather than their actual occupied volume. This\n      may be important when considering cylinders, spheres, unions, and\n      Class.MeshPart|MeshParts which have non-block shapes. For cases where\n      accuracy especially matters, use Class.WorldRoot:GetPartsInPart()\n      instead, or further filter the results of this method yourself.\n\n      This method uses a Datatype.OverlapParams object to describe reusable\n      portions of the spatial query, such as an inclusion or exclusion list, the\n      maximum number of parts to query, what\n      collision group to\n      use, and whether the query favors an intersected part's\n      Class.BasePart.CanCollide value over its Class.BasePart.CanQuery\n      value.\n    codesamples: []\n    parameters:\n      - name: cframe\n        type: CFrame\n        default:\n        summary: |\n          The location of the center of the given box volume to be queried.\n      - name: size\n        type: Vector3\n        default:\n        summary: |\n          The size of the given box volume to be queried.\n      - name: overlapParams\n        type: OverlapParams\n        default: OverlapParams{MaxParts=0, Tolerance=0, BruteForceAllSlow=false, RespectCanCollide=false, CollisionGroup=Default, FilterDescendantsInstances={}}\n        summary: |\n          Contains reusable portions of the spatial query parameters.\n    returns:\n      - type: Instances\n        summary: |\n          An array of Class.BasePart|BaseParts which matched the spatial\n          query.\n    tags:\n      - CustomLuaState\n    deprecationmessage: ''\n    security: None\n    threadsafety: Safe\n    capabilities: []\n  - name: WorldRoot:GetPartBoundsInRadius\n    summary: |\n      Returns an array of parts whose bounding boxes overlap a given sphere.\n    description: |\n      Class.WorldRoot:GetPartBoundsInRadius() returns an array of parts whose\n      bounding boxes overlap a sphere whose volume is described using the\n      given center (Datatype.Vector3) and radius (number).\n\n      As emphasized, this spatial query method efficiently considers the volume\n      of parts' bounding boxes rather than their actual occupied volume. This\n      may be important when considering cylinders, spheres, unions, and\n      Class.MeshPart|MeshParts which have non-block shapes. For cases where\n      accuracy especially matters, use Class.WorldRoot:GetPartsInPart()\n      instead, or further filter the results of this method yourself.\n\n      This method uses a Datatype.OverlapParams object to describe reusable\n      portions of the spatial query, such as an inclusion or exclusion list, the\n      maximum number of parts to query, what\n      collision group to\n      use, and whether the query favors an intersected part's\n      Class.BasePart.CanCollide value over its Class.BasePart.CanQuery\n      value.\n    codesamples: []\n    parameters:\n      - name: position\n        type: Vector3\n        default:\n        summary: |\n          The location of the center of the given sphere volume to be queried.\n      - name: radius\n        type: float\n        default:\n        summary: |\n          The radius of the given sphere volume to be queried.\n      - name: overlapParams\n        type: OverlapParams\n        default: OverlapParams{MaxParts=0, Tolerance=0, BruteForceAllSlow=false, RespectCanCollide=false, CollisionGroup=Default, FilterDescendantsInstances={}}\n        summary: |\n          Contains reusable portions of the spatial query parameters.\n    returns:\n      - type: Instances\n        summary: |\n          An array of Class.BasePart|BaseParts which matched the spatial\n          query.\n    tags:\n      - CustomLuaState\n    deprecationmessage: ''\n    security: None\n    threadsafety: Safe\n    capabilities: []\n  - name: WorldRoot:GetPartsInPart\n    summary: |\n      Returns an array of parts whose occupied space is shared with the given\n      part.\n    description: |\n      Class.WorldRoot:GetPartsInPart() returns an array of parts whose\n      occupied space is shared with the given part (which must exist in the same\n      Class.WorldRoot as the parts to be queried). This method can be used in\n      place of Class.BasePart:GetTouchingParts() and is generally a better\n      choice.\n\n      As noted, this spatial query method considers the exact volume\n      occupied by the given part using a full geometric collision check. As an\n      example, a concave/hollow part won't match queried parts within it unless\n      they actually overlap/touch such a part. For simpler volumes, consider\n      using Class.WorldRoot:GetPartBoundsInBox() or\n      Class.WorldRoot:GetPartBoundsInRadius(), as they are less accurate but\n      perform more efficiently.\n\n      This method uses a Datatype.OverlapParams object to describe reusable\n      portions of the spatial query, such as an inclusion or exclusion list, the\n      maximum number of parts to query, what\n      collision group to\n      use, and whether the query favors an intersected part's\n      Class.BasePart.CanCollide value over its Class.BasePart.CanQuery\n      value.\n    codesamples: []\n    parameters:\n      - name: part\n        type: BasePart\n        default:\n        summary: |\n          The part whose volume is to be checked against other parts.\n      - name: overlapParams\n        type: OverlapParams\n        default: OverlapParams{MaxParts=0, Tolerance=0, BruteForceAllSlow=false, RespectCanCollide=false, CollisionGroup=Default, FilterDescendantsInstances={}}\n        summary: |\n          Contains reusable portions of the spatial query parameters.\n    returns:\n      - type: Instances\n        summary: |\n          An array of Class.BasePart|BaseParts which matched the spatial\n          query.\n    tags:\n      - CustomLuaState\n    deprecationmessage: ''\n    security: None\n    threadsafety: Safe\n    capabilities: []\n  - name: WorldRoot:IKMoveTo\n    summary: |\n      Moves the specified part to the specified location via inverse kinematics\n      rather than moving it there directly, to ensure any joints, constraints,\n      or collisions that part is participating in remain physically satisfied.\n    description: |\n      This function moves the specified part to the specified location via\n      inverse kinematics\n      rather than moving it there directly, to ensure any joints,\n      Class.Constraint|constraints, or collisions that part is participating\n      in remain physically satisfied. Currently this function is only available\n      in Studio to Class.Plugin|plugins, as it currently conflicts with the\n      physics of a running game.\n\n      Translate stiffness is a number between 0 and 1 specifying how\n      aggressively to match the part's position to the position part of the\n      target CFrame. Rotate stiffness is a number between 0 and 1 specifying\n      how aggressively to match the part's rotation to the rotation part of the\n      target CFrame.\n\n      For example:\n\n      - If translate stiffness and rotate stiffness are both equal to 1, then\n        the part will be moved exactly to the target CFrame regardless of what\n        physical constraints there are on it.\n      - If translate stiffness and rotate stiffness are both equal to 0.5, then\n        the part will try to move to exactly the target CFrame, but may be\n        pushed out of the way by physical constraints on it.\n      - If translate stiffness and rotate stiffness are both equal to 0, then\n        the target CFrame will be ignored and physical constraints will be\n        solved for the object at the position where it was.\n    codesamples: []\n    parameters:\n      - name: part\n        type: BasePart\n        default:\n        summary: |\n          The part being moved.\n      - name: target\n        type: CFrame\n        default:\n        summary: |\n          The location to move the specified part.\n      - name: translateStiffness\n        type: float\n        default: 0.5\n        summary: |\n          A number between 0 and 1 specifying how aggressively to match the\n          part's position to the position part of the target Datatype.CFrame.\n      - name: rotateStiffness\n        type: float\n        default: 0.5\n        summary: |\n          A number between 0 and 1 specifying how aggressively to match the\n          part's rotation to the rotation part of the target Datatype.CFrame.\n      - name: collisionsMode\n        type: IKCollisionsMode\n        default: OtherMechanismsAnchored\n        summary: |\n          Allows you to specify what objects should be effected by the physical\n          resolution.\n    returns:\n      - type: ()\n        summary: ''\n    tags: []\n    deprecationmessage: ''\n    security: PluginSecurity\n    threadsafety: Unsafe\n    capabilities: []\n  - name: WorldRoot:IsRegion3Empty\n    summary: |\n      Returns a bool indicating whether there are no Class.BasePart|BaseParts\n      within the given Datatype.Region3.\n    description: |\n      IsRegion3Empty returns a bool indicating whether there are no\n      Class.BasePart|BaseParts within the given Datatype.Region3.\n\n      The optional ignoreDescendantsInstance parameter can be used to specify\n      a specific instance for whom itself and all of its descendants should be\n      ignored by this function. This can be useful when, for example, looking to\n      see if any Class.BasePart|BaseParts are inside a Class.BasePart other\n      than the Class.BasePart itself.\n\n\n      local min = part.Position - (0.5  part.Size)\n      local max = part.Position + (0.5  part.Size)\n      local region = Region3.new(min, max)\n      local isPartEmpty = worldroot:IsRegion3Empty(region, part)  -- Ignore part\n\n\n      If more than one object and its descendants need to be excluded from the\n      search, developers should use\n      Class.WorldRoot:IsRegion3EmptyWithIgnoreList().\n\n      This function only returns if a region is empty or not. Developers looking\n      to find Class.BasePart|BaseParts in a region should use\n      Class.WorldRoot:FindPartsInRegion3().\n\n      #### How do Region3 checks work?\n\n      Checking if a part overlaps a Datatype.Region3 is not a simple process.\n      It actually is time consuming and complicated. Instead it checks if parts\n      are roughly in the same area. When this function is called, it figures out\n      which voxels contain the Datatype.Region3. It then figures out which\n      parts might be in those voxels. It does this by comparing the axis-aligned\n      bounding box (sometimes called the AABB) of the part with the voxels. The\n      axis-aligned bounding box can be seen in Roblox Studio when a part is\n      selected.\n\n      This means that the area that is inspected by the function may be larger\n      than the Datatype.Region3. For this reason it is recommended to make\n      sure that the Datatype.Region3 is on the voxel grid. The best way to do\n      this is by setting the coordinates of the Datatype.Region3 to multiples\n      of 4 (since voxels are 4 x 4 x 4 studs).\n\n      This method is a fairly quick and easy way to see if any parts are in a\n      general area. If a game needs to know if parts are exactly in an area,\n      then Class.BasePart:GetTouchingParts() should be used. There is a higher\n      cost to using Class.BasePart:GetTouchingParts() since a part is needed\n      in the Class.WorldRoot and the function takes more time to run.\n    codesamples: []\n    parameters:\n      - name: region\n        type: Region3\n        default:\n        summary: |\n          The Datatype.Region3 to be checked.\n      - name: ignoreDescendentsInstance\n        type: Instance\n        default: nil\n        summary: |\n          An Class.Instance to be ignored.\n    returns:\n      - type: boolean\n        summary: |\n          True if the Datatype.Region3 is empty.\n    tags:\n      - Deprecated\n    deprecationmessage: |\n      This function has been deprecated. Use\n      Class.WorldRoot:GetPartBoundsInBox() along with Datatype.OverlapParams\n      for new work.\n    security: None\n    threadsafety: Unsafe\n    capabilities: []\n  - name: WorldRoot:IsRegion3EmptyWithIgnoreList\n    summary: |\n      Returns a boolean indicating whether there are no\n      Class.BasePart|BaseParts within the given Datatype.Region3, ignoring\n      any Class.BasePart|BaseParts that are descendants of the objects within\n      the given ignore list.\n    description: |\n      Returns a boolean indicating whether there are no\n      Class.BasePart|BaseParts within the given Datatype.Region3, ignoring\n      any Class.BasePart|BaseParts that are descendants of the objects within\n      the given ignore list. If a nil value is given in the ignore list,\n      instances after this value will not be ignored.\n\n      This function only returns if a region is empty or not. Developers looking\n      to find specific Class.BasePart|BaseParts in a region should use\n      Class.WorldRoot:FindPartsInRegion3WithIgnoreList().\n\n      This function is a variant of Class.WorldRoot:IsRegion3Empty() with the\n      addition of an ignore list. In cases where an inclusion list is required\n      instead, developers should check to see if any parts are returned by\n      Class.WorldRoot:FindPartsinRegion3WithWhitelist().\n    codesamples: []\n    parameters:\n      - name: region\n        type: Region3\n        default:\n        summary: |\n          The Datatype.Region3 to be checked.\n      - name: ignoreDescendentsTable\n        type: Instances\n        default:\n        summary: |\n          An array of objects to be ignored.\n    returns:\n      - type: boolean\n        summary: |\n          True if the Datatype.Region3 is empty.\n    tags:\n      - Deprecated\n    deprecationmessage: |\n      This function has been deprecated. Use\n      Class.WorldRoot:GetPartBoundsInBox() along with Datatype.OverlapParams\n      for new work.\n    security: None\n    threadsafety: Unsafe\n    capabilities: []\n  - name: WorldRoot:Raycast\n    summary: |\n      Casts a ray using an origin, direction, and optional\n      Datatype.RaycastParams, then returns a Datatype.RaycastResult if an\n      eligible object or terrain intersects the ray.\n    description: |\n      Casts a ray using an origin, direction, and optional\n      Datatype.RaycastParams. If it finds an eligible Class.BasePart or\n      Class.Terrain cell, a Datatype.RaycastResult is returned containing\n      the results of the operation. If no Datatype.RaycastParams object is\n      provided, the defaults are used (all parts are considered and\n      Class.Terrain water is not ignored).\n\n      Note that the length (magnitude) of the directional vector is important,\n      as objects/terrain further away than its length will not be tested. If\n      you're using a Datatype.CFrame to help create the ray components,\n      consider using Datatype.CFrame.LookVector as the directional vector and\n      multiply it by the desired length as shown in the example below. The\n      maximum length of the direction vector is 15,000 studs.\n\n      This method does not use a Datatype.Ray object, but its origin and\n      direction components can be borrowed from Datatype.Ray.Origin and\n      Datatype.Ray.Direction.\n    codesamples:\n      - worldroot---raycast\n    parameters:\n      - name: origin\n        type: Vector3\n        default:\n        summary: |\n          The origin point of the ray.\n      - name: direction\n        type: Vector3\n        default:\n        summary: |\n          The directional vector of the ray. Note that the length of this vector\n          matters, as parts/terrain further away than its length will not be\n          tested.\n      - name: raycastParams\n        type: RaycastParams\n        default: RaycastParams{IgnoreWater=false, BruteForceAllSlow=false, RespectCanCollide=false, CollisionGroup=Default, FilterDescendantsInstances={}}\n        summary: |\n          An object used to specify hit eligibility in the raycast operation. If\n          not provided, default values are used where all parts are considered\n          and Class.Terrain water is not ignored.\n    returns:\n      - type: RaycastResult?\n        summary: |\n          Contains the results of a raycast operation, or nil if no eligible\n          Class.BasePart or Class.Terrain cell was hit.\n    tags: []\n    deprecationmessage: ''\n    security: None\n    threadsafety: Safe\n    capabilities: []\n  - name: WorldRoot:Shapecast\n    summary: ''\n    description: ''\n    codesamples: []\n    parameters:\n      - name: part\n        type: BasePart\n        default:\n        summary: ''\n      - name: direction\n        type: Vector3\n        default:\n        summary: ''\n      - name: params\n        type: RaycastParams\n        default: RaycastParams{IgnoreWater=false, BruteForceAllSlow=false, RespectCanCollide=false, CollisionGroup=Default, FilterDescendantsInstances={}}\n        summary: ''\n    returns:\n      - type: RaycastResult?\n        summary: ''\n    tags: []\n    deprecationmessage: ''\n    security: None\n    threadsafety: Unsafe\n    capabilities: []\n  - name: WorldRoot:Spherecast\n    summary: |\n      Casts a spherical shape in a given direction and returns a\n      Datatype.RaycastResult if the shape hits a Class.BasePart or\n      Class.Terrain cell.\n    description: |\n      Casts a spherical shape in a given direction and returns the first\n      collision with a Class.BasePart or Class.Terrain cell. This is\n      analogous to how Class.WorldRoot:Raycast() casts a linear ray in a\n      direction to find a collision, but it uses a 3D shape instead of a ray.\n\n      Unlike Class.WorldRoot:GetPartsInPart(), this method does not detect\n      Class.BasePart|BaseParts that initially intersect the shape.\n\n      If a hit is detected, a Datatype.RaycastResult is returned containing\n      the hit information. The Datatype.RaycastResult.Distance|Distance\n      property represents the distance the shape has to travel to find a hit,\n      and the Datatype.RaycastResult.Position|Position property represents the\n      intersection point that causes the hit.\n\n      This method throws an error if it is passed invalid radius or direction\n      inputs.\n    codesamples:\n      - worldroot---spherecast\n    parameters:\n      - name: position\n        type: Vector3\n        default:\n        summary: |\n          The initial position of the cast spherical shape.\n      - name: radius\n        type: float\n        default:\n        summary: |\n          The radius of the cast spherical shape in studs. The maximum radius is\n          256 studs.\n      - name: direction\n        type: Vector3\n        default:\n        summary: |\n          Direction of the shapecast, with the magnitude representing the\n          maximum distance the shape can travel. The maximum distance is 1024\n          studs.\n      - name: params\n        type: RaycastParams\n        default: RaycastParams{IgnoreWater=false, BruteForceAllSlow=false, RespectCanCollide=false, CollisionGroup=Default, FilterDescendantsInstances={}}\n        summary: ''\n    returns:\n      - type: RaycastResult?\n        summary: |\n          Contains the result of the shapecast operation, or nil if no\n          eligible Class.BasePart or Class.Terrain cell was hit.\n    tags: []\n    deprecationmessage: ''\n    security: None\n    threadsafety: Safe\n    capabilities: []\n  - name: WorldRoot:StepPhysics\n    summary: |\n      Advances the simulation for parts in the world forward based on a\n      specified time increment and an optional set of\n      Class.BasePart|BaseParts.\n    description: |\n      Advances the simulation for parts in the world forward based on a\n      specified time increment and an optional set of Class.BasePart. When a\n      set of parts is specified, only these parts will be simulated and all\n      other parts in the world will be treated as anchored. When this argument\n      is left out, all parts in the world will be included in the simulation.\n      The specified time increment can be any positive number, with larger\n      values increasing the runtime of the function. Depending on the value of\n      the time increment, the physics system may subdivide it into multiple\n      individual steps to maintain the accuracy and stability of the simulation.\n      Even if the function performs multiple substeps, the results of the\n      simulation will only be seen once the function completes. To visualize the\n      individual steps of a simulation, the function can be called once per\n      RenderStep via the Class.RunService.RenderStepped event.\n    codesamples:\n      - worldroot---stepphysics\n    parameters:\n      - name: dt\n        type: float\n        default:\n        summary: |\n          The amount of time that will be simulated. This argument must be a\n          positive number. Larger values will increase the runtime of this\n          function.\n      - name: parts\n        type: Instances\n        default: '{}'\n        summary: |\n          Optional array of parts that will be simulated. This set must contain\n          instances that are of type Class.BasePart; any other types will be\n          ignored.\n    returns:\n      - type: ()\n        summary: ''\n    tags: []\n    deprecationmessage: ''\n    security: PluginSecurity\n    threadsafety: Unsafe\n    capabilities: []\nevents: []\ncallbacks: []",
    "source": "WorldRoot.yaml"
}