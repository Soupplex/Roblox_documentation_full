{
    "title": "Reuse code",
    "description": "How to use module scripts to reuse code.",
    "content": "After creating a few scripts, it's never long before you want to reuse some code between them. Depending on location, Class.ModuleScript|ModuleScripts let you reuse code between scripts on different sides of the client-server boundary or the same side of the boundary.\n\nYou can put module scripts anywhere that you put scripts, but Class.ReplicatedStorage is a popular location; storing module scripts here lets you reuse code between the server and clients.\n\nAnatomy of a module script\n\nIn Roblox Studio, add a module script to ReplicatedStorage and rename it to PickupManager. Each Class.ModuleScript starts with the following code:\n\nlua\nlocal module = {}\n\nreturn module\n\nThis code creates an empty Luau table and returns it to any script that requires the module script.\n\nThe return value can be any data type except for nil, but most module scripts return a function, a table, or a table of functions. To generate its return value, module scripts can of course run arbitrary code, which includes requiring other module scripts.\n\nBe careful not to have module scripts require each other in a circular manner, which results in a Requested module was required recursively error.\n\nThe following example returns a table with a single function called getPickupBonus. Paste it into the new module script:\n\nlua\n-- ModuleScript in ReplicatedStorage\nlocal PickupManager = {}\n\nlocal defaultMultiplier = 1.25\nlocal rarityMultipliers = {\n\tcommon = 10,\n\tuncommon = 20,\n\trare = 50,\n\tlegendary = 100\n}\n\n-- Add the getPickupBonus function to the PickupManager table\nPickupManager.getPickupBonus = function(rarity)\n\tlocal bonus = rarityMultipliers[rarity]  defaultMultiplier\n\treturn bonus\nend\n\nreturn PickupManager\n\nAdding the function to a table isn't strictly necessary—you could just return the function itself—but it's a good pattern to follow; it gives you an easy-to-understand syntax when you call the function from another script and lets you easily add more functions to the module script over time.\n\nRequire module scripts\n\nTo load a module script, you call the Global.LuaGlobals.require() function. In ReplicatedStorage, add a new script, and change its RunContext to Client. Then add the following code to call the PickupManager.getPickupBonus function:\n\nlua title=\"Client script in ReplicatedStorage\"\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\n-- Get the value returned by the ModuleScript\nlocal PickupManager = require(ReplicatedStorage:WaitForChild(\"PickupManager\"))\n\n-- Call a ModuleScript function\nlocal bonus = PickupManager.getPickupBonus(\"legendary\")\nprint(bonus)  --> 125\n\nThe Class.Instance:WaitForChild() pattern is an important safety measure in client scripts. For more information, see Replication order.\n\nStoring module scripts in ReplicatedStorage lets you share code between the server and client, so you can use the same code to require the script from ServerScriptService:\n\nlua title=\"Script in ServerScriptService\"\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal PickupManager = require(ReplicatedStorage:WaitForChild(\"PickupManager\"))\n\nWhen you call Global.LuaGlobals.require() on a Class.ModuleScript, it runs once and returns a single item as a reference. Calling Global.LuaGlobals.require() again returns the exact same reference, meaning that if you modify a returned table or Class.Instance, subsequent Global.LuaGlobals.require() calls return that modified reference. The module itself doesn't run multiple times.\n\nIf you require a Class.ModuleScript from both sides of the client-server boundary, as in the example above, the Class.ModuleScript returns a unique reference for each side.\n\nPatterns\n\nModule scripts have some common patterns that you can use to simplify your code and avoid pitfalls as your experience grows in size and complexity.\n\nMost of these patterns require an understanding of events. If you're not familiar with them, see Events.\n\nData sharing\n\nTo associate data with individual objects, you can assign attributes to them or create Class.Configuration folders with value objects such as Class.StringValue or Class.IntValue. However, both approaches are troublesome if you want to add or modify dozens of objects or data values. They also don't store tables or functions.\n\nIf you want to modify the same data for multiple copies of the same\nobject or reuse the same data for different objects, store the data in\nClass.ModuleScript|ModuleScripts. It's an easier way for you to reuse the data in other scripts, and you can store tables and functions.\n\nThe following example Class.ModuleScript in Class.ReplicatedStorage|ReplicatedStorage stores the configuration values for a generic gun:\n\nlua title=\"ModuleScript in ReplicatedStorage\"\nlocal GunConfig = {}\n\nGunConfig.MagazineSize = 20\nGunConfig.AmmoCount = 100\nGunConfig.Firerate = 600\nGunConfig.Damage = {\n  [\"Head\"] = 50;\n  [\"Torso\"] = 40;\n  [\"Body\"] = 25;\n}\n\nreturn GunConfig\n\nCustom events\n\nCustom events enable scripts to communicate with each other, but having to keep track of references to individual Class.BindableEvent objects can clutter your code.\n\nYou can use Class.ModuleScript|ModuleScripts to store\nClass.BindableEvent|BindableEvents and provide\ncustom event handlers that are directly tied to the methods of Class.ModuleScript.\n\nThe following Class.ModuleScript in Class.ReplicatedStorage|ReplicatedStorage has a custom event that fires when the switch changes state:\n\nlua title=\"ModuleScript in ReplicatedStorage\"\nlocal Switch = {}\n\n-- Creating bindable so any script can listen to when the switch was changed\nlocal bindableEvent = Instance.new(\"BindableEvent\")\nSwitch.Changed = bindableEvent.Event\n\nlocal state = false\nfunction Switch.flip()\n  state = not state\n  bindableEvent:Fire(state)\nend\n\nreturn Switch\n\nThe following client script in Class.ReplicatedStorage connects a function to call when the Switch.Changed event fires.\n\nlua title=\"Script in ReplicatedStorage\"\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal Switch = require(ReplicatedStorage:WaitForChild(\"Switch\"))\n\nSwitch.Changed:Connect(function(newState)\n  print(\"Switch state is now\", newState)\nend)\n\n-- Test the flipping a few times\ntask.wait(1)\nSwitch.flip()\ntask.wait(1)\nSwitch.flip()\n\nEncapsulation\n\nEncapsulation is the practice of creating a layer of abstraction around objects or scripting logic to hide complexity. You can use Class.ModuleScript|ModuleScripts to encapsulate Roblox objects with custom Luau functions to simplify code.\n\nFor example, you can use encapsulation to:\n\n- Simplify cross-network communication with a single Class.RemoteEvent object.\n- Wrap error handling code around sensitive services such as Class.DataStoreService.\n- Define custom methods to control or extend Roblox object features.\n\nIt's difficult to keep track of dozens of individual Class.RemoteEvent objects to implement networking in your experience. You can use a Class.ModuleScript to encapsulate a single Class.RemoteEvent to help simplify this problem. By including a unique id argument, you can still send different network messages while only using a single Class.RemoteEvent.\n\nIn the example below, the Class.ModuleScript named NetworkManagerClient encapsulates the Class.RemoteEvent:FireServer() method to include this extra id argument. Additionally, this Class.ModuleScript references the Class.RemoteEvent object itself so you don't have to reference it in other parts of your code. You only need to require this Class.ModuleScript to send network messages and don't need to deal with Class.RemoteEvent objects in the rest of your codebase.\n\nThe following Class.ModuleScript in Class.ReplicatedFirst provides an encapsulated function that you can call on your client scripts to send a network message:\n\nlua title=\"Network Module\"\n-- ModuleScript in ReplicatedFirst named NetworkManagerClient\nlocal NetworkManagerClient = {}\n\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal remoteEvent = ReplicatedStorage:WaitForChild(\"RemoteEvent\")\n\n-- Encapsulating the remote object's FireServer function\nfunction NetworkManagerClient.FireServer(id, ...)\n  remoteEvent:FireServer(id, ...)\nend\n\nreturn NetworkManagerClient\n\nThe following Class.ModuleScript in Class.ServerScriptService uses Class.BindableEvent|BindableEvents for every script to connect to a specific ID. When a client sends a network message, each Class.BindableEvent associated with the specified ID fires.\n\nlua\n-- ModuleScript in ServerScriptService named NetworkManagerServer\nlocal NetworkManagerServer = {}\n\nlocal networkSignalList = {}\nfunction NetworkManagerServer.GetServerEventSignal(id)\n\tlocal bindableEvent = Instance.new(\"BindableEvent\")\n\t-- Linking the new BindableEvent to the id\n\ttable.insert(networkSignalList, {\n\t\tid = id,\n\t\tbindableEvent = bindableEvent,\n\t})\n\treturn bindableEvent.Event\nend\n\n-- Connecting to\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal remoteEvent = ReplicatedStorage:WaitForChild(\"RemoteEvent\")\nremoteEvent.OnServerEvent:Connect(function(player, id, ...)\n\t-- Finding every bindable event that matches the ID of the received remote event\n\tfor , signal in networkSignalList do\n\t\tif signal.id == id then\n\t\t\tsignal.bindableEvent:Fire(player, ...)\n\t\tend\n\tend\nend)\n\nreturn NetworkManagerServer\n\nThe following Class.LocalScript sends a message with the ID RequestA with an optional Hello argument.\n\nlua\n-- LocalScript in ReplicatedFirst\nlocal ReplicatedFirst = game:GetService(\"ReplicatedFirst\")\n\nlocal NetworkManagerClient = require(ReplicatedFirst:WaitForChild(\"NetworkManagerClient\"))\nNetworkManagerClient.FireServer(\"RequestA\", \"Hello\")\n\nThe following Class.Script connects to the network message ID RequestA and prints out a statement with any additional parameters when it receives the request.\n\nlua\n-- Script in ServerScriptService\nlocal ServerScriptService = game:GetService(\"ServerScriptService\")\n\nlocal NetworkManagerServer = require(ServerScriptService:WaitForChild(\"NetworkManagerServer\"))\nNetworkManagerServer.GetServerEventSignal(\"RequestA\"):Connect(function(player, ...)\n\tprint(\"Received RequestA from\", player, ...)\nend)",
    "source": "module.md"
}