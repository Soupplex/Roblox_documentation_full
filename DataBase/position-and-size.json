{
    "title": "Position and size UI objects",
    "description": "Explains the process of positioning, sizing, and ordering UI objects on a player's screen.",
    "content": "Unless UI objects are under control of a layout structure or a size modifier/constraint, you have complete control over their position and size. You can also set the Z‑index layering order in which objects overlap.\n\nCore properties\n\nAll Class.GuiObject|GuiObjects share a core set of properties to position, size, anchor, and layer them within an on‑screen or in‑experience container.\n\nPosition\n\nThe Class.GuiObject.Position|Position property is a Datatype.UDim2 coordinate set that positions the object along the X and Y axes. A Datatype.UDim2 is represented by both Datatype.UDim.Scale|Scale and Datatype.UDim.Offset|Offset values for each axis:\n\n- Datatype.UDim.Scale|Scale values represent a percentage of the container's size along the corresponding axis, additive of any Datatype.UDim.Offset|Offset values.\n- Datatype.UDim.Offset|Offset values represent how many pixels to shift the object on the corresponding axis, additive of any Datatype.UDim.Scale|Scale values.\n\nTo edit the position of a selected Class.GuiObject, click the Position field in the Properties window and enter a new Datatype.UDim2 coordinate set.\n\nBrackets and spaces are optional when entering a Datatype.UDim2 in Studio &mdash; you can simply enter the four values separated by commas, for instance 0.25,40,0.1,20, and Studio will infer the intended value set.\n\nStudio also infers the intended value set when a single number is entered. For example, entering simply 0.5 will be converted to {0.5, 0},{0.5, 0} since 0.5 is likely a Scale value of 50%. Conversely, entering 20 will be converted to {0, 20},{0, 20} since 20 is likely an Offset value of 20 pixels and not a scale of 2000%.\n\nSize\n\nThe Class.GuiObject.Size|Size property is a Datatype.UDim2 coordinate set that sizes the object along the X and Y axes. A Datatype.UDim2 is represented by both Datatype.UDim.Scale|Scale and Datatype.UDim.Offset|Offset values for each axis:\n\n- Scale &mdash; Values that represent a percentage of the container's size along the corresponding axis, additive to any Offset values.\n- Offset &mdash; Values that represent the object's pixel size along the corresponding axis, additive to any Scale values.\n\nTo edit the size of a selected Class.GuiObject, click the Size field in the Properties window and enter a new Datatype.UDim2 coordinate set.\n\nBrackets and spaces are optional when entering a Datatype.UDim2 in Studio &mdash; you can simply enter the four values separated by commas, for instance 0.75,0,0.25,0, and Studio will infer the intended value set.\n\nStudio also infers the intended value set when a single number is entered. For example, entering simply 0.5 will be converted to {0.5, 0},{0.5, 0} since 0.5 is likely a Scale value of 50%. Conversely, entering 20 will be converted to {0, 20},{0, 20} since 20 is likely an Offset value of 20 pixels and not a scale of 2000%.\n\nAnchorPoint\n\nThe Class.GuiObject.AnchorPoint|AnchorPoint property defines the origin point from where the object changes position and size. The default Class.GuiObject.AnchorPoint|AnchorPoint values are (0, 0) which places the anchor in the top‑left corner of the object.\n\nClass.GuiObject.AnchorPoint|AnchorPoint values are a fraction from 0 to 1, relative to the size of the object, meaning an object with Class.GuiObject.AnchorPoint|AnchorPoint values of (0.5, 0.5) places the anchor point halfway (50%) through the object both horizontally and vertically, and any changes to its position or size both move and scale outward from this point.\n\n\n\n\n\n\n\n\nTo view and edit the anchor point of a selected Class.GuiObject:\n\n1. In the Properties window, click inside the AnchorPoint field.\n\n\n\n2. Enter a new Datatype.Vector2 coordinate and press Enter.\n\n\n    Studio infers the intended value pair when a single number is entered. For example, entering simply 0.5 will be converted to 0.5, 0.5 for a center anchor point.\n\n\nZIndex\n\nThe Class.GuiObject.ZIndex|ZIndex property defines the layer order in which Class.GuiObject|GuiObjects render and overlap each other. If you want to create new rendering layers, you must set the Class.GuiObject.ZIndex|ZIndex property to different positive or negative integer values for each object.\n\nFor UI containers like Class.ScreenGui, the default Class.ScreenGui.ZIndexBehavior|ZIndexBehavior always renders children above their parents, and each child's Class.GuiObject.ZIndex|ZIndex is used to decide the order in which it renders over others.\n\nTo edit an object's Class.GuiObject.ZIndex|ZIndex, locate ZIndex in the Properties window and enter a new integer value.\n\nLayout structures\n\nLayout structures let you quickly organize and display Class.GuiObject|GuiObjects, for example into a horizontal or vertical list, a grid of equally‑sized tiles, a page sequence, and more. Layouts typically override or influence the position/size of objects under their control.\n\n\n    Layout\n    Description\n\n\n\n    List\n    Class.UIListLayout positions sibling Class.GuiObject|GuiObjects into horizontal rows or vertical columns within their parent container.\n\n\n    Grid\n    Class.UIGridLayout positions sibling Class.GuiObject|GuiObjects in a grid of uniform cells of the same size within their parent container.\n\n\n    Table\n    Class.UITableLayout positions sibling Class.GuiObject|GuiObjects and their children into table format.\n\n\n    Page\n    Class.UIPageLayout organizes its sibling Class.GuiObject|GuiObjects into unique pages that you can transition to through scripting.\n\n\nCross-platform factors\n\nRoblox is inherently cross‑platform, as players can discover and join experiences on their phone or tablet, then later continue where they left off on their PC or console. You should design your Roblox experiences to be accessible and enjoyable on all platforms that you choose to support, instead of optimizing for one platform and neglecting others.\n\nReserved zones\n\nOn mobile devices, the default controls occupy a portion of the bottom-left and bottom-right corners of the screen. When you design an experience's UI, avoid placing important info or virtual buttons in these zones.\n\nThumb zones\n\nMost mobile players use two thumbs &mdash; one on the virtual thumbstick and one on the jump button. Depending on the physical size of the device and the player's hands, reaching too far from the bottom corners becomes uncomfortable or impossible, so you should avoid placing frequently‑used buttons outside of easy‑to‑reach zones.\n\nButton comfortably within reach of player's right thumb\n\nButton difficult to reach unless player stretches hand or thumb\n\nRemember that comfortable thumb zones differ between phones and tablets because tablets have a larger screen. A button placed 40% below the screen's top edge is reachable on a phone but almost unreachable on a tablet.\n\nButton 40% from top edge of phone, within reach of player's thumb\n\nButton 40% from top edge of tablet, difficult to reach without stretching\n\nA reliable approach on both phones and tablets is relative positioning of custom buttons near frequently‑used controls like the default jump button, placing them within easy reach.\n\nThe following code, placed in a client-side script within Class.StarterPlayerScripts, fetches the position of the jump button and creates a placeholder button 20 pixels to its left.\n\nlua title=\"Client Script - Custom Button Near Jump Button\"\nlocal Players = game:GetService(\"Players\")\nlocal UserInputService = game:GetService(\"UserInputService\")\n\nlocal player = Players.LocalPlayer\nlocal playerGui = player:WaitForChild(\"PlayerGui\")\n\nif UserInputService.TouchEnabled then\n\t-- Wait for jump button to be fully loaded\n\twhile not (playerGui:FindFirstChild(\"JumpButton\", true) and playerGui:FindFirstChild(\"JumpButton\", true).IsLoaded) do\n\t\ttask.wait()\n\tend\n\tlocal jumpButton = playerGui:FindFirstChild(\"JumpButton\", true)\n\n\t-- Place new custom button to left of jump button\n\tlocal customButton = Instance.new(\"ImageButton\")\n\tcustomButton.AnchorPoint = Vector2.new(1, 1)\n\tcustomButton.Size = UDim2.fromOffset(jumpButton.Size.X.Offset  0.8, jumpButton.Size.Y.Offset  0.8)\n\tcustomButton.Position = jumpButton.Position + UDim2.fromOffset(-20, jumpButton.Size.Y.Offset)\n\tcustomButton.Parent = jumpButton.Parent\nelse\n\twarn(\"Device is not touch-enabled or Studio is not emulating a touch-enabled device!\")\nend\n\nContext-based UI\n\nScreen space is limited on mobile devices, so you should show only the most vital information during active gameplay. For example, if your experience includes a special input action to open doors and treasure chests, it doesn't make sense to constantly show an \"open\" button on the screen. Instead, use a proximity prompt or similar method to accept input only when the character approaches a door or chest.\n\n\n  Custom button that you display only when character is near a door or chest",
    "source": "position-and-size.md"
}