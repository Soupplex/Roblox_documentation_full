{
    "title": "3D-drag-detectors",
    "description": "",
    "content": "{\n    \"title\": \"3D drag detectors\",\n    \"description\": \"3D drag detectors facilitate and encourage interaction with 3D objects in an experience, such as opening doors and drawers, sliding a part around, and much more.\",\n    \"content\": \"The Class.DragDetector instance facilitates and encourages interaction with 3D objects in an experience, such as opening doors and drawers, sliding a part around, grabbing and tossing a bowling ball, pulling back and firing a slingshot, and much more. Key features include:\\n\\n- Place a Class.DragDetector under any Class.BasePart or Class.Model to make it draggable via all inputs (mouse, touch, gamepad, and VR), all without a single line of code.\\n\\n- Choose from several drag styles, define how the object responds to motion, and optionally apply axis or movement limits.\\n\\n- Scripts can respond to manipulation of dragged objects to drive UI or make logical decisions, such as adjusting the light level in a room based on a sliding wall switch dimmer.\\n\\n- Players can manipulate anchored parts or models and they'll stay exactly where you put them upon release.\\n\\n- Class.DragDetector|DragDetectors work in Studio as long as you're not using the Select, Move, Scale, or Rotate tools, making it easier to test and adjust draggable objects while editing.\\n\\nMake objects draggable\\n\\nTo make any part or model draggable, simply add a Class.DragDetector as a direct descendant.\\n\\n1. In the Explorer window, hover over the Class.Part, Class.MeshPart, or Class.Model and click the &CirclePlus; button. A contextual menu displays.\\n1. From the menu, insert a DragDetector.\\n\\n\\n\\n1. By default, the object will now be draggable in the ground plane, but you can customize its Class.DragDetector.DragStyle|DragStyle, define how it responds to motion, and optionally apply axis or movement limits.\\n\\nRemember that Class.DragDetector|DragDetectors only work in Studio if you're not using the Select, Move, Scale, or Rotate tools.\\n\\nCustomize drag detectors\\n\\nDrag style\\n\\nClass.DragDetector|DragDetectors map cursor motion to virtual lines and planes to calculate proposed 3D motion. Through the Class.DragDetector.DragStyle|DragStyle property, you can choose from different mappings to suit your needs. For example, TranslatePlane produces translation in a virtual plane, whereas RotateAxis produces rotation about a virtual axis.\\n\\n\\n    Setting\\n    Description\\n\\n\\n\\n    Enum.DragDetectorDragStyle.TranslateLine|TranslateLine\\n    1D motion along the detector's Class.DragDetector.Axis|Axis, by default the world Y axis.\\n\\n\\n    Enum.DragDetectorDragStyle.TranslatePlane|TranslatePlane\\n    2D motion in the plane perpendicular to the detector's Class.DragDetector.Axis|Axis, by default the world XZ plane.\\n\\n\\n    Enum.DragDetectorDragStyle.TranslatePlaneOrLine|TranslatePlaneOrLine\\n    2D motion in the plane perpendicular to the detector's Class.DragDetector.Axis|Axis and, when the modifier is active, 1D motion along the detector's Class.DragDetector.Axis|Axis.\\n\\n\\n    Enum.DragDetectorDragStyle.TranslateLineOrPlane|TranslateLineOrPlane\\n    1D motion along the detector's Class.DragDetector.Axis|Axis and, when the modifier is active, 2D motion in the plane perpendicular to the detector's Class.DragDetector.Axis|Axis.\\n\\n\\n    Enum.DragDetectorDragStyle.TranslateViewPlane|TranslateViewPlane\\n    2D motion in the plane perpendicular to the camera's view. In this mode, the plane is constantly updated, even while dragging, and will always face the camera's current view.\\n\\n\\n    Enum.DragDetectorDragStyle.RotateAxis|RotateAxis\\n    Rotation about the detector's Class.DragDetector.Axis|Axis, by default the world Y axis.\\n\\n\\n    Enum.DragDetectorDragStyle.RotateTrackball|RotateTrackball\\n    Trackball rotation, further customized through the Class.DragDetector.TrackballRadialPullFactor|TrackballRadialPullFactor and Class.DragDetector.TrackballRollFactor|TrackballRollFactor properties.\\n\\n\\n    Enum.DragDetectorDragStyle.BestForDevice|BestForDevice\\n    TranslatePlaneOrLine for mouse and gamepad; TranslatePlane for touch; 6DOF for VR.\\n\\n\\n    Enum.DragDetectorDragStyle.Scriptable|Scriptable\\n    Calculates desired motion via a custom function provided through Class.DragDetector:SetDragStyleFunction()|SetDragStyleFunction().\\n\\n\\nDrag direction\\n\\nBy default, 3D motion and the associated Class.DragDetector.DragStyle|DragStyle map to world space. However, you may want to change the Class.DragDetector.ReferenceInstance|ReferenceInstance, Class.DragDetector.Orientation|Orientation, or Class.DragDetector.Axis|Axis, for example when building drag detectors into models with adjustable parts.\\n\\n\\n    Property\\n    Description\\n\\t\\tDefault\\n\\n\\n\\n    Class.DragDetector.ReferenceInstance|ReferenceInstance\\n    An instance whose pivot provides the reference frame for the drag detector. The Class.DragDetector.DragFrame|DragFrame is expressed relative to this reference frame which may be retrieved via Class.DragDetector:GetReferenceFrame()|GetReferenceFrame(). If the reference frame is nil, translation will be in the direction of (or in the plane perpendicular to) the Class.DragDetector.Axis|Axis property in world space.\\n\\t\\tnil\\n\\n\\n    Class.DragDetector.Orientation|Orientation\\n    Specifies the YXZ rotation of axes of motion relative to the reference frame (does not change the orientation of the reference frame itself). Linear translation and axial rotation will be on this reoriented Y axis, and planar translation in the XZ plane. Changing this value automatically updates Class.DragDetector.Axis|Axis and vice versa.\\n\\t\\t(0, 0, 0)\\n\\n\\n    Class.DragDetector.Axis|Axis\\n    The primary axis of motion, expressed relative to the reference frame. Changing this value automatically updates Class.DragDetector.Orientation|Orientation and vice versa.\\n\\t\\t(0, 1, 0)\\n\\n\\nResponse to motion\\n\\nThe Class.DragDetector.ResponseStyle|ResponseStyle property specifies how an object responds to the proposed motion, depending on whether the object is Class.BasePart.Anchored|Anchored or not.\\n\\n\\n    Setting\\n    Anchored behavior\\n\\t\\tUnanchored behavior\\n\\n\\n\\n    Enum.DragDetectorResponseStyle.Geometric|Geometric\\n    Both inside the running experience and in Studio edit mode, the position/orientation of an anchored object will be updated to exactly reflect the proposed motion.\\n\\t\\tFor an unanchored object, behavior is the same as for an anchored object. However, in a running experience, the object will be anchored at the start of the drag and restored to unanchored upon drag release.\\n\\n\\n    Enum.DragDetectorResponseStyle.Physical|Physical\\n    An anchored object will default to Geometric behavior, as it is not affected by forces.\\n\\t\\tAn unanchored object will be moved by constraint forces that attempt to bring it to the desired position and/or orientation given by the proposed motion.\\n\\n\\n    Enum.DragDetectorResponseStyle.Custom|Custom\\n    The object will not move at all, but Class.DragDetector.DragFrame|DragFrame will still be updated and you can respond to drag manipulation however you'd like.\\n\\t\\t(same as anchored)\\n\\n\\nRemember that Class.DragDetector|DragDetectors only work in Studio if you're not using the Select, Move, Scale, or Rotate tools.\\n\\nAxis & movement limits\\n\\nBy default, there are no limits to 3D motion beyond the inherent restrictions of the Class.DragDetector.DragStyle|DragStyle. If necessary, you can apply minimum and maximum limits to both translation and rotation. Note, however, that these are not constraints; they merely impede the drag detector's attempts to generate motion in order to remain within limits.\\n\\n\\n    Properties\\n    Description\\n\\t\\tDefault\\n\\n\\n\\n    Class.DragDetector.MinDragTranslation|MinDragTranslation\\n\\t\\tClass.DragDetector.MaxDragTranslation|MaxDragTranslation\\n    Limits to drag translation in each dimension. If MaxDragTranslation is greater than MinDragTranslation, translation will be clamped within that range.\\n\\t\\t(0, 0, 0)\\n\\n\\n    Class.DragDetector.MinDragAngle|MinDragAngle\\n\\t\\tClass.DragDetector.MaxDragAngle|MaxDragAngle\\n    Only relevant if Class.DragDetector.DragStyle|DragStyle is set to RotateAxis. If Class.DragDetector.MaxDragAngle|MaxDragAngle is greater than Class.DragDetector.MinDragAngle|MinDragAngle, rotation will be clamped within that range.\\n\\t\\t0\\n\\n\\nWhen using axis/movement limits, you should always set the detector's Class.DragDetector.ReferenceInstance|ReferenceInstance so that the limits are relative to a dedicated reference frame. If you fail to establish the reference frame, each drag of the object will reset its limits to its own current world space position/orientation.\\n\\nDrag permissions\\n\\nPermission of players to interact with a given drag detector instance can be specified by the Class.DragDetector.PermissionPolicy|PermissionPolicy property. This is set to Enum.DragDetectorPermissionPolicy.Everybody by default, and it can also be changed to support scripted permission controls as shown in the code sample.\\n\\n\\n    Setting\\n    Description\\n\\n\\n\\n    Enum.DragDetectorPermissionPolicy.Nobody|Nobody\\n    No players can interact with the Class.DragDetector.\\n\\n\\n    Enum.DragDetectorPermissionPolicy.Everybody|Everybody\\n    All players can interact with the Class.DragDetector.\\n\\n\\n    Enum.DragDetectorPermissionPolicy.Scriptable|Scriptable\\n    Players' drag permissions will be determined by a function registered through Class.DragDetector:SetPermissionPolicyFunction()|SetPermissionPolicyFunction(). Under this setting, failure to register a function or returning an invalid result will prevent all players from dragging.\\n\\n\\nlua title=\\\"DragDetector - Scripted Drag Permission\\\"\\nlocal dragDetector = script.Parent.DragDetector\\ndragDetector.PermissionPolicy = Enum.DragDetectorPermissionPolicy.Scriptable\\n\\ndragDetector:SetPermissionPolicyFunction(function(player, part)\\n\\tif player and player:GetAttribute(\\\"IsInTurn\\\") then\\n\\t\\treturn true\\n\\telseif part and not part:GetAttribute(\\\"IsDraggable\\\") then\\n\\t\\treturn false\\n\\telse\\n\\t\\treturn true\\n\\tend\\nend)\\n\\nPhysics response\\n\\nAssuming a dragger's response style is set to Physical and it is applied to an unanchored object, that object will be moved by constraint forces that attempt to bring it to the position/orientation given by the proposed motion. You can further customize the physical response through the following properties:\\n\\n\\n    Property\\n    Description\\n\\t\\tDefault\\n\\n\\n\\n    Class.DragDetector.ApplyAtCenterOfMass|ApplyAtCenterOfMass\\n    When false, drag force is applied at the point the user clicks on. When true, force is applied at the object's center of mass.\\n\\t\\tfalse\\n\\n\\n    Class.DragDetector.MaxForce|MaxForce\\n    Maximum force applied for the object to reach its goal.\\n\\t\\t10000000\\n\\n\\n    Class.DragDetector.MaxTorque|MaxTorque\\n    Maximum torque applied for the object to reach its goal.\\n\\t\\t10000\\n\\n\\n    Class.DragDetector.Responsiveness|Responsiveness\\n    Higher values cause the object to reach its goal more rapidly.\\n\\t\\t10\\n\\n\\nModifier input\\n\\nSome Class.DragDetector.DragStyle|DragStyle modes allow users to hold down a modifier key/button to manipulate the dragged object in different ways. By default, the modifier is Enum.KeyCode|LeftControl on PC, Enum.KeyCode|ButtonR1 on gamepad, or Enum.KeyCode|ButtonL2 on VR. You can customize these modifiers through the Class.DragDetector.KeyboardModeSwitchKeyCode|KeyboardModeSwitchKeyCode, Class.DragDetector.GamepadModeSwitchKeyCode|GamepadModeSwitchKeyCode, or Class.DragDetector.VRSwitchKeyCode|VRSwitchKeyCode properties of the drag detector instance.\\n\\nReplication\\n\\nWhen the Class.DragDetector.RunLocally|RunLocally property is false (default), the client interprets all input to produce data that it sends to the server to perform the drag. In this mode, all custom event signals and registered functions must be in server Class.Script|Scripts.\\n\\nWhen the Class.DragDetector.RunLocally|RunLocally property is true, no events are replicated to the server. All custom event signals and registered functions must be in client Class.LocalScript|LocalScripts and you must use remote events to propagate necessary changes to the server.\\n\\nScript responses to clicking and dragging\\n\\nThrough event signals, property changes, Enum.DragDetectorDragStyle.Scriptable|Scriptable drag style, and custom functions, scripts can respond to the manipulation of dragged objects to drive UI or make logical decisions, such as adjusting the light level in a room based on a sliding wall switch dimmer.\\n\\nEvent signals\\n\\nThrough the following event signals, you can detect when a user starts, continues, and ends dragging an object.\\n\\n\\n    Event\\n    Description\\n\\n\\n\\n    Class.DragDetector.DragStart|DragStart\\n    Fires when a user starts dragging the object.\\n\\n\\n    Class.DragDetector.DragContinue|DragContinue\\n    Fires when a user continues dragging the object after Class.DragDetector.DragStart|DragStart has been initiated.\\n\\n\\n    Class.DragDetector.DragEnd|DragEnd\\n    Fires when a user stops dragging the object.\\n\\n\\nlua title=\\\"DragDetector - Event Signals\\\" highlight=\\\"7,9,11,13,15,17\\\"\\nlocal dragDetector = script.Parent.DragDetector\\n\\nlocal highlight = Instance.new(\\\"Highlight\\\")\\nhighlight.Enabled = false\\nhighlight.Parent = script.Parent\\n\\ndragDetector.DragStart:Connect(function()\\n\\thighlight.Enabled = true\\nend)\\n\\ndragDetector.DragContinue:Connect(function()\\n\\nend)\\n\\ndragDetector.DragEnd:Connect(function()\\n\\thighlight.Enabled = false\\nend)\\n\\nDrag frame changes\\n\\nIn addition to event signals, you can monitor changes to the detector's Class.DragDetector.DragFrame|DragFrame directly.\\n\\nlua title=\\\"DragDetector - DragFrame Changes\\\" highlight=\\\"3,6\\\"\\nlocal dragDetector = script.Parent.DragDetector\\n\\ndragDetector:GetPropertyChangedSignal(\\\"DragFrame\\\"):Connect(function()\\n\\tlocal currentDragTranslation = dragDetector.DragFrame.Position\\n\\tprint(currentDragTranslation)\\nend)\\n\\nScripted drag style\\n\\nIf you set a detector's Class.DragDetector.DragStyle|DragStyle to Scriptable, you can provide your own function that takes in a Datatype.Ray and returns a world space Datatype.CFrame. The detector will move the motion so that the dragged object goes to that custom location/orientation.\\n\\nlua title=\\\"DragDetector - Scripted DragStyle\\\" highlight=\\\"2,7,31,32,34\\\"\\nlocal Workspace = game:GetService(\\\"Workspace\\\")\\n\\nlocal dragDetector = script.Parent.DragDetector\\ndragDetector.DragStyle = Enum.DragDetectorDragStyle.Scriptable\\n\\nlocal cachedHitPoint = Vector3.zero\\nlocal cachedHitNormal = Vector3.yAxis\\n\\nlocal function followTheCursor(cursorRay)\\n\\t-- Exclude dragged object from raycast detection\\n\\tlocal raycastParams = RaycastParams.new()\\n\\traycastParams.FilterDescendantsInstances = {dragDetector.Parent}\\n\\traycastParams.FilterType = Enum.RaycastFilterType.Exclude\\n\\n\\tlocal hitPoint = Vector3.zero\\n\\tlocal hitNormal = Vector3.yAxis\\n\\n\\tlocal raycastResult = Workspace:Raycast(cursorRay.Origin, cursorRay.Direction, raycastParams)\\n\\tif raycastResult then\\n\\t\\thitPoint = raycastResult.Position\\n\\t\\thitNormal = raycastResult.Normal.Unit\\n\\telse\\n\\t\\thitPoint = cachedHitPoint\\n\\t\\thitNormal = cachedHitNormal\\n\\tend\\n\\n\\tcachedHitPoint = hitPoint\\n\\tcachedHitNormal = hitNormal\\n\\n\\tlocal lookDir1 = hitNormal:Cross(Vector3.xAxis)\\n\\tlocal lookDir2 = hitNormal:Cross(Vector3.yAxis)\\n\\tlocal lookDir = if lookDir1.Magnitude > lookDir2.Magnitude then lookDir1.Unit else lookDir2.Unit\\n\\treturn CFrame.lookAt(hitPoint, hitPoint + lookDir, hitNormal)\\nend\\n\\ndragDetector:SetDragStyleFunction(followTheCursor)\\n\\nCustom constraint function\\n\\nDrag detectors do not have built-in motion rules about grids and snapping, but you can register custom constraint functions to edit the detector's Class.DragDetector.DragFrame|DragFrame before it is applied. For example, you can keep motion on a grid by rounding positions to multiples of the grid increment, or simulate a chess game with rules of motion legal to each piece.\\n\\nlua title=\\\"DragDetector - Custom Constraint Function\\\" highlight=\\\"4,14,27,28,30\\\"\\nlocal dragDetector = script.Parent.DragDetector\\nlocal startPartPosition = nil\\n\\nlocal SNAPINCREMENT = 4\\n\\ndragDetector.DragStart:Connect(function()\\n\\tstartPartPosition = script.Parent.Position\\nend)\\n\\ndragDetector.DragEnd:Connect(function()\\n\\tstartPartPosition = nil\\nend)\\n\\nlocal function snapToWorldGrid(proposedMotion)\\n\\tif startPartPosition == nil then\\n\\t\\treturn proposedMotion\\n\\tend\\n\\tlocal snapIncrement = SNAPINCREMENT // 1\\n\\tif snapIncrement\\n\\nAnchored models with adjustable parts\\n\\nYou can easily create and share models which are primarily anchored, but which have one or more child parts/models that players can drag. For example, the following desk has two drawers which players can open to inspect what's inside.\\n\\nWhen making children of models draggable, you should set the drag detector's Class.DragDetector.ReferenceInstance|ReferenceInstance to an object within the model that can serve as a dedicated reference frame, for example the desk's top surface. This establishes a consistent reference Datatype.CFrame for the style/direction of dragging, even if the model is rotated.\\n\\nDrag detectors and constraints\\n\\nYou can combine drag detectors with Class.Constraint|Constraints, for example a marionette puppet. In the following setup, the control handles are anchored, the body parts are unanchored, and constraints hold the marionette together. Moving the handles with the TranslateViewPlane Class.DragDetector.DragStyle|DragStyle makes the marionette dance, and the individual body parts may also be moved with drag detectors, all while the model retains its integrity.\\n\\n3D user interfaces\\n\\n3D user interfaces are easily achievable through drag detectors, such as adjusting the brightness of a Class.SpotLight based on a sliding switch dimmer. You can also detect the X and Z axes individually to control two different aspects of a 3D user interface, such as the Class.ParticleEmitter.Size|Size, Class.ParticleEmitter.Speed|Speed, and Class.ParticleEmitter.Color|Color of a Class.ParticleEmitter.\\n\\nlua title=\\\"DragDetector - 3D User Interface\\\"\\nlocal model = script.Parent\\nlocal slider = model.SliderPart\\nlocal originPart = model.OriginPart\\nlocal emitter = script.Parent.EmitterPart.ParticleEmitter\\n\\nlocal dragDetector = slider.DragDetector\\ndragDetector.ReferenceInstance = originPart\\ndragDetector.MinDragTranslation = Vector3.zero\\ndragDetector.MaxDragTranslation = Vector3.new(10, 0, 10)\\n\\nlocal dragRangeX = dragDetector.MaxDragTranslation.X - dragDetector.MinDragTranslation.X\\nlocal dragRangeZ = dragDetector.MaxDragTranslation.Z - dragDetector.MinDragTranslation.Z\\n\\nlocal MINPARTICLESIZE = 1\\nlocal MAXPARTICLESIZE = 1.5\\nlocal MINPARTICLESPEED = 2.5\\nlocal MAXPARTICLESPEED = 5\\nlocal COLOR1 = Color3.fromRGB(255, 150, 0)\\nlocal COLOR2 = Color3.fromRGB(255, 0, 50)\\n\\nlocal function updateParticles(emitter)\\n\\tlocal dragFactorX = (dragDetector.DragFrame.Position.X - dragDetector.MinDragTranslation.X) / dragRangeX\\n\\tlocal dragFactorZ = (dragDetector.DragFrame.Position.Z - dragDetector.MinDragTranslation.Z) / dragRangeZ\\n\\n\\t-- Adjust particle size and speed based on drag detector X factor\\n\\temitter.Size = NumberSequence.new{\\n\\t\\tNumberSequenceKeypoint.new(0, 0),\\n\\t\\tNumberSequenceKeypoint.new(0.1, MINPARTICLESIZE + ((MAXPARTICLESIZE - MINPARTICLESIZE)  dragFactorX)),\\n\\t\\tNumberSequenceKeypoint.new(1, 0)\\n\\t}\\n\\tlocal speed = MINPARTICLESPEED + ((MAXPARTICLESPEED - MINPARTICLESPEED)  dragFactorX)\\n\\temitter.Speed = NumberRange.new(speed, speed  1.2)\\n\\t-- Adjust particle color based on drag detector Z factor\\n\\tlocal color = COLOR2:Lerp(COLOR1, dragFactorZ)\\n\\temitter.Color = ColorSequence.new{\\n\\t\\tColorSequenceKeypoint.new(0, color),\\n\\t\\tColorSequenceKeypoint.new(1, color)\\n\\t}\\nend\\n\\ndragDetector:GetPropertyChangedSignal(\\\"DragFrame\\\"):Connect(function()\\n\\tupdateParticles(emitter)\\nend)\",\n    \"source\": \"3D-drag-detectors.md\"\n}",
    "source": "3D-drag-detectors.json"
}