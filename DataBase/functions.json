{
    "title": "Functions",
    "description": "Functions are blocks of code that can execute multiple times on command.",
    "content": "Functions are blocks of code that you can execute multiple times on command. You can also connect them to events or assign them as callbacks.\n\nBasic functions\n\nA function definition includes:\n\n- The scope of the function (global or local).\n- The function keyword.\n- The name of the function in camelCase.\n- The parameters of the function in parentheses (()).\n- The block of code, or \"body\", of the function.\n- The end keyword.\n\nThe body of the function executes when you call the function. To call a function, type its name followed by parentheses. You can define a variable to accept the return value or use the return value in place of a variable.\n\nlua\n-- This function has no parameters and returns nil\nlocal function addOneAndTwo()\n\tlocal result = 1 + 2\n\tprint(result)\nend\n-- Calling a function without a return\naddOneAndTwo() -- 3\n\nParameters\n\nParameters are variables that you make available to the function and are only used in the function's scope. Functions have no parameters by default. If you call a function with more parameters than it expects, Luau ignores the extra parameters. If you call a function with fewer parameters than it expects, Luau passes nil for all missing parameters.\n\nlua\n-- This function has two parameters: num1 and num2\nlocal function addNumbers(num1, num2)\n\tprint(num1 + num2)\nend\n\naddNumbers(2, 3) -- 5\naddNumbers(5, 6, 7) -- 11\naddNumbers(9) -- attempt to perform arithmetic (add) on number and nil\n\nReturn\n\nIn the body of the function, the return keyword returns a result from a computation. You can return multiple values from one function. return ends function execution, and Luau expects the end keyword to follow the return statements, so writing code between the return command and the end command throws an error.\n\nlua\n-- This function returns one return value\nlocal function addNumbers(num1, num2)\n\tlocal result = num1 + num2\n\treturn result\nend\n\nprint(addNumbers(1, 2)) -- 3\nlocal seven = addNumbers(3, 4)\nprint(seven) -- 7\n\n-- This function returns multiple values: sum and difference\nlocal function addAndSubtract(num1, num2)\n\tlocal sum = num1 + num2\n\tlocal difference = num1 - num2\n\treturn sum, difference\nend\n\n-- Calling a function and expecting multiple return values\nlocal sum, difference = addAndSubtract(2, 3)\nprint(sum) -- 5\nprint(difference) -- -1\n\nMethods\n\nMethods are functions that are members of an object, such as a class or table. They expect the object itself (self) as the first argument. When you call a method, use the colon notation (:) instead of dot notation (.) to pass self as the first argument automatically.\n\nAll objects in Roblox descend from Class.Instance and have commonly used methods including Class.Instance:Destroy(), Class.Instance:Clone(), and Class.Instance:FindFirstChild().\n\nlua\nlocal Workspace = game:GetService(\"Workspace\")\n\n-- Destroying a part with dot notation (function)\nlocal firstPart = Instance.new(\"Part\")\nfirstPart.Parent = Workspace\nprint(firstPart.Parent) -- Workspace\nfirstPart.Destroy(firstPart)\nprint(firstPart.Parent) -- nil\n\n-- Destroying a part with colon notation (method)\nlocal secondPart = Instance.new(\"Part\")\nsecondPart.Parent = Workspace\nprint(secondPart.Parent) -- Workspace\nsecondPart:Destroy()\nprint(secondPart.Parent) -- nil\n\nThe statement table:Method() is functionally identical to table.Method(table), and when defining a method, function table:Method() is identical to function table.Method(self). This behavior extends to Class.Instance methods, since they are also derived from tables.\n\nDefine methods\n\nTo create a method in a table, use the name of the method as the key and the method function as the value. In the definition of the method, the self parameter refers to the method's parent table. When you call a method using colon notation, you pass the table itself as the first argument. You can define parameters for a method, but you need to list them after the self parameter.\n\nIn the following example, the testButton table has a method as the value of the changeEnabled key. You can verify that self refers to the method's parent table by printing the value of self.enabled.\n\nlua\nlocal testButton = {\n\tenabled = true,\n\tchangeEnabled = function(self, isEnabled)\n\t\tself.enabled = isEnabled\n\t\tprint(self.enabled)\n\tend\n}\n\nprint(testButton.enabled) -- true\n-- Call the method\ntestButton:changeEnabled(false) -- false\n\nCallbacks\n\nCallbacks are functions that execute in response to another function or process.\n\nBasic callbacks\n\nFunctions can be passed into other functions, for example, an anonymous function can be used to implement a callback that Library.table.sort() then uses to sort a list of Class.Player|Players from Class.Players.GetPlayers().\n\nlua\nlocal Players = game:GetService(\"Players\")\nlocal sortedPlayers = Players:GetPlayers()\n\ntable.sort(sortedPlayers, function(a, b)\n\t-- Use an anonymous callback to sort players by name\n\treturn a.Name\nThe variadic token ... can only be used within functions defined as variadic; functions or callbacks defined within a variadic function cannot use the same ..., even if they are variadic themselves.\n\n... does not behave like a regular variable, and can only be passed into other functions, returned, or put into a table.\n\nlua\nlocal function variadic(named, ...)\n\tlocal arguments = {...} -- pack the extra arguments into a table\n\tprint(\"Named argument =\", named)\n\tfor i, value in arguments do\n\t\tprint(\"Input No.\", i, \"=\", value)\n\tend\nend\n\nvariadic(10, \"Hi\", 20, \"Variadic Function\")\n--[[ Resulting output:\nNamed argument = 10\nInput No. 1 = Hi\nInput No. 2 = 20\nInput No. 3 = Variadic Function\n]]\n\nForward arguments\n\nYou can define variadic functions as wrappers around other functions to pass, or forward, arguments from the wrapper to the other functions.\n\nlua\nlocal function printAround(functionToPrintAround, ...)\n\tprint(\"Before\")\n\tfunctionToPrintAround(...)\n\tprint(\"After\")\nend\n\nlocal function addNumbers(x, y, z)\n\tprint(\"x =\", x)\n\tprint(\"y + z =\", y + z)\nend\n\nprintAround(addNumbers, 1, 2, 3)\n--[[ Resulting output:\nBefore\nx = 1\ny + z = 5\nAfter\n]]\n\nCall a variadic function with arrays\n\nIf you want to pass a table array of values to a global variadic function, such as print(), you can use the global unpack() function to pass the values of the table instead of the table itself.\n\nlua\nlocal squares = {1, 4, 9, 16, 25}\nprint(\"The first 5 square numbers are:\", unpack(squares))\n-- The first 5 square numbers are 1 4 9 16 25",
    "source": "functions.md"
}