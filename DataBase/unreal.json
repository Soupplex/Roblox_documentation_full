{
    "title": "Roblox for Unreal developers",
    "description": "If you're an experienced Unreal developer, use this page to get oriented with Roblox.",
    "content": "import ScriptTypes from './includes/engine-comparisons/script-types.md'\nimport CodeSample from './includes/engine-comparisons/fishing-pole-code-sample.md'\nimport ScriptLocations from './includes/engine-comparisons/script-locations.md'\nimport Transforms from './includes/engine-comparisons/transforms.md'\n\nThis page contains information to help experienced Unreal Engine developers get started with Roblox, including basic orientation, a conceptual comparison, and key differences between the two platforms.\n\nGet oriented\n\nUnreal's Outliner and Roblox Studio's Explorer are the primary windows for organizing elements in 3D spaces. Both display a hierarchy of objects and folders. However, Outliner has a flatter, less defined structure and only shows Actors. The Explorer window has a deeply nested, strict structure and displays all objects as part of the hierarchy, even objects that would be considered components in Unreal.\n\nThe Roblox Studio Asset Manager and Toolbox overlap with the Unreal Content Browser. The Asset Manager lets you manage all assets within your experience, whereas the Toolbox lets you access any assets you've published. The Toolbox also lets you search the Creator Store for assets from Roblox or the community, similar to the Unreal Engine Marketplace but accessible directly from the Studio user interface.\n\nPhilosophical differences\n\nRoblox is a \"simulation engine\" rather than a traditional game engine. Unreal Actors and Roblox Class.Part|Parts both serve as fundamental building blocks, but in practice, the two are quite different:\n\n- Representation: Actors in Unreal are a higher-level concept for any object in a level, whereas Class.Part|Parts in Roblox are designed to represent physical objects like wooden blocks and plastic spheres.\n- Physics: To perform physics simulations in Unreal, you enable physics within certain components (such as the StaticMeshComponent) or by adding components to Actors, such as physics constraints. In Roblox, physics are built into the Class.Part|Parts data type; the engine handles interactions automatically.\n\nYou can see the difference immediately if you create an Actor and a Class.Part. The Actor has little more than a location, rotation, and scale. The Class.Part has that same information, plus a material and color, values for reflectance and transparency, mass and shape, and much more. The two only start to share similar properties when you compare a StaticMeshActor in Unreal to a Class.MeshPart in Roblox.\n\n\n  Unreal Editor Details panel\n\n\n  Roblox Studio Properties window\n\nAnother useful comparison is the Unreal Actor to the Roblox Class.Model. Models act as a container for a collection of interconnected parts in the same way that Actors in Unreal are containers for components. You specify one of the model's parts as its primary part to define the pivot point. Models also hold scripts, animations, sound effects, prompts, constraints, particle emitters, and more.\n\nFor example, an Unreal Actor might have a NiagaraComponent that uses several emitters to achieve the desired visual effect, a mesh for the shape, a physics constraint to add springiness, and a script for player interactivity. In Outliner, you see a single Actor named SpringyFireball.\n\nIn Roblox, a comparable SpringyFireball model in the Explorer window might look something like this:\n\ntext\nModel\n|- ParticleEmitter\n|- MeshPart\n|- SpringConstraint\n|- ClickDetector\n|  |- Script\n\nRoblox's physics-by-default philosophy extends to the process of building 3D models. In Roblox, welding multiple parts together into an assembly is an excellent way to quickly build things, because Roblox treats the welded parts as a single rigid body. This approach isn't practical in Unreal.\n\nRather than using standard metric units for length and mass, Roblox uses notional units called studs and Roblox Mass Units (RMUs). For approximate metric conversions and recommendations around use, see Units.\n\nLocation matters\n\nRoblox experiences are multiplayer by default, so Roblox Studio includes many different storage locations with specific behaviors. For example, a script might run when you put it in Class.ReplicatedStorage, but not when you put it into Class.StarterPlayerScripts. For more information, see Client-server runtime and Object organization.\n\nScripting\n\nUnreal doesn't have the concept of different script types. If you choose to make a multiplayer game, you write additional code to synchronize game state between the server and the clients.\n\nIn Unreal, much of the engine's functionality is available by extending built-in classes like UObject, ACharacters, ULevel, and UWorld in C++ or Blueprint. Unreal supports custom events, but many classes include events that the engine automatically invokes as part of the natural life cycle of the level.\n\nCompared to the Unreal \"ticking\" system, Roblox scripts are much more event-driven. You access similar engine functionality by subscribing to services and listening for updates.\n\nC++ and Luau\n\nFor scripting, Unreal uses C++. Roblox uses Luau, a scripting language derived from Lua 5.1.\n\nCompared to Luau, C++ has an overall performance advantage, which might or might not be relevant to the kinds of experiences you want to build. Luau is gradually typed and has a less verbose syntax. In larger projects, however, gradual typing can introduce categories of bugs that strongly typed languages like C++ avoid, so consider enabling strict type checking in Roblox scripts.\n\nUnreal also includes a visual scripting system called Blueprints. Roblox has third-party plugins that offer similar functionality, but no comparable system built-in.\n\nLuau code sample\n\nThe Roblox script can be relatively concise because Roblox has many built-in assumptions: a Class.Player with a Class.Humanoid character connected to the server and can equip Class.Tool|Tools. These assumptions don't exist in Unreal, so the implementation would be very different.\n\nAssets\n\nUnreal and Roblox both support importing custom meshes and models in .fbx format. Certain types of assets may require specific configurations and export settings from your third-party modeling software. For more information, see the following pages:\n\n- 3D Importer\n- 3D modeling specifications\n- Blender and Maya export requirements\n\nIn Unreal, assets import into your Content directory, visible in the Content Browser. In Roblox, assets import into your Workspace and into the Toolbox or Asset Manager.\n\nRoblox also offers an open-source Blender plugin to streamline the import process, similar to the Send to Unreal feature of Blender Tools.\n\nTransforms\n\nCollaboration\n\nIn Unreal, you collaborate with version control systems like Perforce or SVN, generally through Unreal's built-in user interface. These version control systems use the centralized \"checkout\" model that locks files while one person works on them.\n\nRoblox files live in the cloud (although you can export copies), so Roblox Studio provides built-in collaboration workflows for simultaneous editing, group management, permissions, script drafting, and more. See Collaboration.\n\nCloud syncing provides further benefits with packages, the Roblox equivalent of Unreal Blueprint classes. Converting an asset or asset hierarchy to a package helps with local reusability, but also with collaboration. When you or your collaborators publish a new version of a package, you can quickly update existing instances of that package within an experience or set them to auto-update.\n\nPlugins\n\nSimilar to Unreal, Roblox Studio supports plugins, which can simplify or give you additional control over various aspects of the development process. Plugins are available in the Creator Store, just like assets, many for free.\n\nGlossary\n\n| Unreal | Roblox | Notes |\n| :--- | :--- | :--- |\n| Level | Place | |\n| Actor | Class.Part or Class.Model | See Philosophical differences. |\n| Blueprint Class | Package | |\n| Transform | Datatype.CFrame | Datatype.CFrame doesn't include scale information. See Transforms. |\n| Outliner | Explorer | |\n| Details panel | Properties |\n| Level Viewport | 3D viewport | |\n| Content Browser | Asset Manager or Toolbox | |\n| Landscape Mode | Terrain Editor | |\n| PlayerStart | Class.SpawnLocation | |\n| Output Log | Output | |\n| Marketplace | Creator Store | |\n| Menu bar | Toolbar | |\n| Plugin | Plugin | |",
    "source": "unreal.md"
}