{
    "title": "collisions",
    "description": "",
    "content": "{\n    \"title\": \"Collisions\",\n    \"description\": \"Explains methods to detect physical collisions, handle collision events, and fine-tune which objects collide with others.\",\n    \"content\": \"A collision occurs when two 3D objects come into contact within the 3D world. For customized collision handling, Class.BasePart has a set of collision events and collision filtering techniques, so you can control which physical assemblies collide with others.\\n\\nCollision events\\n\\nCollision events occur when two Class.BasePart|BaseParts touch or stop touching in the 3D world. You can detect these collisions through the Class.BasePart.Touched|Touched and Class.BasePart.TouchEnded|TouchEnded events which occur regardless of either part's Class.BasePart.CanCollide|CanCollide property value. When considering collision handling on parts, note the following:\\n\\n- A part's Class.BasePart.CanTouch|CanTouch property determines whether it triggers collision events. If set to false, neither Class.BasePart.Touched|Touched nor Class.BasePart.TouchEnded|TouchEnded will fire.\\n- A part's Class.BasePart.CanCollide|CanCollide property affects whether it will physically collide with other parts and cause forces to act upon them. Even if Class.BasePart.CanCollide|CanCollide is disabled for a part, you can detect touch and non‑touch through Class.BasePart.Touched|Touched and Class.BasePart.TouchEnded|TouchEnded events.\\n- The Class.BasePart.Touched|Touched and Class.BasePart.TouchEnded|TouchEnded events only fire as a result of physical movement, not from a Class.BasePart.Position|Position or Class.BasePart.CFrame|CFrame changes that cause a part to intersect or stop intersecting another part.\\n- The top-level Class.Terrain class inherits from Class.BasePart, so you can assign a collision group to Class.Terrain to determine whether other Class.BasePart|BaseParts collide with Terrain voxels.\\n\\nFor performance optimization, set Class.BasePart.CanTouch|CanTouch to false for objects that don't require collisions.\\n\\nTouched\\n\\nThe Class.BasePart.Touched|Touched event fires when a Class.BasePart\\ncomes in contact with another, or with a Terrain voxel. It only fires as a result of physical simulation and will not fire when the part's Class.BasePart.Position|Position or Class.BasePart.CFrame|CFrame is explicitly set such that it intersects another part or voxel.\\n\\nThe following code pattern shows how the Class.BasePart.Touched|Touched event can be connected to a custom onTouched() function. Note that the event sends the otherPart argument to the function, indicating the other part involved in the collision.\\n\\nlua title=\\\"Part Collision\\\" highlight=\\\"3-5, 7\\\"\\nlocal Workspace = game:GetService(\\\"Workspace\\\")\\n\\nlocal part = Workspace.Part\\n\\nlocal function onTouched(otherPart)\\n\\tprint(part.Name .. \\\" collided with \\\" .. otherPart.Name)\\nend\\n\\npart.Touched:Connect(onTouched)\\n\\nNote that the Class.BasePart.Touched|Touched event can fire multiple times in quick succession based on subtle physical collisions, such as when a moving object \\\"settles\\\" into a resting position or when a collision involves a multi‑part model. To avoid triggering more Class.BasePart.Touched|Touched events than necessary, you can implement a simple debounce system which enforces a \\\"cooldown\\\" period through an instance attribute.\\n\\nlua title=\\\"Part Collision With Cooldown\\\" highlight=\\\"3, 6, 9-12\\\"\\nlocal Workspace = game:GetService(\\\"Workspace\\\")\\n\\nlocal part = Workspace.Part\\n\\nlocal COOLDOWNTIME = 1\\n\\nlocal function onTouched(otherPart)\\n\\tif not part:GetAttribute(\\\"Touched\\\") then\\n\\t\\tprint(part.Name .. \\\" collided with \\\" .. otherPart.Name)\\n\\n\\t\\tpart:SetAttribute(\\\"Touched\\\", true)  -- Set attribute to true\\n\\t\\ttask.wait(COOLDOWNTIME)  -- Wait for cooldown duration\\n\\t\\tpart:SetAttribute(\\\"Touched\\\", false)  -- Reset attribute\\n\\tend\\nend\\n\\npart.Touched:Connect(onTouched)\\n\\nTouchEnded\\n\\nThe Class.BasePart.TouchEnded|TouchEnded event fires when the entire collision bounds of a Class.BasePart exits the bounds of another Class.BasePart or a filled Terrain voxel. It only fires as a result of physical simulation and will not fire when the part's Class.BasePart.Position|Position or Class.BasePart.CFrame|CFrame is explicitly set such that it stops intersecting another part or voxel.\\n\\nThe following code pattern shows how the Class.BasePart.TouchEnded|TouchEnded event can be connected to a custom onTouchEnded() function. Like Class.BasePart.Touched|Touched, the event sends the otherPart argument to the function, indicating the other part involved.\\n\\nlua title=\\\"Non-Collision Detection\\\" highlight=\\\"3-5, 7\\\"\\nlocal Workspace = game:GetService(\\\"Workspace\\\")\\n\\nlocal part = Workspace.Part\\n\\nlocal function onTouchEnded(otherPart)\\n\\tprint(part.Name .. \\\" is no longer touching \\\" .. otherPart.Name)\\nend\\n\\npart.TouchEnded:Connect(onTouchEnded)\\n\\nCollision filtering\\n\\nCollision filtering defines which physical parts collide with others. You can configure filtering for numerous objects through collision groups or you can control collisions on a part‑to‑part basis with Class.NoCollisionConstraint instances.\\n\\nCollision groups\\n\\nCollision groups let you assign Class.BasePart|BaseParts to dedicated groups and specify whether or not they collide with those in other groups. Parts within non‑colliding groups pass through each other completely, even if both parts have their Class.BasePart.CanCollide|CanCollide property set to true.\\n\\n\\n  In the video above, the spinning objects are in different collision groups such that they collide with objects of another color but not with objects of their own color\\n\\nYou can easily set up collision groups through Studio's Collision Groups editor, accessible through Studio's Window ⟩ 3D menu.\\n\\nThe editor functions in either List View which favors docking to the left or right side of Studio, or in a wider Table View, which favors docking to the top or bottom.\\n\\n\\n\\n\\n\\n\\n\\n\\nRegister groups\\n\\nThe editor includes one Default collision group which cannot be renamed or deleted. All Class.BasePart|BaseParts automatically belong to this default group unless assigned to another group, meaning that they will collide with all other objects in the Default group.\\n\\nTo create a new collision group:\\n\\n1. Click the Add Group button along the top of the editor panel, enter a new group name, and press Enter. The new group appears in both columns of list view, or in both the left column and upper row of table view.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n1. Repeat the process if necessary, choosing a unique and descriptive name for each group. Note that you can change a group's name during development by clicking in its field, or by selecting it and clicking the rename button.\\n\\n\\n\\nTo create a new collision group through scripting, include the Class.PhysicsService service and register the group with Class.PhysicsService:RegisterCollisionGroup(). It may be helpful to pre-declare your group names in local variables, as the same strings can be used for assigning objects and configuring groups within the same script.\\n\\nlua title=\\\"Collision Group Setup\\\" highlight=\\\"1,3,4,7,8\\\"\\nlocal PhysicsService = game:GetService(\\\"PhysicsService\\\")\\n\\nlocal cubes = \\\"Cubes\\\"\\nlocal doors = \\\"Doors\\\"\\n\\n-- Register two collision groups\\nPhysicsService:RegisterCollisionGroup(cubes)\\nPhysicsService:RegisterCollisionGroup(doors)\\n\\nSince scripts are not guaranteed to execute in any particular order, it's highly recommended that you register collision groups in a single script. Abstracting group registration among multiple scripts may result in a race condition where a group is not yet registered at the time you configure groups or assign objects to them.\\n\\nConfigure group collisions\\n\\nUnder default configuration, objects in all groups collide with each other. To prevent objects in one group from colliding with objects in another group, uncheck the box in the respective row/column.\\n\\nIn the following example, objects in the Cubes group will not collide with objects in the Doors group.\\n\\n\\n\\n\\n\\n\\n\\n\\nTo configure how objects in two collision groups interact, call Class.PhysicsService:CollisionGroupSetCollidable()|CollisionGroupSetCollidable(), providing the two collision groups and a boolean true (collidable) or false (non‑collidable). If objects in the same group should or shouldn't collide with each other, use that group name for both the first and second parameters.\\n\\nlua title=\\\"Collision Group Setup\\\" highlight=\\\"15\\\"\\nlocal PhysicsService = game:GetService(\\\"PhysicsService\\\")\\n\\nlocal cubes = \\\"Cubes\\\"\\nlocal doors = \\\"Doors\\\"\\n\\n-- Register two collision groups\\nPhysicsService:RegisterCollisionGroup(cubes)\\nPhysicsService:RegisterCollisionGroup(doors)\\n\\n-- Set cubes to be non-collidable with doors\\nPhysicsService:CollisionGroupSetCollidable(cubes, doors, false)\\n\\nAssign objects to groups\\n\\nTo assign objects to groups you've registered through the Studio editor:\\n\\n1. Select one or more Class.BasePart|BaseParts that qualify as part of a collision group.\\n2. Assign them to the group by clicking the &CirclePlus; button for its row. Objects can belong to only one collision group at a time, so placing them in a new group removes them from their current group.\\n\\n\\n\\nOnce assigned, the new group is reflected under the object's Class.BasePart.CollisionGroup|CollisionGroup property.\\n\\nTo add a Class.BasePart to a collision group through scripting, simply assign the group's string name, previously registered through Class.PhysicsService:RegisterCollisionGroup()|RegisterCollisionGroup(), to the part's Class.BasePart.CollisionGroup|CollisionGroup property.\\n\\nlua title=\\\"Collision Group Setup\\\" highlight=\\\"7,8,11,12\\\"\\nlocal PhysicsService = game:GetService(\\\"PhysicsService\\\")\\nlocal Workspace = game:GetService(\\\"Workspace\\\")\\n\\nlocal cubes = \\\"Cubes\\\"\\nlocal doors = \\\"Doors\\\"\\n\\n-- Register two collision groups\\nPhysicsService:RegisterCollisionGroup(cubes)\\nPhysicsService:RegisterCollisionGroup(doors)\\n\\n-- Set cubes to be non-collidable with doors\\nPhysicsService:CollisionGroupSetCollidable(cubes, doors, false)\\n\\n-- Assign an object to each group\\nWorkspace.Cube1.CollisionGroup = cubes\\nWorkspace.Door1.CollisionGroup = doors\\n\\nStudioSelectable collision group\\n\\nTools in Studio use the collision filtering system to determine which objects are candidates for selection when clicking in the 3D viewport. Objects whose assigned collision group does not collide with StudioSelectable will be ignored.\\n\\nFor example, if you have checkpoints in a racing experience whose effective areas are defined by large transparent parts, you can assign them to a Checkpoints collision group and then make that group non‑collidable with StudioSelectable so that they don't get in the way when you're editing the underlying map geometry.\\n\\nFor plugin code, it's recommended that you assign \\\"StudioSelectable\\\" as the collision group filter of your Datatype.RaycastParams when finding parts under the cursor. This allows your plugins to match the selection mechanics that creators have learned to expect from built‑in Studio tools.\\n\\nlua title=\\\"Recommended Plugin Selection Raycast\\\"\\nlocal UserInputService = game:GetService(\\\"UserInputService\\\")\\nlocal Workspace = game:GetService(\\\"Workspace\\\")\\n\\nlocal raycastParams = RaycastParams.new()\\nraycastParams.CollisionGroup = \\\"StudioSelectable\\\"  -- To follow the convention\\nraycastParams.BruteForceAllSlow = true  -- So that parts with CanQuery of \\\"false\\\" can be selected\\n\\nlocal mouseLocation = UserInputService:GetMouseLocation()\\nlocal mouseRay = Workspace.CurrentCamera:ViewportPointToRay(mouseLocation.X, mouseLocation.Y)\\nlocal filteredSelectionHit = Workspace:Raycast(mouseRay.Origin, mouseRay.Direction  10000, raycastParams)\\n\\nPart-to-part filtering\\n\\nTo prevent collisions between two specific parts without\\nsetting up collision groups, such as between a vehicle's wheel and its chassis, consider the\\nNo Collision\\nconstraint. Advantages include:\\n\\n- Collision groups and/or configuration scripts are not required, so you can easily create and share models with customized collision filtering.\\n- Connected parts will not collide with each other, but they can still\\n  collide with other objects.\\n\\nDisable character collisions\\n\\nRoblox player characters collide with each other by default. This can lead to\\ninteresting but unintended gameplay, such as characters jumping on top of each other to reach specific areas. If this behavior is undesirable, you can prevent it through the following Class.Script in Class.ServerScriptService.\\n\\nlua title=\\\"Script - Disable Character Collisions\\\"\\nlocal PhysicsService = game:GetService(\\\"PhysicsService\\\")\\nlocal Players = game:GetService(\\\"Players\\\")\\n\\nPhysicsService:RegisterCollisionGroup(\\\"Characters\\\")\\nPhysicsService:CollisionGroupSetCollidable(\\\"Characters\\\", \\\"Characters\\\", false)\\n\\nlocal function onDescendantAdded(descendant)\\n\\t-- Set collision group for any part descendant\\n\\tif descendant:IsA(\\\"BasePart\\\") then\\n\\t\\tdescendant.CollisionGroup = \\\"Characters\\\"\\n\\tend\\nend\\n\\nlocal function onCharacterAdded(character)\\n\\t-- Process existing and new descendants for physics setup\\n\\tfor , descendant in character:GetDescendants() do\\n\\t\\tonDescendantAdded(descendant)\\n\\tend\\n\\tcharacter.DescendantAdded:Connect(onDescendantAdded)\\nend\\n\\nPlayers.PlayerAdded:Connect(function(player)\\n\\t-- Detect when the player's character is added\\n\\tplayer.CharacterAdded:Connect(onCharacterAdded)\\nend)\\n\\nModel collisions\\n\\nClass.Model objects are containers for parts rather than inheriting from Class.BasePart, so they can't directly connect to Class.BasePart.Touched or Class.BasePart.TouchEnded events. To determine whether a model triggers a collision events, you need to loop through its children and connect the custom onTouched() and onTouchEnded() functions to each child Class.BasePart.\\n\\nFor joined parts by solid modeling instead of Class.Model objects, see Mesh and Solid Modeling Collisions.\\n\\nThe following code sample connects all Class.BasePart|BaseParts of a multi‑part model to collision events and tracks the total number of collisions with other parts.\\n\\nlua title=\\\"Model Collision\\\"\\nlocal model = script.Parent\\n\\nlocal numTouchingParts = 0\\n\\nlocal function onTouched(otherPart)\\n\\t-- Ignore instances of the model intersecting with itself\\n\\tif otherPart:IsDescendantOf(model) then return end\\n\\t-- Increase count of model parts touching\\n\\tnumTouchingParts += 1\\n\\n\\tprint(model.Name, \\\"intersected with\\\", otherPart.Name, \\\"| Model parts touching:\\\", numTouchingParts)\\nend\\n\\nlocal function onTouchEnded(otherPart)\\n\\t-- Ignore instances of the model un-intersecting with itself\\n\\tif otherPart:IsDescendantOf(model) then return end\\n\\t-- Decrease count of model parts touching\\n\\tnumTouchingParts -= 1\\n\\n\\tprint(model.Name, \\\"un-intersected from\\\", otherPart.Name, \\\"| Model parts touching:\\\", numTouchingParts)\\nend\\n\\nfor , child in model:GetChildren() do\\n\\tif child:IsA(\\\"BasePart\\\") then\\n\\t\\tchild.Touched:Connect(onTouched)\\n\\t\\tchild.TouchEnded:Connect(onTouchEnded)\\n\\tend\\nend\\n\\nMesh and solid model collisions\\n\\nClass.MeshPart and Class.PartOperation (parts joined by solid modeling) are subclasses of Class.BasePart, so meshes and solid modeled parts inherit the same collision events and collision filtering options as regular parts. However, since meshes and solid modeled parts usually have more complex geometries, they have a distinctive Class.TriangleMeshPart.CollisionFidelity|CollisionFidelity property which determines how precisely the physical bounds align with the visual representation for collision handling.\\n\\nThe Class.TriangleMeshPart.CollisionFidelity|CollisionFidelity property has the following options, in order of fidelity and performance impact from lowest to highest:\\n\\n- Box — Creates a bounding collision box, ideal for small or non‑interactive objects.\\n- Hull — Generates a convex hull, suitable for objects with less pronounced indentations or cavities.\\n- Default — Produces an approximate collision shape that supports concavity, suitable for complex objects with semi-detailed interaction needs.\\n- PreciseConvexDecomposition — Offers the most precise fidelity but still not a 1:1 representation of the visual. This option has the most expensive performance cost and takes longer for the engine to compute.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nTo view collision fidelity in Studio, toggle on Collision fidelity from the Visualization Options widget in the upper‑right corner of the 3D viewport.\\n\\nFor more information on the performance impact of collision fidelity options and how to mitigate them, see Performance optimization.\",\n    \"source\": \"collisions.md\"\n}",
    "source": "collisions.json"
}