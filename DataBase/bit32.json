{
    "title": "bit32",
    "description": "",
    "content": "This file is automatically generated. Please don't edit it manually.\nTo submit a bug report on the content, see\nhttps://devforum.roblox.com/c/bug-reports/documentation-issues/72\n\nname: bit32\ntype: library\nsummary: |\n  A library of functions to perform bitwise operations.\ndescription: |\n  This library provides functions to perform bitwise operations.\n\n  #### Number Limitations\n\n  This library treats numbers as unsigned 32-bit integers; numbers will be\n  converted to this before being used (see image below). Numbers with decimal\n  numbers are rounded to the nearest whole number.\n\n\ntags: []\ncodesamples: []\nproperties: []\nfunctions:\n  - name: bit32.arshift\n    summary: |\n      Returns a number after its bits have been arithmetically shifted to the\n      right by a given displacement.\n    description: |\n      Returns the number x shifted disp bits to the right. The number disp\n      may be any representable integer. Negative displacements shift to the\n      left.\n\n      This shift operation is what is called arithmetic shift. Vacant bits on\n      the left are filled with copies of the higher bit of x; vacant bits on\n      the right are filled with zeros. In particular, displacements with\n      absolute values higher than 31 result in zero or 0xFFFFFFFF (all original\n      bits are shifted out).\n    parameters:\n      - name: x\n        type: number\n        default:\n        summary: |\n          The number whose bits shall be shifted.\n      - name: disp\n        type: number\n        default:\n        summary: |\n          The integer number of bits to shift by.\n    returns:\n      - type: number\n        summary: ''\n    tags: []\n    codesamples: []\n    deprecationmessage: ''\n  - name: bit32.band\n    summary: |\n      Returns the bitwise AND of all provided numbers.\n    description: |\n      Returns the bitwise AND of all provided numbers.\n\n      Each bit is tested against the following truth table:\n\n\n\n\n            A\n            B\n            Output\n\n\n\n\n            0\n            0\n            0\n\n\n            1\n            0\n            0\n\n\n            0\n            1\n            0\n\n\n            1\n            1\n            1\n\n\n\n\n\n    parameters:\n      - name: numbers\n        type: Tuple\n        default:\n        summary: ''\n    returns:\n      - type: number\n        summary: ''\n    tags: []\n    codesamples: []\n    deprecationmessage: ''\n  - name: bit32.bnot\n    summary: |\n      Returns the bitwise negation of a given number.\n    description: |\n      Returns the bitwise negation of x.\n\n\n\n      For any integer x, the following identity holds:\n\n      lua\n      assert(bit32.bnot(x) == (-1 - x) % 2^32)\n\n    parameters:\n      - name: x\n        type: number\n        default:\n        summary: ''\n    returns:\n      - type: number\n        summary: ''\n    tags: []\n    codesamples: []\n    deprecationmessage: ''\n  - name: bit32.bor\n    summary: |\n      Returns the bitwise OR of all provided numbers.\n    description: |\n      Returns the bitwise OR of all provided numbers.\n\n      Each bit is tested against the following truth table:\n\n\n\n\n            A\n            B\n            Output\n\n\n\n\n            0\n            0\n            0\n\n\n            1\n            0\n            1\n\n\n            0\n            1\n            1\n\n\n            1\n            1\n            1\n\n\n\n\n\n    parameters:\n      - name: numbers\n        type: Tuple\n        default:\n        summary: ''\n    returns:\n      - type: number\n        summary: ''\n    tags: []\n    codesamples: []\n    deprecationmessage: ''\n  - name: bit32.btest\n    summary: |\n      Returns a boolean describing whether the bitwise and of its operands is\n      different from zero.\n    description: |\n      Returns a boolean signalling whether the bitwise and of its operands is\n      different from zero.\n    parameters:\n      - name: numbers\n        type: Tuple\n        default:\n        summary: ''\n    returns:\n      - type: bool\n        summary: ''\n    tags: []\n    codesamples: []\n    deprecationmessage: ''\n  - name: bit32.bxor\n    summary: |\n      Returns the bitwise XOR of all provided numbers.\n    description: |\n      Returns the bitwise XOR of all provided numbers.\n\n      Each bit is tested against the following truth table:\n\n\n\n\n            A\n            B\n            Output\n\n\n\n\n            0\n            0\n            0\n\n\n            1\n            0\n            1\n\n\n            0\n            1\n            1\n\n\n            1\n            1\n            0\n\n\n\n\n\n    parameters:\n      - name: numbers\n        type: Tuple\n        default:\n        summary: ''\n    returns:\n      - type: number\n        summary: ''\n    tags: []\n    codesamples: []\n    deprecationmessage: ''\n  - name: bit32.byteswap\n    summary: |\n      Returns the given number with the order of the bytes swapped.\n    description: |\n      Returns the given number with the order of the bytes swapped.\n    parameters:\n      - name: x\n        type: number\n        default:\n        summary: ''\n    returns:\n      - type: number\n        summary: ''\n    tags: []\n    codesamples: []\n    deprecationmessage: ''\n  - name: bit32.countlz\n    summary: |\n      Returns the number of consecutive zero bits in the 32-bit representation\n      of the provided number starting from the left-most (most significant) bit.\n    description: |\n      Returns the number of consecutive zero bits in the 32-bit representation\n      of the provided number starting from the left-most (most significant) bit.\n      Returns 32 if the provided number is zero.\n    parameters:\n      - name: 'n'\n        type: number\n        default:\n        summary: ''\n    returns:\n      - type: number\n        summary: ''\n    tags: []\n    codesamples: []\n    deprecationmessage: ''\n  - name: bit32.countrz\n    summary: |\n      Returns the number of consecutive zero bits in the 32-bit representation\n      of the provided number starting from the right-most (least significant)\n      bit.\n    description: |\n      Returns the number of consecutive zero bits in the 32-bit representation\n      of the provided number starting from the right-most (least significant)\n      bit. Returns 32 if the provided number is zero.\n    parameters:\n      - name: 'n'\n        type: number\n        default:\n        summary: ''\n    returns:\n      - type: number\n        summary: ''\n    tags: []\n    codesamples: []\n    deprecationmessage: ''\n  - name: bit32.extract\n    summary: |\n      Extract a range of bits from a number and return them as an unsigned\n      number.\n    description: |\n      Returns the unsigned number formed by the bits field to\n      field + width - 1 from n. Bits are numbered from 0 (least significant)\n      to 31 (most significant). All accessed bits must be in the range [0, 31].\n      The default for width is 1.\n    parameters:\n      - name: 'n'\n        type: number\n        default:\n        summary: ''\n      - name: field\n        type: number\n        default:\n        summary: ''\n      - name: width\n        type: number\n        default: 1\n        summary: ''\n    returns:\n      - type: number\n        summary: ''\n    tags: []\n    codesamples: []\n    deprecationmessage: ''\n  - name: bit32.replace\n    summary: |\n      Return a copy of a number with a range of bits replaced by a given value.\n    description: |\n      Returns a copy of n with the bits field to field + width - 1\n      replaced by the value v. See Library.bit32.extract() for details about\n      field and width.\n    parameters:\n      - name: 'n'\n        type: number\n        default:\n        summary: ''\n      - name: v\n        type: number\n        default:\n        summary: ''\n      - name: field\n        type: number\n        default:\n        summary: ''\n      - name: width\n        type: number\n        default: 1\n        summary: ''\n    returns:\n      - type: number\n        summary: ''\n    tags: []\n    codesamples: []\n    deprecationmessage: ''\n  - name: bit32.lrotate\n    summary: |\n      Returns a number after its bits have been rotated to the left by a given\n      number of times.\n    description: |\n      Returns the number x rotated disp bits to the left. The number disp\n      may be any representable integer. For any valid displacement, the\n      following identity holds:\n\n      lua\n      assert(bit32.lrotate(x, disp) == bit32.lrotate(x, disp % 32))\n\n\n      In particular, negative displacements rotate to the right.\n    parameters:\n      - name: x\n        type: number\n        default:\n        summary: ''\n      - name: disp\n        type: number\n        default:\n        summary: ''\n    returns:\n      - type: number\n        summary: ''\n    tags: []\n    codesamples: []\n    deprecationmessage: ''\n  - name: bit32.lshift\n    summary: |\n      Returns a number whose bits have been logically shifted to the left by a\n      given displacement.\n    description: |\n      Returns the number x shifted disp bits to the left. The number disp\n      may be any representable integer. Negative displacements shift to the\n      right. In any direction, vacant bits are filled with zeros. In particular,\n      displacements with absolute values higher than 31 result in zero (all bits\n      are shifted out).\n\n\n\n      For positive displacements, the following equality holds:\n\n      lua\n      assert(bit32.lshift(b, disp) == (b  2^disp) % 2^32)\n\n    parameters:\n      - name: x\n        type: number\n        default:\n        summary: ''\n      - name: disp\n        type: number\n        default:\n        summary: ''\n    returns:\n      - type: number\n        summary: ''\n    tags: []\n    codesamples: []\n    deprecationmessage: ''\n  - name: bit32.rrotate\n    summary: |\n      Returns a number after its bits have been rotated to the right by a given\n      number of times.\n    description: |\n      Returns the number x rotated disp bits to the right. The number disp\n      may be any representable integer.\n\n      For any valid displacement, the following identity holds:\n\n      lua\n      assert(bit32.rrotate(x, disp) == bit32.rrotate(x , disp % 32))\n\n\n      In particular, negative displacements rotate to the left.\n    parameters:\n      - name: x\n        type: number\n        default:\n        summary: ''\n      - name: disp\n        type: number\n        default:\n        summary: ''\n    returns:\n      - type: number\n        summary: ''\n    tags: []\n    codesamples: []\n    deprecationmessage: ''\n  - name: bit32.rshift\n    summary: |\n      Returns a number whose bits have been logically shifted to the right by a\n      given displacement.\n    description: |\n      Returns the number x shifted disp bits to the right. The number disp\n      may be any representable integer. Negative displacements shift to the\n      left. In any direction, vacant bits are filled with zeros. In particular,\n      displacements with absolute values higher than 31 result in zero (all bits\n      are shifted out).\n\n\n\n      For positive displacements, the following equality holds:\n\n      lua\n      assert(bit32.rshift(b, disp) == (b % 2^32 / 2^disp) // 1)\n\n\n      This shift operation is what is called logical shift.\n    parameters:\n      - name: x\n        type: number\n        default:\n        summary: ''\n      - name: disp\n        type: number\n        default:\n        summary: ''\n    returns:\n      - type: number\n        summary: ''\n    tags: []\n    codesamples: []\n    deprecationmessage: ''",
    "source": "bit32.yaml"
}