{
    "title": "Deferred engine events",
    "description": "Deferred engine events defer event handlers until certain resumption points.",
    "content": "The Class.Workspace.SignalBehavior property controls whether event handlers are fired immediately or deferred. The Enum.SignalBehavior.Deferred option is recommended which helps improve the performance and correctness of the engine. The event handlers for deferred events are resumed at the next resumption point, along with any newly triggered event handlers.\n\nThe Enum.SignalBehavior.Default value of Class.Workspace.SignalBehavior is currently equivalent to Enum.SignalBehavior.Immediate, but will eventually switch to being equivalent to Enum.SignalBehavior.Deferred. Template places are directly set to Enum.SignalBehavior.Deferred by default.\n\nThe following diagram compares the Enum.SignalBehavior.Immediate|Immediate event behavior and the Enum.SignalBehavior.Deferred|Deferred event behavior.\n\n- With the Immediate behavior, if an event triggers another event, the second event handler fires immediately.\n- With the Deferred behavior, the second event is added to the back of a queue and run later.\n\nThe total time taken does not change, but the ordering is different.\n\n\"Re-entrancy\" prevents events from continuously firing one another when they reach a certain depth. The current limit for this is 10.\n\nDeferred event benefits\n\nThe Immediate behavior has some disadvantages. For every instance added to your experience, property that changes, or some other trigger that is invoked, the engine needs to run Luau code before anything else happens.\n\n- To change 1,000 properties, 1,000 snippets of code potentially need to run after each change.\n- Strange, hard-to-diagnose bugs can occur, such as a removing event firing before something was even added.\n- Performance-critical systems can fire events requiring them to yield back and forth to Luau.\n- Event handlers can make changes to the place or trigger other events any time an event is fired.\n- An event can fire multiple times despite being redundant, such as a property changing twice.\n\nBy having specific portions of the engine life cycle in which Luau can run, the engine can gain improved performance by using a number of assumptions:\n\n- Performance-critical systems don't need to yield to Luau, which leads to performance gains.\n- Unless the engine itself changes it, the place never changes outside of a resumption point.\n\nResumption points\n\nAfter being deferred, an event handler is resumed at the next resumption point. Currently, the set of resumption points includes:\n\n- Input processing (resumes once per input to be processed, see Class.UserInputService)\n- Class.RunService.PreRender\n- Legacy waiting script resumption such as wait(), spawn(), and delay()\n- Class.RunService.PreAnimation\n- Class.RunService.PreSimulation\n- Class.RunService.PostSimulation\n- Waiting script resumption such as Library.task.wait(), Library.task.spawn(), and Library.task.delay()\n- Class.RunService.Heartbeat\n- Class.DataModel.BindToClose\n\nCommon affected code patterns\n\nWith remote events, the following examples either stop working correctly or have subtly different behavior; they rely on events being resumed immediately.\n\nTrigger and catch events mid-execution\n\nIn this example, false is always returned when deferred events are enabled because the callback has not run. To work correctly, the thread must yield until at least when the event should have fired.\n\nlua\nlocal success = false\nevent:Connect(function ()\n   success = true\nend)\ndoSomethingToTriggerEvent() -- Causes event to fire\nreturn success\n\nListen for the first occurrence of an event\n\nlua\nconnection = event:Connect(function ()\n   connection:Disconnect()\n   -- do something\nend)\n\nWith deferred events enabled, multiple event handler invocations can be queued before you disconnect from the event. Calling Class.Instance.Disconnect()|Disconnect() drops all pending event handler invocationsâ€”the same behavior that exists for immediate events.\n\nAny other method of disconnection besides Class.Instance.Disconnect()|Disconnect(), such as calling Class.Instance.Destroy()|Destroy() on the Class.Instance, disconnects the signal immediately, but runs the associated event handler for any events that are still pending.\n\nAlternatively, use Datatype.RBXScriptSignal.Once()|Once() as a more convenient method for connecting to an event that you only need the first invocation of.\n\nEvents that change ancestry or properties\n\nDeferred events cause events that handle a change in ancestry or a property to fire after the ancestry or property is changed:\n\nlua\nlocal part = Instance.new(\"Part\", workspace)\n\nlocal function onPartDestroying()\n\tprint(\"In signal:\", part:GetFullName(), #part:GetChildren())\nend\n\npart.Destroying:Connect(onPartDestroying)\npart:Destroy()\n\nBecause Class.Instance.Destroy()|Destroy() works immediately after the script that called it yields, the instance has already been destroyed by the time onPartDestroying() is called. For more examples, see Class.Instance.Destroying.",
    "source": "deferred.md"
}