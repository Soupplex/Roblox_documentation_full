{
    "title": "Strings",
    "description": "A sequence of characters, such as letters, numbers, and symbols.",
    "content": "The string data type is a sequence of characters, such as letters, numbers, and symbols. It's the data type for storing most text-based information.\n\nDeclare strings\n\nTo declare a string variable, put quotes around the characters. It's more common to use double quotes (\"), but single quotes (') also work. If you want to include a single or double quote in your string, enclose your string in the other type of quote, or use an escaped quote.\n\nlua\nlocal string1 = \"Hello world!\"\nprint(string1)  --> Hello world!\n\nlocal string2 = 'Hello \"world\"!'\nprint(string2)  --> Hello \"world\"!\n\nTo include both single and double quotes in a string, or to create multi-line strings, declare them using double brackets:\n\nlua\nlocal string1 = [[Hello\nworld!\nHello \"world\"!\nHello 'world'!]]\n\nprint(string1)\n--> Hello\n--> world!\n--> Hello \"world\"!\n--> Hello 'world'!\n\nIf necessary, you can nest multiple brackets inside a string using the same number of equal signs in both the beginning and ending bracket:\n\nlua\nlocal string1 = [=[Hello\n[[world!]]\n]=]\n\nprint(string1)\n--> Hello\n--> [[world!]]\n\nCombine strings\n\nTo combine strings, concatenate them with two dots (..). Concatenating strings doesn't insert a space between them, so you'll need to include space(s) at the end/beginning of a preceding/subsequent string, or concatenate a space between the two strings.\n\nlua\nlocal hello = \"Hello\"\nlocal helloWithSpace = \"Hello \"\nlocal world = \"world!\"\n\nlocal string1 = hello .. world\nlocal string2 = helloWithSpace .. world\nlocal string3 = hello .. \" \" .. world\n\nprint(string1)  --> Helloworld!\nprint(string2)  --> Hello world!\nprint(string3)  --> Hello world!\n\nNote that the print() command takes multiple arguments and combines them with spaces, so you can use , instead of .. to yield spaces in print() outputs.\n\nlua\nlocal hello = \"Hello\"\nlocal world = \"world\"\nlocal exclamationMark = \"!\"\n\nprint(hello .. world .. exclamationMark)  --> Helloworld!\nprint(hello, world .. exclamationMark)  --> Hello world!\nprint(hello, world, exclamationMark)  --> Hello world !\n\nConvert strings\n\nTo convert a string to a number, use the Global.LuaGlobals.tonumber() function. If the string doesn't have a number representation, Global.LuaGlobals.tonumber() returns nil.\n\nlua\nlocal numericString = \"123\"\nprint(tonumber(numericString))  --> 123\n\nlocal alphanumericString = \"Hello123\"\nprint(tonumber(alphanumericString))  --> nil\n\nEscape strings\n\nTo escape a double- or single-quote string declaration and embed almost any character, put a backslash (\\) before the character. For example:\n\n- To embed a single quote in a single-quote string, use \\'.\n- To embed a double quote in a double-quote string, use \\\".\n\nlua\nlocal string1 = 'Hello \\'world\\'!'\nprint(string1)  --> Hello 'world'!\n\nlocal string2 = \"Hello \\\"world\\\"!\"\nprint(string2)  --> Hello \"world\"!\n\nCertain characters following backslashes produce special characters rather than escaped characters:\n\n- To embed a new line, use \\n.\n- To embed a horizontal tab, use \\t.\n\nlua\nlocal string1 = \"Hello\\nworld!\"\nprint(string1)\n--> Hello\n--> world!\n\nlocal string2 = \"Hello\\tworld!\"\nprint(string2)  --> Hello\tworld!\n\nString interpolation\n\nLuau supports string interpolation, a feature that lets you insert expressions into strings. Use backticks (  ) to declare an interpolated string, then add expressions inside of curly brackets:\n\nlua\nlocal world = \"world\"\n\nlocal string1 = Hello {world}!\nprint(string1)  --> Hello world!\n\nAlthough variables are the most common usage, you can use any expression, including math:\n\nlua\nlocal world = \"world\"\nlocal number = 1\nlocal letters = {\"w\", \"o\", \"r\", \"l\", \"d\"}\n\nlocal string1 = Hello {world}, {number} time!\nlocal string2 = Hello {world}, {number + 1} times!\nlocal string3 = Hello {table.concat(letters)} a third time!\n\nprint(string1)  --> Hello world, 1 time!\nprint(string2)  --> Hello world, 2 times!\nprint(string3)  --> Hello world a third time!\n\nStandard escape rules apply for backticks, curly brackets, and backslashes:\n\nlua\nlocal string1 = Hello \\\\{world\\}\\!\nprint(string1)  --> Hello {world}!\n\nMath conversion\n\nIf you perform math operations on a string, Luau automatically converts the string to a number. If the string doesn't have a number representation, it throws an error.\n\nlua\nprint(\"55\" + 10)  --> 65\nprint(\"55\" - 10)  --> 45\nprint(\"55\"  10)  --> 550\nprint(\"55\" / 10)  --> 5.5\nprint(\"55\" % 10)  --> 5\nprint(\"Hello\" + 10)\t --> print(\"Hello\" + 10):1: attempt to perform arithmetic (add) on string and number\n\nComparisons\n\nStrings can be compared using the  and >= operators which compare using lexicographical order based on the ASCII codes of each character in a string.\nThis will result in numbers in strings not being compared correctly, for example, \"100\" will be less than \"20\", since the bytes \"0\" and \"1\" have lower ASCII codes than byte \"2\".\n\nlua\nprint(\"Apple\"  true\nprint(\"Banana\"  true (B is before a in ASCII)\nprint(\"number100\"  true\n\nString pattern reference\n\nA string pattern is a combination of characters that you can use with\nLibrary.string.match(), Library.string.gmatch(), and other functions to\nfind a piece, or substring, of a longer string.\n\nDirect matches\n\nYou can use direct matches in a Luau function like Library.string.match(),\nexcept for magic characters. For example, these commands\nlook for the word Roblox within a string:\n\nlua\nlocal match1 = string.match(\"Welcome to Roblox!\", \"Roblox\")\nlocal match2 = string.match(\"Welcome to my awesome game!\", \"Roblox\")\nprint(match1)  --> Roblox\nprint(match2)  --> nil\n\nCharacter classes\n\nCharacter classes are essential for more advanced string searches. You can use\nthem to search for something that isn't necessarily character-specific but\nfits within a known category (class), including letters, digits,\nspaces, punctuation, and more.\n\nThe following table shows the official character classes for Luau string\npatterns:\n\n\tClass\n\tRepresents\n\tExample Match\n\n\n\t.\n\tAny character\n\t32kasGJ1%fTlk?@94\n\n\n\t%a\n\tAn uppercase or lowercase letter\n\taBcDeFgHiJkLmNoPqRsTuVwXyZ\n\n\n\t%l\n\tA lowercase letter\n\tabcdefghijklmnopqrstuvwxyz\n\n\n\t%u\n\tAn uppercase letter\n\tABCDEFGHIJKLMNOPQRSTUVWXYZ\n\n\n\t%d\n\tAny digit (number)\n\t0123456789\n\n\n\t%p\n\tAny punctuation character\n\t!@#;,.\n\n\n\t%w\n\tAn alphanumeric character (either a letter or a number)\n\taBcDeFgHiJkLmNoPqRsTuVwXyZ0123456789\n\n\n\t%s\n\tA space or whitespace character\n\t , \\n, and \\r\n\n\n\t%c\n\tA special control character\n\n\n\n\t%x\n\tA hexadecimal character\n\t0123456789ABCDEF\n\n\n\t%z\n\tThe NULL character (\\0)\n\n\n\nFor single-letter character classes such as %a and %s, the corresponding\nuppercase letter represents the \"opposite\" of the class. For instance, %p\nrepresents a punctuation character while %P represents all characters except\npunctuation.\n\nMagic characters\n\nThere are 12 \"magic characters\" which are reserved for special purposes in\npatterns:\n\n\n\t$\n\t%\n\t^\n\n\t(\n\t)\n\n\n\t.\n\t[\n\t]\n\t+\n\t-\n\t?\n\n\nYou can escape and search for magic characters using the % symbol. For\nexample, to search for roblox.com, escape the . (period) symbol by\npreceding it with a % as in %..\n\nlua\n-- \"roblox.com\" matches \"roblox#com\" because the period is interpreted as \"any character\"\nlocal match1 = string.match(\"What is roblox#com?\", \"roblox.com\")\nprint(match1)  --> roblox#com\n\n-- Escape the period with % so it is interpreted as a literal period character\nlocal match2 = string.match(\"I love roblox.com!\", \"roblox%.com\")\nprint(match2)  --> roblox.com\n\nAnchors\n\nYou can search for a pattern at the beginning or end of a string by using the\n^ and $ symbols.\n\nlua\nlocal start1 = string.match(\"first second third\", \"^first\")  -- Matches because \"first\" is at the beginning\nprint(start1)  --> first\n\nlocal start2 = string.match(\"third second first\", \"^first\")  -- Doesn't match because \"first\" isn't at the beginning\nprint(start2)  --> nil\n\nlocal end1 = string.match(\"first second third\", \"third$\")  -- Matches because \"third\" is at the end\nprint(end1)  --> third\n\nlocal end2 = string.match(\"third second first\", \"third$\")  -- Doesn't match because \"third\" isn't at the end\nprint(end2)  --> nil\n\nYou can also use both ^ and $ together to ensure a pattern matches only\nthe full string and not just some portion of it.\n\nlua\n-- Using both ^ and $ to match across a full string\nlocal match1 = string.match(\"Roblox\", \"^Roblox$\")  -- Matches because \"Roblox\" is the entire string (equality)\nprint(match1)  --> Roblox\n\nlocal match2 = string.match(\"I play Roblox\", \"^Roblox$\")  -- Doesn't match because \"Roblox\" isn't at the beginning AND end\nprint(match2)  --> nil\n\nlocal match3 = string.match(\"I play Roblox\", \"Roblox\")  -- Matches because \"Roblox\" is contained within \"I play Roblox\"\nprint(match3)  --> Roblox\n\nClass modifiers\n\nBy itself, a character class only matches one character in a string. For\ninstance, the following pattern (\"%d\") starts reading the string from left\nto right, finds the first digit (2), and stops.\n\nlua\nlocal match = string.match(\"The Cloud Kingdom has 25 power gems\", \"%d\")\nprint(match)  --> 2\n\nYou can use modifiers with any character class to control the result:\n\n\tQuantifier\n\tMeaning\n\n\n\t+\n\tMatch 1 or more of the preceding character class\n\n\n\t-\n\tMatch as few of the preceding character class as possible\n\n\n\n\tMatch 0 or more of the preceding character class\n\n\n\t?\n\tMatch 1 or less of the preceding character class\n\n\n\t%n\n\tFor n between 1 and 9, matches a substring equal to the nth captured string.\n\n\n\t%bxy\n\tThe balanced capture matching x, y, and everything between (for example, %b() matches a pair of parentheses and everything between them)\n\n\nAdding a modifier to the same pattern (\"%d+\" instead of \"%d\"), outputs\n25 instead of 2:\n\nlua\nlocal match1 = string.match(\"The Cloud Kingdom has 25 power gems\", \"%d\")\nprint(match1)  --> 2\n\nlocal match2 = string.match(\"The Cloud Kingdom has 25 power gems\", \"%d+\")\nprint(match2)  --> 25\n\nClass sets\n\nSets should be used when a single character class can't do the whole job.\nFor instance, you might want to match both lowercase letters (%l) and\npunctuation characters (%p) using a single pattern.\n\nSets are defined by brackets [] around them. In the following example,\nnotice the difference between using a set (\"[%l%p]+\") and not using a\nset (\"%l%p+\").\n\nlua\nlocal match1 = string.match(\"Hello!!! I am another string.\", \"[%l%p]+\")  -- Set\nprint(match1)  --> ello!!!\n\nlocal match2 = string.match(\"Hello!!! I am another string.\", \"%l%p+\")  -- Non-set\nprint(match2)  --> o!!!\n\nThe first command (set) tells Luau to find both lowercase characters and\npunctuation. With the + quantifier added after the entire set, it finds\nall of those characters (ello!!!), stopping when it reaches the space.\n\nIn the second command (non-set), the + quantifier only applies to the %p\nclass before it, so Luau grabs only the first lowercase character (o) before\nthe series of punctuation (!!!).\n\nLike character classes, sets can be \"opposites\" of themselves. This is done by\nadding a ^ character at the beginning of the set, directly after the opening\n[. For instance, \"[%p%s]+\" represents both punctuation and spaces, while\n\"[^%p%s]+\" represents all characters except punctuation and spaces.\n\nSets also support ranges which let you find an entire range of matches\nbetween a starting and ending character. This is an advanced feature which is\noutlined in more detail on the\nLua 5.1 Manual.\n\nString captures\n\nString captures are sub-patterns within a pattern. These are enclosed in\nparentheses () and are used to get (capture) matching substrings and save\nthem to variables. For example, the following pattern contains two captures,\n(%a+) and (%d+), which return two substrings upon a successful match.\n\nlua\nlocal pattern = \"(%a+)%s?=%s?(%d+)\"\n\nlocal key1, val1 = string.match(\"TwentyOne = 21\", pattern)\nprint(key1, val1)  --> TwentyOne 21\n\nlocal key2, val2 = string.match(\"TwoThousand= 2000\", pattern)\nprint(key2, val2)  --> TwoThousand 2000\n\nlocal key3, val3 = string.match(\"OneMillion=1000000\", pattern)\nprint(key3, val3)  --> OneMillion 1000000\n\nThe ? quantifier that follows both of the %s classes is a safe addition\nbecause it makes the space on either side of the = sign optional. That means\nthe match succeeds if one (or both) spaces are missing around the equal sign.\n\nIn the Library.string.gsub() function, you can include capture groups in the\nreplacement string using %1, %2, %3, etc., up to %9. Even though Luau\nsupports up to 32 capture groups before throwing an error, you can only\nreference the first nine with this syntax:\n\nlua\nlocal str = \"love2play Roblox\"\nlocal pattern = \"(%w+)(%d+)(%w+)%s+(%w+)\"\nlocal replacement = \"I %1 %2 %3 %4!\"\n\nlocal result = string.gsub(str, pattern, replacement)\nprint(result) --> I love 2 play Roblox!\n\nYou can also nest string captures:\n\nlua\nlocal places = \"The Cloud Kingdom is heavenly, The Forest Kingdom is peaceful\"\nlocal pattern = \"(The%s(%a+%sKingdom)[%w%s]+)\"\n\nfor description, kingdom in string.gmatch(places, pattern) do\n\tprint(description)\n\tprint(kingdom)\nend\n--> The Cloud Kingdom is heavenly\n--> Cloud Kingdom\n--> The Forest Kingdom is peaceful\n--> Forest Kingdom\n\nThis pattern search works as follows:\n\nThe Library.string.gmatch() iterator looks for a match on the entire\n\"description\" pattern defined by the outer pair of parentheses. This stops at\nthe first comma and captures the following:\n\n\n\n\t\t\t#\n\t\t\tPattern\n\t\t\tCapture\n\n\n\n\n\t\t\t1\n\t\t\t(The%s(%a+%sKingdom)[%w%s]+)\n\t\t\tThe Cloud Kingdom is heavenly\n\n\n\nUsing its successful first capture, the iterator then looks for a match on the\n\"kingdom\" pattern defined by the inner pair of parentheses. This nested\npattern simply captures the following:\n\n\n\n\t\t\t#\n\t\t\tPattern\n\t\t\tCapture\n\n\n\n\n\t\t\t2\n\t\t\t(%a+%sKingdom)\n\t\t\tCloud Kingdom\n\n\n\nThe iterator then backs out and continues searching the full string, capturing\nthe following:\n\n\n\n\t\t\t#\n\t\t\tPattern\n\t\t\tCapture\n\n\n\n\n\t\t\t3\n\t\t\t(The%s(%a+%sKingdom)[%w%s]+)\n\t\t\tThe Forest Kingdom is peaceful\n\n\n\t\t\t4\n\t\t\t(%a+%sKingdom)\n\t\t\tForest Kingdom\n\n\n\nIn addition to all of the above, there is a special case with an empty capture (()). If a capture is empty, then the position in the string will be captured:\n\nlua\nlocal match1 = \"Where does the capture happen? Who knows!\"\nlocal match2 = \"This string is longer than the first one. Where does the capture happen? Who knows?!\"\n\nlocal pattern = \"()Where does the capture happen%? Who knows!()\"\n\nlocal start1, finish1 = string.match(match1, pattern)\nprint(start1, finish1)  --> 1 42\n\nlocal start2, finish2 = string.match(match2, pattern)\nprint(start2, finish2)  --> 43 84\n\nThese special captures may be nested like normal ones:\n\nlua\nlocal places = \"The Cloud Kingdom is heavenly, The Forest Kingdom is peaceful.\"\nlocal pattern = \"The (%a+()) Kingdom is %a+\"\n\nfor kingdom, position in string.gmatch(places, pattern) do\n\tprint(kingdom, position)\nend\n--> Cloud 10\n--> Forest 42\n\nThe returned values are unusual in that they are numbers rather than strings:\n\nlua\nlocal match = \"This is an example\"\nlocal pattern = \"This is an ()example\"\n\nlocal position = string.match(match, pattern)\nprint(typeof(position))  --> number",
    "source": "strings.md"
}