{
    "title": "Services",
    "description": "Services provide pre-built functionality in the Roblox Engine.",
    "content": "In Reuse code, you might have noticed frequent use of the game:GetService() method. Roblox services let you access the built-in features of the engine, like selling in-experience items, enabling chat, playing sounds, animating objects, and managing instances.\n\nIn fact, services are the first step in the most fundamental, common pattern of Roblox development:\n\n1. Get services.\n1. Require module scripts.\n1. Add local functions.\n1. Add the events that trigger those functions.\n\nFor example, you might want to save players' positions in the world when they exit your experience:\n\nlua\nlocal Players = game:GetService(\"Players\")\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal SaveManager = require(ReplicatedStorage:WaitForChild(\"SaveManager\"))\n\n-- Local function that calls a reusable function in the module script.\nlocal function saveProgress(character)\n\t-- Get the position of the player's character.\n\tlocal position = character:FindFirstChild(\"HumanoidRootPart\").Position\n\t-- Use the saveData function in the module script, which writes to the\n\t-- DataStoreService.\n\tSaveManager.saveData(character, position)\nend\n\n-- Another local function that calls saveProgress() when a character is removed\n-- from the experience (in this case, when the player leaves).\nlocal function onPlayerAdded(player)\n\tplayer.CharacterRemoving:Connect(saveProgress)\nend\n\n-- Calls onPlayerAdded when a player first connects to the experience.\nPlayers.PlayerAdded:Connect(onPlayerAdded)\n\nSome key details include:\n\n- Because you should only retrieve a service once per script, the convention is to give the variable the same name as the service. This convention applies to module scripts, as well.\n- You retrieve services with the global variable Class.DataModel|game, a reference to the root of the data model.\n- Roblox doesn't make guarantees around loading order (and instance streaming further complicates what is and isn't loaded at any given time), so the use of Class.Instance:WaitForChild() is an important safety measure.\n\nRather than comparing standard libraries, global functions and variables, or third-party libraries, a big part of Roblox development is identifying which of the many, many services can help you add the desired functionality to your experiences. In the example above, instead of using a standard I/O library to write to disk, you use cloud services to store data.\n\nContainer services\n\nContainer services can contain and influence other objects. These container\nservices reside at the root of the data model and are visible in Studio's\nExplorer window. Collectively, these container services\nform a structured hierarchy for the data model, so the Roblox Engine can\nproperly interpret and render your place. The following table includes some common container services.\n\nService | Description\n:--- | :---\nClass.Workspace | Contains all objects that render in the 3D world, such as parts and terrain.\nClass.Lighting | Contains objects for setting universal lighting effects, such as Class.Atmosphere and Class.Sky.\nClass.ReplicatedStorage and Class.ReplicatedFirst | Contain content and logic that replicates between the server and client.\n\nTo further examine the data model, you can use these methods:\n\n- Class.DataModel:FindService()|game:FindService() searches for the instance of the specified service.\n- Class.DataModel:GetChildren()|game:GetChildren() returns an array of all root children of the data model, which are the top-level container services.\n- Class.DataModel:GetDescendants()|game:GetDescendants() returns an array of all the descendants of the data model, including all container services and their children.\n\nFor more information on container services, see the data\nmodel documentation.\n\nScripting services\n\nScripting services provide standard functionality in the Roblox Engine that you\ncall within scripts. The following table includes some common scripting services.\n\nService | Description\n:--- | :---\nClass.TweenService | Used to interpolate numeric properties of other instances from a start to end value, with options for easing direction and style, repeat, and delay.\nClass.MarketplaceService | The service responsible for in-experience transactions, such as prompting the player to purchase a developer product, subscription, pass, Roblox Premium, etc.\nClass.RunService | Contains methods and events for frame-by-frame time management, as well as for checking the context (server, client, Studio mode) in which the experience is running. Useful for running any process or update on every runtime frame.\nClass.SoundService | Controls various global aspects of how audio plays in an experience, such as the doppler scale and volumetric audio. Can also contain sound groups to control the volume and dynamic effects properties of multiple audio signals at once.\nClass.CollectionService | Manages groups (collections) of instances with tags that replicate from the server to the client, letting you more easily assign and work with groups of related instances.\n\nCloud services\n\nRoblox also has special cloud services for handling tasks and processes\nthat occur in the Roblox cloud. The following table includes some common cloud services.\n\nService | Description\n:--- | :---\nClass.DataStoreService | For storing persistent data across sessions.\nClass.MemoryStoreService | For storing frequent and ephemeral data that change rapidly.\nClass.MessagingService | For communicating between multiple servers during live sessions.\n\nCloud services also have corresponding web APIs; they're accessible from external scripts or tools. For more information, see Open Cloud.",
    "source": "services.md"
}