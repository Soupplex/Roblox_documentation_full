{
    "title": "Memory store sorted map",
    "description": "Explains how to implement the sorted map data structure for memory stores.",
    "content": "The sorted map data structure of memory stores allows you to store frequent in-memory data as key-value pairs with an optional sort key and maintain a specific order based on the sort keys and keys. Unlike queues, the order of keys entering a map doesn't determine the order of processing, making sorted maps useful for sorting based data organization for implementing in-experience entities for engagement such as leaderboards and cross-server auctioning.\n\nLimits\n\nIn addition to the data structure size limits, sorted maps have a key size limit of 128 characters, a value size limit of 32 KB, and a sort key size limit of 128 characters.\n\nIf you need to store data that surpasses this limit for your experience, you can adopt the sharding technique to split and distribute them through key prefix into multiple data structures. Sharding memory stores can also help improve the scalability of your system.\n\nGet a sorted map\n\nTo get a sorted map, call Class.MemoryStoreService:GetSortedMap() with a name you want to define for the map. The name is global within the experience, so you can access the same sorted map on any script using the name.\n\nlua title=\"Getting a Sorted Map\"\nlocal MemoryStoreService = game:GetService(\"MemoryStoreService\")\n\nlocal sortedMap = MemoryStoreService:GetSortedMap(\"SortedMap1\")\n\nAfter you get a sorted map, call any of the following functions:\n\n\n    Function\n    Action\n\n\n\n    Class.MemoryStoreSortedMap:SetAsync()\n    Add a new key or overwrite the value and/or sort key if the key already exists.\n\n\n    Class.MemoryStoreSortedMap:GetAsync()\n    Read a particular key.\n\n\n    Class.MemoryStoreSortedMap:GetRangeAsync()\n    Read all existing keys or a specific range of them.\n\n\n    Class.MemoryStoreSortedMap:UpdateAsync()\n    Update the value of a key and/or sort key after retrieving it from a sorted map.\n\n\n    Class.MemoryStoreSortedMap:RemoveAsync()\n    Remove a key from the sorted map.\n\n\n\t\tClass.MemoryStoreSortedMap:GetSizeAsync()\n\t\tGet the number of items in the sorted map.\n\n\nAll functions accessing data structures in memory stores are asynchronous network calls that might occasionally fail. You should wrap these calls in Global.LuaGlobals.pcall() to catch and handle errors, like the code sample in each section does.\n\nAdd or overwrite data\n\nTo add a new key or overwrite the value or sort key of a key in the sorted map, call Class.MemoryStoreSortedMap:SetAsync() with the key name, its value, an expiration time in seconds and an optional sort key. The memory automatically cleans up once the key expires. The maximum expiration time is 3,888,000 seconds (45 days). The sort key, if provided, must be a valid number (integer or floating point) or a string.\n\nIn the sorting order of your keys, a sort key takes precedence over a key. For example, when sorting in ascending order, numeric sort keys sort first, followed by string sort keys, followed by items with no sort key. All items with numeric sort keys are sorted by sort key, if the sort key for two items is equal, they are sorted by key. Similarly, all items with string sort keys are sorted by sort key, if the sort key for two items is equal, they are sorted by key. All items with no sort key are sorted just by the key.\n\nExample of some data sorted in ascending order -\n\ntext\n{key: \"player1\", value: someValue1, sortKey: -1}\n{key: \"player2\", value: someValue2, sortKey: 0}\n{key: \"player4\", value: someValue3, sortKey: 1}\n{key: \"player5\", value: someValue4, sortKey: 1}\n{key: \"player3\", value: someValue5, sortKey: 3.14}\n{key: \"player6\", value: someValue6, sortKey: \"someString\"}\n{key: \"player0\", value: someValue7}\n{key: \"player7\", value: someValue8}\n\nNote how player0 sorts after all keys with a sort key. player6 sorts after all keys with a numeric sort key. player4 and player5 have the same sort key, so they are sorted in ascending order by key.\n\nUnder the EU General Data Protection Regulation (GDPR), if your memory stores have user data subject to Right to be Forgotten you must remove the data in 30 days, even if you set your memory store key's expiration up to 45 days.\n\nlua title=\"Adding Data to a Sorted Map\"\nlocal MemoryStoreService = game:GetService(\"MemoryStoreService\")\n\nlocal sortedMap = MemoryStoreService:GetSortedMap(\"SortedMap1\")\n\nlocal setSuccess,  = pcall(function()\n\treturn sortedMap:SetAsync(\"User1234\", 1000, 30, 3.14152)\nend)\nif setSuccess then\n\tprint(\"Set succeeded.\")\nend\n\nGet data\n\nYou can either get a data value and sort key associated with a specific key or get multiple values and sort keys for keys within a range.\n\nGet data with one key\n\nTo get a value and sort key associated with one key from the sorted map, call Class.MemoryStoreSortedMap:GetAsync() with the key name.\n\nlua title=\"Getting a Particular Key from a Sorted Map\"\nlocal MemoryStoreService = game:GetService(\"MemoryStoreService\")\n\nlocal sortedMap = MemoryStoreService:GetSortedMap(\"SortedMap1\")\n\nlocal setSuccess,  = pcall(function()\n\treturn sortedMap:SetAsync(\"User1234\", 1000, 30, 3.14152)\nend)\nif setSuccess then\n\tprint(\"Set succeeded.\")\nend\n\nlocal item\nlocal getSuccess, getError = pcall(function()\n\titem = sortedMap:GetAsync(\"User1234\")\nend)\nif getSuccess then\n\tprint(item)\nelse\n\twarn(getError)\nend\n\nGet data with multiple keys\n\nTo get data for multiple keys from the sorted map as a single operation, call Class.MemoryStoreSortedMap:GetRangeAsync(). This function lists all existing keys by default, but you can set the upper and lower bounds for the key range. For example, the following code sample retrieves up to 20 items starting from the beginning of the sorted map, with keys greater than or equal to 10, sort keys greater than or equal to 100 and keys less than or equal to 50, sort keys less than or equal to 500.\n\nlua title=\"Getting a Range of Keys from a Sorted Map\"\nlocal MemoryStoreService = game:GetService(\"MemoryStoreService\")\n\nlocal sortedMap = MemoryStoreService:GetSortedMap(\"SortedMap1\")\n\nlocal lowerBound = {}\nlowerBound[\"key\"] = \"10\"\nlowerBound[\"sortKey\"] = 100\nlocal upperBound = {}\nupperBound[\"key\"] = \"50\"\nupperBound[\"sortKey\"] = 500\n\n-- Get up to 20 items starting from the beginning\nlocal getSuccess, items = pcall(function()\n\treturn sortedMap:GetRangeAsync(\n\t\tEnum.SortDirection.Ascending, 20, lowerBound, upperBound)\nend)\nif getSuccess then\n\tfor , item in items do\n\t\tprint(item.key)\n\t\tprint(item.sortKey)\n\tend\nend\n\nUpdate data\n\nTo retrieve the value and sort key of a key from a sorted map and update it, call Class.MemoryStoreSortedMap:UpdateAsync() with the key name, a callback function to update the value and sort key for this key, and an expiration time in seconds. The maximum expiration time is 3,888,000 seconds (45 days).\n\nFor most experiences, multiple servers can update the same key concurrently and change the value. As Class.MemoryStoreSortedMap:UpdateAsync()|UpdateAsync() always modifies the latest value before updating, you should use it to read the latest value as the input for your callback function.\n\nFor example, the following code sample updates the score in a leaderboard for a player. The score is calculated as kills / deaths. Class.MemoryStoreSortedMap:UpdateAsync()|UpdateAsync() ensures that the kills and deaths are updated for the most recent values even if multiple experience servers update the same item simultaneously. A player's kills and deaths are monotonically increasing values and can hence only increase in value in a session.\n\nlua title=\"Updating the leaderboard score for a player in a Sorted Map\"\nlocal MemoryStoreService = game:GetService(\"MemoryStoreService\")\n\nlocal sortedMap = MemoryStoreService:GetSortedMap(\"Leaderboard\")\n\nlocal function updateLeaderboard(itemKey, killsToAdd, deathsToAdd)\n\tlocal success, newStats, newScore = pcall(function()\n\t\treturn sortedMap:UpdateAsync(itemKey, function(playerStats, playerScore)\n\t\t\tplayerStats = playerStats or { kills = 0, deaths = 0 }\n\t\t\tplayerStats.kills += killsToAdd\n\t\t\tplayerStats.deaths += deathsToAdd\n\t\t\tif playerStats then\n\t\t\t\t-- playerScore is the sortKey being used to sort items in the map\n\t\t\t\tplayerScore = playerStats.kills / math.max(playerStats.deaths, 1)\n\t\t\t\treturn playerStats, playerScore\n\t\t\tend\n\t\t\treturn nil\n\t\tend, 30)\n\tend)\n\tif success then\n\t\tprint(newStats)\n\t\tprint(newScore)\n\tend\nend\n\nThe latency for Class.MemoryStoreSortedMap:UpdateAsync()|UpdateAsync() is similar to Class.MemoryStoreSortedMap:GetAsync()|GetAsync() and Class.MemoryStoreSortedMap:SetAsync()|SetAsync() unless there is contention.\n\nWhen contention occurs, the system automatically retries the operation until one of these three happens: the operation succeeds, the callback function returns nil, or the maximum number of retries is reached. If the system reaches the maximum number of retries, it returns a conflict.\n\nRemove data\n\nYou can use Class.MemoryStoreSortedMap:RemoveAsync() for both removing one key from the sorted map and deleting all data in a memory store sorted map.\n\nRemove a key\n\nTo remove a key from the sorted map, call Class.MemoryStoreSortedMap:RemoveAsync() with a key name.\n\nlua title=\"Remove a Key from a Sorted Map\"\nlocal MemoryStoreService = game:GetService(\"MemoryStoreService\")\n\nlocal sortedMap = MemoryStoreService:GetSortedMap(\"SortedMap1\")\n\nlocal setSuccess,  = pcall(function()\n\treturn sortedMap:SetAsync(\"User1234\", 1000, 30, \"someStringSortKey\")\nend)\nif setSuccess then\n\tprint(\"Set succeeded.\")\nend\n\nlocal removeSuccess, removeError = pcall(function()\n\tsortedMap:RemoveAsync(\"User1234\")\nend)\nif not removeSuccess then\n\twarn(removeError)\nend\n\nDelete all data\n\nTo delete memory in sorted maps, list all your keys with Class.MemoryStoreSortedMap:GetRangeAsync(), then remove them with Class.MemoryStoreSortedMap:RemoveAsync().\n\nlua title=\"Delete Memory in a Sorted Map\"\nlocal MemoryStoreService = game:GetService(\"MemoryStoreService\")\n\nlocal sortedMap = MemoryStoreService:GetSortedMap(\"SortedMap1\")\n\n-- Initial lower bound of nil starts flush from first item\nlocal exclusiveLowerBound = nil\n\nwhile true do\n\t-- Get up to a hundred items starting from current lower bound\n\tlocal getRangeSuccess, items = pcall(function()\n\t\treturn sortedMap:GetRangeAsync(Enum.SortDirection.Ascending, 100, exclusiveLowerBound)\n\tend)\n\tif getRangeSuccess then\n\t\tlocal removeSuccess = true\n\t\tlocal removeError = nil\n\n\t\tfor , item in items do\n\t\t\tremoveSuccess, removeError = pcall(function()\n\t\t\t\tsortedMap:RemoveAsync(item.key)\n\t\t\tend)\n\t\tend\n\n\t\t-- If there was an error removing items, try again with the same exclusive lower bound\n\t\tif not removeSuccess then\n\t\t\twarn(removeError)\n\t\t-- If range is less than a hundred items, end of map is reached\n\t\telseif #items < 100 then\n\t\t\tbreak\n\t\telse\n\t\t\t-- The last retrieved key is the exclusive lower bound for the next iteration\n\t\t\texclusiveLowerBound = {}\n\t\t\texclusiveLowerBound[\"key\"] = items[#items].key\n\t\t\texclusiveLowerBound[\"sortKey\"] = items[#items].sortKey\n\t\tend\n\tend\nend\n\nGet size\n\nTo get the number of items in the sorted map, call\nClass.MemoryStoreSortedMap:GetSizeAsync().\n\nlua title=\"Getting the Size of a Sorted Map\"\nlocal MemoryStoreService = game:GetService(\"MemoryStoreService\")\n\nlocal sortedMap = MemoryStoreService:GetSortedMap(\"SortedMap1\")\n\nlocal setSuccess,  = pcall(function()\n\treturn sortedMap:SetAsync(\"User1234\", 1000, 30, 3.14152)\nend)\n\nif setSuccess then\n\tprint(\"Set succeeded.\")\nend\n\nlocal size\nlocal success, sizError = pcall(function()\n\tsize = sortedMap:GetSizeAsync()\nend)\n\nif success then\n\tprint(size)\nelse\n\twarn(sizeError)\nend",
    "source": "sorted-map.md"
}