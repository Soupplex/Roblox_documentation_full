{
    "title": "Improve performance",
    "description": "Lists common performance problems and steps to mitigate them.",
    "content": "This page describes common performance problems and best practices for mitigating them.\n\nScript computation\n\nExpensive operations in Luau code take longer to process and can thus impact frame rate. Unless it is being executed in parallel, Luau code runs synchronously and blocks the main thread until it encounters a function that yields the thread.\n\nCommon problems\n\n- Intensive operations on table structures - Complex operations such as\n  serialization, deserialization, and deep cloning incur a high performance\n  cost, especially on large table structures. This is particularly true if these\n  operations are recursive or involve iterating over very large data structures.\n- High frequency events - Tying expensive operations to frame-based events\n  of Class.RunService without limiting the frequency means these operations\n  are repeated every frame, which often results in an unnecessary increase in\n  computation time. These events include:\n\n  - Class.RunService.PreAnimation\n  - Class.RunService.PreRender\n  - Class.RunService.PreSimulation\n  - Class.RunService.PostSimulation\n  - Class.RunService.Heartbeat\n\nMitigation\n\n- Invoke code on Class.RunService events sparingly, limiting usage to cases\n  where high frequency invocation is essential (for example, updating the\n  camera). You can execute most other code in other events or less frequently in\n  a loop.\n- Break up large or expensive tasks using Library.task.wait() to spread the\n  work across multiple frames.\n- Identify and optimize unnecessarily expensive operations and use\n  multithreading for computationally\n  expensive tasks that don't need to access the data model.\n- Certain server-side scripts can benefit from native code generation, a simple flag that compiles a script to machine code rather than bytecode.\n\nMicroProfiler scopes\n\n\n    Scope\n    Associated computation\n\n\n    RunService.PreRender\n    Code executing on the PreRender event\n\n\n    RunService.PreSimulation\n    Code executing on the Stepped event\n\n\n    RunService.PostSimulation\n    Code executing on Heartbeat event\n\n\n    RunService.Heartbeat\n    Code executing on Heartbeat event\n\n\nFor more information on debugging scripts using the MicroProfiler, see the\nLibrary.debug library, which includes functions for tagging specific code and\nfurther increasing specificity, such as Library.debug.profilebegin and\nLibrary.debug.profileend. Many Roblox API methods called by scripts also have\ntheir own associated MicroProfiler tags that can provide useful signal.\n\nScript memory usage\n\nMemory leaks can occur when you write scripts that consume memory that the\ngarbage collector can't properly release when its no longer in use. Leaks are\nspecifically pervasive on the server, because they can continuously be online\nfor many days, whereas a client session is much shorter.\n\nThe following memory values in the Developer Console can indicate a problem that needs further investigation:\n\n- LuaHeap - High or growing consumption suggests a memory leak.\n- InstanceCount - Consistently growing numbers of instances suggest references to some instances in your code are not being garbage collected.\n- PlaceScriptMemory - Provides a script by script breakdown of memory usage.\n\nCommon problems\n\n- Leaving connections connected - The engine never garbage collects events connected to an instance and any values referenced inside the connected callback. Therefore, active connections of events and code inside the connected instances, connected functions, and referenced values, are out of scope for the memory garbage collector, even after the events are fired.\n\n  Although events are disconnected when the instance they belong to is\n  destroyed, a common mistake is to assume this applies to Class.Player\n  objects. After a user leaves an experience, the engine doesn't automatically\n  destroy their representative Class.Player object and character model, so\n  connections to the Class.Player object and instances under the character\n  model, such as Class.Player.CharacterAdded|CharacterAdded, still consume memory if you don't disconnect them in your scripts.\n\tThis can result in very significant memory leaks over time on the server as hundreds of users join and leave the experience.\n\n- Tables - Inserting objects into tables but not removing them when they are\n  no longer needed causes unnecessary memory consumption, especially for tables\n  that track user data when they join. For example, the following code sample creates a table adding user information each time a user joins:\n\n   lua title=\"Example\"\n   local playerInfo = {}\n   Players.PlayerAdded:Connect(function(player)\n\t   playerInfo[player] = {} -- some info\n   end)\n\n\n   If you don't remove these entries when they are no longer needed, the table continues to grow in size and consumes more memory as more users join the session. Any code that iterates over this table also becomes more computationally expensive as the table grows in size.\n\nMitigation\n\nTo clean up all used values for preventing memory leaks:\n\n- Disconnect all connections - Go through your codebase and make sure each\n  connection is cleaned up via one of the following paths:\n  - Disconnecting manually using the Datatype.RBXScriptConnection:Disconnect()|Disconnect() function.\n  - Destroying the instance the event belongs to with the Class.Instance:Destroy()|Destroy() function.\n  - Destroying the script object that the connection traces back to.\n\n- Remove player objects and characters after leaving - Enable Class.Workspace.PlayerCharacterDestroyBehavior to automatically destroy player objects and character models after a user leaves. If you prefer, you can instead clean them up manually:\n\n   lua title=\"Example player and character cleanup\"\n\t local Players = game:GetService(\"Players\")\n   Players.PlayerAdded:Connect(function(player)\n     player.CharacterRemoving:Connect(function(character)\n       task.defer(character.Destroy, character)\n     end)\n   end)\n\n   Players.PlayerRemoving:Connect(function(player)\n\t   task.defer(player.Destroy, player)\n   end)\n\n\nPhysics computation\n\nExcessive physics simulation can be a key cause of increased computation time\nper frame on both the server and the client.\n\nCommon problems\n\n- Excessive physics time step frequency - By default, stepping behavior is\n  in adaptive mode, where physics\n  steps at either 60 Hz, 120 Hz, or 240 Hz, depending on the complexity of the\n  physics mechanism.\n\n  A fixed mode with improved accuracy of physics is also available, which\n  forces all physics assemblies to step at 240 Hz (four times per frame). This\n  results in significantly more computation each frame.\n\n- Excessive number of complexity of simulated objects - The more 3D\n  assemblies that are simulated, the longer physics computations take each\n  frame. Often, experiences will have objects being simulated that do not need\n  to be or will have mechanisms that have more constraints and joints than they\n  need.\n- Overly precise collision detection - Mesh parts have a\n  Class.MeshPart.CollisionFidelity|CollisionFidelity property for detecting\n  collision which offers a variety of modes with different levels of\n  performance impact. Precise collision detection mode for mesh parts has the\n  most expensive performance cost and takes the engine longer to compute.\n\nMitigation\n\n- Anchor parts that don't require simulation - Anchor all parts that don't\n  need to be driven by physics, such as for static NPCs.\n- Use adaptive physics stepping - Adaptive stepping dynamically adjusts the\n  rate of physics calculations for physics mechanisms, allowing physics updates\n  to be made less frequently in some cases.\n- Reduce mechanism complexity\n  - Where possible, minimize the number of physics constraints or joints in an\n    assembly.\n  - Reduce the amount of self-collision within a mechanism, such as by applying\n    limits or no-collision constraints to ragdoll limbs to prevent them from\n    colliding with each other.\n\n- Reduce the usage of precise collision fidelity for meshes\n  - For small or non-interactable objects where users would rarely notice the\n    difference, use box fidelity.\n  - For small-medium size objects, use box or hull fidelities, depending on the\n    shape.\n  - For large and very complex objects, build out custom collisions using\n    invisible parts when possible.\n  - For objects that don't require collisions, disable collisions and use box or\n    hull fidelity, since the collision geometry is still stored in memory.\n  - You can render collision geometry for debug purposes in Studio by toggling\n  \ton Collision fidelity from the Visualization Options widget in the upper‑right corner of the 3D viewport.\n\n    Alternatively, you can apply the CollisionFidelity=PreciseConvexDecomposition filter to the Explorer which shows a count of all mesh parts with the precise fidelity and allows you to easily select them.\n\n  - For an in-depth walkthrough on how to choose a collision fidelity option that balances your precision and performance requirements, see Set physics and rendering parameters.\n\nMicroProfiler scopes\n\n\n    Scope\n    Associated computation\n\n\n    physicsStepped\n    Overall physics computation\n\n\n    worldStep\n    Discrete physics steps taken each frame\n\n\nPhysics memory usage\n\nPhysics movement and collision detection consumes memory. Mesh parts have a Class.MeshPart.CollisionFidelity|CollisionFidelity property that determines the approach that's used to evaluate the collision bounds of the mesh.\n\nCommon problem\n\nThe default and precise collision detection modes consumes significantly more memory than the two other modes with lower fidelity collision shapes.\n\nIf you see high levels of memory consumption under PhysicsParts, you might need to explore reducing the collision fidelity of objects in your experience.\n\nHow to mitigate\n\nTo reduce memory used for collision fidelity:\n\n- For parts that do not need collisions, disable their collisions by setting Class.BasePart.CanCollide, Class.BasePart.CanTouch and Class.BasePart.CanQuery to false.\n- Reduce fidelity of collisions using the Class.MeshPart.CollisionFidelity|CollisionFidelity setting. Enum.CollisionFidelity.Box|Box has the lowest memory overhead, and Enum.CollisionFidelity.Default|Default and Enum.CollisionFidelity.Precise|Precise are generally more expensive.\n  - It's generally safe to set any small anchored part's collision fidelity to Enum.CollisionFidelity.Box|Box.\n  - For very complex large meshes, you may want to build your own collision mesh out of smaller objects with box collision fidelity.\n\nHumanoids\n\nClass.Humanoid is a class that provides a wide range of functionalities to\nplayer and non player characters (NPCs). Although powerful, a Class.Humanoid\ncomes with a significant computation cost.\n\nCommon problems\n\n- Leaving all HumanoidStateTypes enabled on NPCs - There is a performance\n  cost to leaving certain Enum.HumanoidStateType|HumanoidStateTypes\n  enabled. Disable any that are not needed for your NPCs. For\n  example, unless your NPC is going to climb ladders, it's safe to disable\n  the Enum.HumanoidStateType.Climbing|Climbing state.\n- Instantiating, modifying, and respawning models with Class.Humanoid|Humanoids or skinned Class.MeshPart|MeshParts frequently\n  - This can be intensive for the engine to process, particularly if these models use layered clothing. This also can be particularly problematic in experiences where avatars respawn often.\n  - In the MicroProfiler, lengthy updateInvalidatedFastClusters tags\n    (over 4 ms) are often a signal that avatar instantiation/modification is\n    triggering excessive invalidations.\n- Using Humanoids in cases where they are not required - Static NPCs that do\n  not move generally have no need for the Class.Humanoid class.\n- Playing animations on a large number of NPCs from the server - NPC\n  animations that run on the server need to be simulated on the server and replicated\n  to the client. This can be unnecessary overhead.\n- Performing unnecessary size and scale changes - Size/scale changes cause FastCluster to be rebuilt. Try to reduce this during gameplay if you are seeing FastCluster-related performance issues. Similarly, other property changes might also cause FastCluster to be rebuilt, so in general reduce these changes as much as possible.\n\nMitigation\n\n- Play NPC animations on the client - In experiences with a large number of\n  NPCs, consider creating the Class.Animator on the client and running the\n  animations locally. This reduces the load on the server and the need for\n  unnecessary replication. It also makes additional optimizations possible (such\n  as only playing animations for NPCs who are near to the character).\n- Use performance-friendly alternatives to Humanoids - NPC models don't\n  necessarily need to contain a humanoid object.\n  - For static NPCs, use a simple Class.AnimationController, because they\n    don't need to move around but just need to play animations.\n  - For moving NPCs, consider implementing your own movement controller and\n    using an Class.AnimationController for animations, depending on the\n    complexity of your NPCs.\n- Disable unused humanoid states - Use Class.Humanoid:SetStateEnabled() to\n  only enable necessary states for each humanoid.\n- Pool NPC models with frequent respawning - Instead of destroying an NPC\n  completely, send the NPC to a pool of inactive NPCs. This way, when a new NPC\n  is required to respawn, you can simply reactivate one of the NPCs from the pool. This\n  process is called pooling, which minimizes the amount of times characters need\n  to be instantiated.\n- Only spawn NPCs when users are nearby - Don't spawn NPCs when users aren't\n  in range, and cull them when users leave their range.\n- Avoid making changes to the avatar hierarchy after it is instantiated - Certain modifications to an avatar hierarchy have significant performance implications. Some optimizations are available:\n  - For custom procedural animations, don't update the Class.JointInstance.C0 and Class.JointInstance.C1 properties. Instead, update the Class.Motor6D.Transform property.\n  - If you need to attach any Class.BasePart objects to the avatar, do so outside the hierarchy of the avatar Class.Model.\n\nMicroProfiler scopes\n\n\n    Scope\n    Associated computation\n\n\n    stepHumanoid\n    Humanoid control and physics\n\n\n    stepAnimation\n    Humanoid and animator animation\n\n\n    updateInvalidatedFastClusters\n    Associated with instantiating or modifying an avatar\n\n\nRendering\n\nA significant portion of the time the client spends each frame is on rendering\nthe scene in the current frame. The server doesn't do any rendering, so this\nsection is exclusive to the client.\n\nDraw calls\n\nA draw call is a set of instructions from the engine to the GPU to render\nsomething. Draw calls have significant overhead. Generally, the fewer draw\ncalls per frame, the less computational time is spent rendering a frame.\n\nYou can see how many draw calls are currently occurring with the Render Stats ⟩ Timing item in Studio. You can view Render Stats in the client by pressing ShiftF2.\n\nThe more objects that need to be drawn in your scene in a given frame, the more\ndraw calls are made to the GPU. However, the Roblox Engine utilizes a process\ncalled instancing to collapse identical meshes with the same texture\ncharacteristics into a single draw call. Specifically, multiple meshes with the\nsame Class.MeshPart.MeshContent|MeshContent are handled in a single draw call when:\n\n- Class.SurfaceAppearance|SurfaceAppearances are identical if present, otherwise when Class.MeshPart.TextureContent|TextureContents are identical.\n- Materials are identical when both Class.SurfaceAppearance and\n  Class.MeshPart.TextureID don't exist.\n\nOther common problems\n\n- Excessive object density - If a large number of objects are concentrated\n  with a high density, then rendering this area of the scene requires more\n  draw calls. If you are finding your frame rate drops when looking at a certain\n  part of the map, this can be a good signal that object density in this area is\n  too high.\n\n  Objects like decals, textures, and particles don't batch well and introduce\n  additional draw calls. Pay extra attention to these object types in a scene. In particular, property changes to Class.ParticleEmitter|ParticleEmitters can have a dramatic impact on performance.\n\n- Missed instancing opportunities - Often, a scene will include the same mesh\n  duplicated a number of times, but each copy of the mesh has different mesh or\n  texture asset IDs. This prevents instancing and can lead to unnecessary draw\n  calls.\n\n  A common cause of this problem is when an entire scene is imported at once,\n  rather than individual assets being imported into Roblox and then duplicated\n  post-import to assemble the scene.\n\n  Even a simple script like this one can help you identify mesh parts with the\n  same name that use different mesh IDs:\n\n  lua\n  for ,descendant in workspace:GetDescendants() do\n    if descendant:IsA(\"MeshPart\") then\n      print(descendant.Name .. \", \" .. descendant.MeshId)\n    end\n  end\n\n\n  The output (with Stack Lines enabled) might look something like this. Repeated lines indicate reuse of the same mesh, which is good. Unique lines aren't necessarily bad, but depending on your naming scheme, could indicate duplicate meshes in your experience:\n\n  text\n  LargeRock, rbxassetid://106420009602747 (x144) -- good\n  LargeRock, rbxassetid://120109824668127\n  LargeRock, rbxassetid://134460273008628\n  LargeRock, rbxassetid://139288987285823\n  LargeRock, rbxassetid://71302144984955\n  LargeRock, rbxassetid://90621205713698\n  LargeRock, rbxassetid://113160939160788\n  LargeRock, rbxassetid://135944592365226 -- all possible duplicates\n\n\n- Excessive object complexity - Although not as important as the number of\n  draw calls, the number of triangles in a scene does influence how long a frame\n  takes to render. Scenes with a very large number of very complex meshes are a\n  common problem, as are scenes with the Class.MeshPart.RenderFidelity property set\n  to Enum.RenderFidelity.Precise|Precise on too many meshes.\n\n- Excessive shadow casting - Handling shadows is an expensive process, and\n  maps that contain a high number and density of light objects that cast shadows\n  (or a high number and density of small parts influenced by shadows) can have\n  performance issues.\n\n- High transparency overdraw - Placing objects with partial transparency\n  near each other forces the engine to render the overlapping pixels multiple\n  times, which can hurt performance. For more information on identifying and\n  fixing this issue, see\n  Delete layered transparencies.\n\n- Unnecessary skinned MeshPart movement - Skinned MeshParts that are part of a Model without a Humanoid are grouped using spatially-organized FastClusters. When these MeshParts move, they must be continually added to and removed from these spatial clusters, forcing the clusters to be rebuilt and impacting performance.\n  - A highly effective workaround is to embed a Humanoid within the Model. The presence of a Humanoid overrides the default spatial clustering behavior, mandating the use of a single, unified FastCluster for the entire Model. Consequently, position updates no longer necessitate cluster rebuilds, thus mitigating the performance bottleneck. This technique should be reserved exclusively for MeshParts with expected movement, as it may introduce memory overhead and negate the benefits of spatial optimization. We recommend always profile your experience after making these types of changes. See Humanoid performance tips for additional information.\n- Too many parts in a Class.Model - Too many parts in a Model could cause rebuilds more often due to the potential for a part's property to change leading to requiring a full rebuild. Find the right balance of parts in a Model when it is using FastCluster.\n\nMitigation\n\n- Instancing identical meshes and reducing the amount of unique meshes - If\n  you ensure all identical meshes to have the same underlying asset IDs, the\n  engine can recognize and render them in a single draw call. Make sure to only\n  upload each mesh in a map once and then duplicate them in Studio for reuse rather\n  than importing large maps as a whole, which might cause identical meshes to\n  have separate content IDs and be recognized as unique assets by the engine.\n  Packages are a helpful mechanism for\n  object reuse.\n- Culling - Culling describes the process of eliminating draw calls for\n  objects that don't factor into the final rendered frame. By default, the\n  engine skips draw calls for objects outside the camera's field of view\n  (frustum culling) and parts, meshes, and terrain occluded from view by other\n  objects (occlusion culling). In certain scenarios, such as indoor\n  environments, you might be able to implement a room or portal system and\n  manually cull objects to further reduce draw calls or overall computational\n  load.\n- Reducing render fidelity - Set Class.MeshPart.RenderFidelity to Enum.RenderFidelity.Automatic|Automatic or Enum.RenderFidelity.Performance|Performance. This allows meshes to fall back to less complex\n  alternatives, which can reduce the number of polygons that need to be drawn.\n- Disabling shadow casting on appropriate parts and light objects - The\n  Roblox engine automatically degrades shadow quality as client graphics quality\n  level decreases, eventually disabling shadows altogether at quality levels\n  below 4. However, you can selectively disable shadow casting properties on\n  light objects and parts to improve performance while shadows are enabled and\n  increase the likelihood that shadows remain enabled. Some examples of\n  optimizations you can make either at edit time or dynamically at runtime:\n  - Use the Class.BasePart.CastShadow property to disable shadow casting on\n    small parts where shadows are unlikely to be visible. This strategy is\n    particularly effective when applied to parts that are far away from the\n    user's camera.\n\n\n    This might result in visual artifacts on shadows.\n\n\n  - Disable shadows on moving objects when possible.\n  - Disable Class.Light.Shadows on light instances where the object does not\n    need to cast shadows.\n  - Limit the range and angle of light instances.\n  - Use fewer light instances.\n  - Consider disabling lights that are outside of a specific range or on a\n    room-by-room basis for indoor environments.\n\nMicroProfiler scopes\n\n\n    Scope\n    Associated computation\n\n\n    Prepare and Perform\n    Overall rendering\n\n\n    Perform/Scene/computeLightingPerform\n    Light grid and shadow updates\n\n\n    LightGridCPU\n    Voxel light grid updates\n\n\n    ShadowMapSystem\n    Shadow mapping\n\n\n    Perform/Scene/UpdateView\n    Preparation for rendering and particle updates\n\n\n    Perform/Scene/RenderView\n    Rendering and post processing\n\n\nNetworking and replication\n\nNetworking and replication describes the process by which data is sent between the\nserver and connected clients. Information is sent between the client and server\nevery frame, but larger amounts of information require more compute time.\n\nCommon problems\n\n- Excessive remote traffic - Sending a large amount of data through\n  Class.RemoteEvent or Class.RemoteFunction objects or invoking them very frequently\n  can lead to a large amount of CPU time being spent processing incoming packets\n  each frame. Common mistakes include:\n  - Replicating data every frame that does not need to be replicated.\n  - Replicating data on user input without any mechanism to throttle it.\n  - Dispatching more data than is required. For example, sending the player's\n    entire inventory when they purchase an item rather than just details of the\n    item purchased.\n- Creation or removal of complex instance trees - When a change is made to\n  the data model on the server, it is replicated to connected clients. This\n  means creating and destroying large instance hierarchies like maps at runtime\n  can be very network intensive.\n\n  A common culprit here is the complex animation data saved by Animation Editor\n  plugins in rigs. If these aren't removed before the experience is published and\n  the animated model is cloned regularly, a large amount of data will be\n  replicated unnecessary.\n\n- Server-side TweenService - If Class.TweenService is used to tween an object\n  server side, the tweened property is replicated to each client every\n  frame. Not only does this result in the tween being jittery as clients'\n  latency fluctuates, but it causes a lot of unnecessary network traffic.\n\nMitigation\n\nYou can employ the following tactics to reduce unnecessary replication:\n\n- Avoid sending large amounts of data at once through remote events.\n  Instead, only send necessary data at a lower frequency. For example, for a\n  character's state, replicate it when it changes rather than every\n  frame.\n- Chunk up complex instance trees like maps and load them in pieces to\n  distribute the work replicating these across multiple frames.\n- Clean up animation metadata, especially the animation directory of rigs,\n  after importing.\n- Limit unnecessary instance replication, especially in cases where the\n  server doesn't need to have knowledge of the instances being created. This\n includes:\n  - Visual effects such as an explosion or a magic spell blast. The server only\n    needs to know the location to determine the outcome, while the clients can\n    create visuals locally.\n  - First-person item view models.\n  - Tween objects on the client rather than the server.\n\nMicroProfiler scopes\n\n\n    Scope\n    Associated computation\n\n\n    ProcessPackets\n    Processing for incoming network packets, such as event invocations and property changes\n\n\n    Allocate Bandwidth and Run Senders\n    Outgoing events relevant on servers\n\n\nAsset memory usage\n\nThe highest impact mechanism available to creators to improve client memory usage is to enable Instance streaming.\n\nInstance streaming\n\nInstance streaming selectively loads out parts of the data model that are not required, which can lead to considerably reduced load times and increase the client's ability to prevent crashes when it comes under memory pressure.\n\nIf you are encountering memory issues and have instance streaming disabled, consider updating your experience to support it, particularly if your 3D world is large. Instance streaming is based on distance in 3D space, so larger worlds naturally benefit more from it.\n\nIf instance streaming is enabled, you can increase the aggressiveness of it. For example, consider:\n\n- Reducing use of Enum.ModelStreamingMode.Persistent where possible. You may need to update your scripts if you're using it as a compatibility measure.\n- Reducing the Workspace.StreamingMinRadius and Workspace.StreamingTargetRadius.\n\nFor more information on streaming options and their benefits, see Streaming properties.\n\nOther common problems\n\n- Asset duplication - A common mistake is to upload the same asset multiple times resulting in different asset IDs. This can lead to the same content being loaded into memory multiple times.\n- Excessive asset volume - Even when assets are not identical, there are cases when opportunities to reuse the same asset and save memory are missed.\n- Audio files - Audio files can be a surprising contributor to memory usage, particularly if you load all of them into the client at once rather than only loading what you need for a portion of the experience. For strategies, see Load times.\n- High resolution textures - Graphics memory consumption for a texture is unrelated to the size of the texture on the disk; the number of pixels in the texture determines memory usage. For example, a 1024x1024 pixel texture consumes four times the graphics memory of a 512x512 texture.\n\n  Images uploaded to Roblox are transcoded to a fixed format, so there is no memory benefit to uploading images in a color model associated with fewer bytes per pixel. Similarly, compressing images prior to upload or removing the alpha channel from images that don't need it can decrease image size on disk, but doesn't improve memory usage.\n\n  As an experience loads, the engine automatically starts with lower quality textures and then ramps up quality based on available device memory, distance from the camera, amount of screen-space that the texture takes up, and other factors. Even still, strategically sizing your textures can improve memory usage in your experience.\n\nMitigation\n\n- Only upload assets once - Reuse the same asset ID across objects and ensure the same assets, especially meshes and images, aren't uploaded separately multiple times.\n- Find and fix duplicate assets - Look for identical mesh parts and textures that are uploaded multiple times with different IDs.\n  - Though there is no API to detect similarity of assets automatically, you can collect all the image asset IDs in your place (either manually or with a script), download them, and compare them using external comparison tools.\n  - For mesh parts, the best strategy is to take unique mesh IDs and organize them by size to manually identify duplicates.\n  - Instead of using separate textures for different colors, upload a single texture and use the Class.SurfaceAppearance.Color property to apply various tints to it.\n- Import assets in map separately - Instead of importing an entire map at once, import and reconstruct assets in the map individually and reconstruct them. The 3D importer doesn't do any de-duplication of meshes, so if you were to import a large map with a lot of separate floor tiles, each of those tiles would be imported as a separate asset (even if they are duplicates). This can lead to performance and memory issues down the line, as each mesh is treated as individually and takes up memory and draw calls.\n- Limit the pixels of images to no more than the necessary amount. Unless an image is occupying a large amount of physical space on the screen, it usually needs at most 512x512 pixels. Most minor images should be smaller than 256x256 pixels.\n- Use trim sheets to ensure maximum texture reuse in 3D maps. For steps and examples on how to create trim sheets, see Create trim sheets.\n\n  You might also consider using sprite sheets to load many smaller UI images as a single image. You can then use Class.ImageLabel.ImageRectOffset and Class.ImageLabel.ImageRectSize to display portions of the sheet.\n\nLoad times\n\nMany experiences implement custom loading screens and use the Class.ContentProvider:PreloadAsync() method to request assets so that images, sounds, and meshes are downloaded in the background.\n\nThe advantage of this approach is that it lets you ensure important parts of your experience are fully loaded without pop-in. However, a common mistake is overutilizing this method to preload more assets than are actually required.\n\nAn example of a bad practice is loading the entire Class.Workspace. While this might prevent texture pop-in, it significantly increases load times.\n\nAnother similar practice is utilising Class.ContentProvider.RequestQueueSize to ensure that all requested assets have finished loading. However, this presents the same issue of significantly increased load times, while also being an unreliable method due to its fluctuating nature.\n\nInstead, only use Class.ContentProvider:PreloadAsync() in necessary situations, which include:\n\n- Images in the loading screen.\n- Important images in your experience menu, such as button backgrounds and icons.\n- Important assets in the starting or spawning area.\n\nIf you must load a large number of assets, we recommend you provide a Skip Loading button.",
    "source": "improve.md"
}