{
    "title": "Character pathfinding",
    "description": "Pathfinding is the process of moving a character along a logical path to reach a destination.",
    "content": "Pathfinding is the process of moving a character along a logical path to reach a destination, avoiding obstacles and (optionally) hazardous materials or defined regions.\n\nNavigation visualization\n\nTo assist with pathfinding layout and debugging, Studio can render a navigation mesh and modifier labels. To enable them, toggle on Navigation mesh and Pathfinding modifiers from the Visualization Options widget in the upper‑right corner of the 3D viewport.\n\nWith Navigation mesh enabled, colored areas show where a character might walk or swim, while non-colored areas are blocked. The small arrows indicate areas that a character will attempt to reach by jumping, assuming you set AgentCanJump to true when creating the path.\n\nWith Pathfinding modifiers enabled, text labels indicate specific materials and regions that are taken into consideration when using pathfinding modifiers.\n\nKnown limitations\n\nPathfinding features specific limitations to ensure efficient processing and optimal performance.\n\nVertical placement limit\n\nPathfinding calculations consider only parts within certain vertical boundaries:\n\n- Lower Boundary &mdash; Parts with a bottom Y coordinate less than -65,536 studs are ignored.\n- Upper Boundary &mdash; Parts with a top Y coordinate exceeding 65,536 studs are ignored.\n- Vertical Span &mdash; The vertical distance from the lowest part's bottom Y coordinate to the highest part's top Y coordinate must not exceed 65,536 studs; otherwise, the pathfinding system will ignore those parts during the pathfinding computation.\n\nSearch distance limitation\n\nThe direct line-of-sight distance for pathfinding from the start to the finish point must not exceed 3,000 studs. Exceeding this distance will result in a Enum.PathStatus|NoPath status.\n\nCreate paths\n\nPathfinding is initiated through Class.PathfindingService and its Class.PathfindingService:CreatePath()|CreatePath() function.\n\nlua title=\"LocalScript\" highlight=\"1, 3\"\nlocal PathfindingService = game:GetService(\"PathfindingService\")\n\nlocal path = PathfindingService:CreatePath()\n\nClass.PathfindingService:CreatePath()|CreatePath() accepts an optional table of parameters which fine tune how the character (agent) moves along the path.\n\n\n     Key\n     Description\n     Type\n     Default\n\n\n\n     AgentRadius\n     Agent radius, in studs. Useful for determining the minimum separation from obstacles.\n     integer\n     2\n\n\n     AgentHeight\n     Agent height, in studs. Empty space smaller than this value, like the space under stairs, will be marked as non-traversable.\n     integer\n     5\n\n\n     AgentCanJump\n     Determines whether jumping during pathfinding is allowed.\n     boolean\n     true\n\n\n     AgentCanClimb\n     Determines whether climbing Class.TrussPart|TrussParts during pathfinding is allowed.\n     boolean\n     false\n\n\n     WaypointSpacing\n     Spacing between intermediate waypoints in path. If set to Library.math.huge, there will be no intermediate waypoints.\n     number\n     4\n\n\n     Costs\n     Table of materials or defined Class.PathfindingModifier|PathfindingModifiers and their cost for traversal. Useful for making the agent prefer certain materials/regions over others. See modifiers for details.\n     table\n     nil\n\n\nlua title=\"LocalScript\" highlight=\"3-10\"\nlocal PathfindingService = game:GetService(\"PathfindingService\")\n\nlocal path = PathfindingService:CreatePath({\n\tAgentRadius = 3,\n\tAgentHeight = 6,\n\tAgentCanJump = false,\n\tCosts = {\n\t\tWater = 20\n\t}\n})\n\nNote that the agent can climb Class.TrussPart|TrussParts during pathfinding assuming you set AgentCanClimb to true when creating the path and nothing blocks the agent from the truss climbing path. A climbable path has the Climb label and the cost for a climbable path is 1 by default.\n\nlua title=\"LocalScript - Truss Climbing Path\" highlight=\"6,8\"\nlocal PathfindingService = game:GetService(\"PathfindingService\")\n\nlocal path = PathfindingService:CreatePath({\n\tAgentCanClimb = true,\n\tCosts = {\n\t\tClimb = 2  -- Cost of the climbing path; default is 1\n\t}\n})\n\nMove along paths\n\nThis section uses the following pathfinding script for the player's character. To test while reading:\n\n1. Copy the code into a Class.LocalScript within Class.StarterCharacterScripts.\n1. Set the TESTDESTINATION variable to a Datatype.Vector3 destination in your 3D world that the player character can reach.\n1. Proceed through the following sections to learn about path computation and character movement.\n\nlua title=\"LocalScript - Character Pathfinding\" highlight=\"11\"\nlocal PathfindingService = game:GetService(\"PathfindingService\")\nlocal Players = game:GetService(\"Players\")\nlocal RunService = game:GetService(\"RunService\")\nlocal Workspace = game:GetService(\"Workspace\")\n\nlocal path = PathfindingService:CreatePath()\n\nlocal player = Players.LocalPlayer\nlocal character = player.Character\nlocal humanoid = character:WaitForChild(\"Humanoid\")\n\nlocal TESTDESTINATION = Vector3.new(100, 0, 100)\n\nlocal waypoints\nlocal nextWaypointIndex\nlocal reachedConnection\nlocal blockedConnection\n\nlocal function followPath(destination)\n\t-- Compute the path\n\tlocal success, errorMessage = pcall(function()\n\t\tpath:ComputeAsync(character.PrimaryPart.Position, destination)\n\tend)\n\n\tif success and path.Status == Enum.PathStatus.Success then\n\t\t-- Get the path waypoints\n\t\twaypoints = path:GetWaypoints()\n\n\t\t-- Detect if path becomes blocked\n\t\tblockedConnection = path.Blocked:Connect(function(blockedWaypointIndex)\n\t\t\t-- Check if the obstacle is further down the path\n\t\t\tif blockedWaypointIndex >= nextWaypointIndex then\n\t\t\t\t-- Stop detecting path blockage until path is re-computed\n\t\t\t\tblockedConnection:Disconnect()\n\t\t\t\t-- Call function to re-compute new path\n\t\t\t\tfollowPath(destination)\n\t\t\tend\n\t\tend)\n\n\t\t-- Detect when movement to next waypoint is complete\n\t\tif not reachedConnection then\n\t\t\treachedConnection = humanoid.MoveToFinished:Connect(function(reached)\n\t\t\t\tif reached and nextWaypointIndex\n\nGet waypoints\n\nOnce the Class.Path is computed, it will contain a series of waypoints that trace the path from start to end. These points can be gathered with the Class.Path:GetWaypoints() function.\n\nlua title=\"LocalScript - Character Pathfinding\" highlight=\"13, 24, 26\"\nlocal PathfindingService = game:GetService(\"PathfindingService\")\nlocal Players = game:GetService(\"Players\")\nlocal RunService = game:GetService(\"RunService\")\nlocal Workspace = game:GetService(\"Workspace\")\n\nlocal path = PathfindingService:CreatePath()\n\nlocal player = Players.LocalPlayer\nlocal character = player.Character\nlocal humanoid = character:WaitForChild(\"Humanoid\")\n\nlocal TESTDESTINATION = Vector3.new(100, 0, 100)\n\nlocal waypoints\nlocal nextWaypointIndex\nlocal reachedConnection\nlocal blockedConnection\n\nlocal function followPath(destination)\n\t-- Compute the path\n\tlocal success, errorMessage = pcall(function()\n\t\tpath:ComputeAsync(character.PrimaryPart.Position, destination)\n\tend)\n\n\tif success and path.Status == Enum.PathStatus.Success then\n\t\t-- Get the path waypoints\n\t\twaypoints = path:GetWaypoints()\n\tend\nend\n\nWaypoints indicated across computed path\n\nPath movement\n\nEach waypoint consists of both a position (Datatype.Vector3) and action (Enum.PathWaypointAction|PathWaypointAction). To move a character containing a Class.Humanoid, like a typical Roblox character, the easiest way is to call Class.Humanoid:MoveTo() from waypoint to waypoint, using the Class.Humanoid.MoveToFinished|MoveToFinished event to detect when the character reaches each waypoint.\n\nlua title=\"LocalScript - Character Pathfinding\" highlight=\"40-51, 54-55\"\nlocal PathfindingService = game:GetService(\"PathfindingService\")\nlocal Players = game:GetService(\"Players\")\nlocal RunService = game:GetService(\"RunService\")\nlocal Workspace = game:GetService(\"Workspace\")\n\nlocal path = PathfindingService:CreatePath()\n\nlocal player = Players.LocalPlayer\nlocal character = player.Character\nlocal humanoid = character:WaitForChild(\"Humanoid\")\n\nlocal TESTDESTINATION = Vector3.new(100, 0, 100)\n\nlocal waypoints\nlocal nextWaypointIndex\nlocal reachedConnection\nlocal blockedConnection\n\nlocal function followPath(destination)\n\t-- Compute the path\n\tlocal success, errorMessage = pcall(function()\n\t\tpath:ComputeAsync(character.PrimaryPart.Position, destination)\n\tend)\n\n\tif success and path.Status == Enum.PathStatus.Success then\n\t\t-- Get the path waypoints\n\t\twaypoints = path:GetWaypoints()\n\n\t\t-- Detect if path becomes blocked\n\t\tblockedConnection = path.Blocked:Connect(function(blockedWaypointIndex)\n\t\t\t-- Check if the obstacle is further down the path\n\t\t\tif blockedWaypointIndex >= nextWaypointIndex then\n\t\t\t\t-- Stop detecting path blockage until path is re-computed\n\t\t\t\tblockedConnection:Disconnect()\n\t\t\t\t-- Call function to re-compute new path\n\t\t\t\tfollowPath(destination)\n\t\t\tend\n\t\tend)\n\n\t\t-- Detect when movement to next waypoint is complete\n\t\tif not reachedConnection then\n\t\t\treachedConnection = humanoid.MoveToFinished:Connect(function(reached)\n\t\t\t\tif reached and nextWaypointIndex\n\nHandle blocked paths\n\nMany Roblox worlds are dynamic; parts might move or fall and floors may collapse. This can block a computed path and prevent the character from reaching its destination. To handle this, you can connect the Class.Path.Blocked event and re-compute the path around whatever blocked it.\n\nPaths may also become blocked somewhere behind the agent, such as a pile of rubble falling on a path as the agent runs away, but that doesn't mean the agent should stop moving. The if blockedWaypointIndex >= nextWaypointIndex check makes sure that the path is re-computed only if the blocked waypoint is ahead of the current waypoint.\n\nlua title=\"LocalScript - Character Pathfinding\" highlight=\"16, 29-37\"\nlocal PathfindingService = game:GetService(\"PathfindingService\")\nlocal Players = game:GetService(\"Players\")\nlocal RunService = game:GetService(\"RunService\")\nlocal Workspace = game:GetService(\"Workspace\")\n\nlocal path = PathfindingService:CreatePath()\n\nlocal player = Players.LocalPlayer\nlocal character = player.Character\nlocal humanoid = character:WaitForChild(\"Humanoid\")\n\nlocal TESTDESTINATION = Vector3.new(100, 0, 100)\n\nlocal waypoints\nlocal nextWaypointIndex\nlocal reachedConnection\nlocal blockedConnection\n\nlocal function followPath(destination)\n\t-- Compute the path\n\tlocal success, errorMessage = pcall(function()\n\t\tpath:ComputeAsync(character.PrimaryPart.Position, destination)\n\tend)\n\n\tif success and path.Status == Enum.PathStatus.Success then\n\t\t-- Get the path waypoints\n\t\twaypoints = path:GetWaypoints()\n\n\t\t-- Detect if path becomes blocked\n\t\tblockedConnection = path.Blocked:Connect(function(blockedWaypointIndex)\n\t\t\t-- Check if the obstacle is further down the path\n\t\t\tif blockedWaypointIndex >= nextWaypointIndex then\n\t\t\t\t-- Stop detecting path blockage until path is re-computed\n\t\t\t\tblockedConnection:Disconnect()\n\t\t\t\t-- Call function to re-compute new path\n\t\t\t\tfollowPath(destination)\n\t\t\tend\n\t\tend)\n\tend\nend\n\nCurrently, Class.Model|Models containing a Class.Humanoid instance, including typical player characters, will not be considered for path computation or path blockage, although the agent may still be blocked by those models physically.\n\nPathfinding modifiers\n\nBy default, Class.Path:ComputeAsync() returns the shortest path between the starting point and destination, with the exception that it attempts to avoid jumps. This looks unnatural in some situations &mdash; for instance, a path may go through water rather than over a nearby bridge simply because the path through water is geometrically shorter.\n\nTo optimize pathfinding even further, you can implement pathfinding modifiers to compute smarter paths across various materials, around defined regions, or through obstacles.\n\nSet material costs\n\nWhen working with Class.Terrain and Class.BasePart materials, you can include a Costs table within Class.PathfindingService:CreatePath()|CreatePath() to make certain materials more traversable than others. All materials have a default cost of 1 and any material can be defined as non-traversable by setting its value to Library.math.huge.\n\nKeys in the Costs table should be string names representing Enum.Material names, for example Water for Enum.Material.Water.\n\nlua title=\"LocalScript - Character Pathfinding\" highlight=\"6-10\"\nlocal PathfindingService = game:GetService(\"PathfindingService\")\nlocal Players = game:GetService(\"Players\")\nlocal RunService = game:GetService(\"RunService\")\nlocal Workspace = game:GetService(\"Workspace\")\n\nlocal path = PathfindingService:CreatePath({\n\tCosts = {\n\t\tWater = 20,\n\t\tMud = 5,\n\t\tNeon = math.huge\n\t}\n})\n\nWork with regions\n\nIn some cases, material preference is not enough. For example, you might want characters to avoid a defined region, regardless of the materials underfoot. This can be achieved by adding a Class.PathfindingModifier object to a part.\n\n1. Create an Class.BasePart.Anchored|Anchored part around the dangerous region and set its Class.BasePart.CanCollide|CanCollide property to false.\n\n\n\n1. Insert a Class.PathfindingModifier instance onto the part, locate its Class.PathfindingModifier.Label|Label property, and assign a meaningful name like DangerZone.\n\n\n\n1. Include a Costs table within Class.PathfindingService:CreatePath()|CreatePath() containing a matching key and associated numeric value. A modifier can be defined as non-traversable by setting its value to Library.math.huge.\n\n   lua title=\"LocalScript - Character Pathfinding\" highlight=\"6-8\"\n   local PathfindingService = game:GetService(\"PathfindingService\")\n   local Players = game:GetService(\"Players\")\n   local RunService = game:GetService(\"RunService\")\n   local Workspace = game:GetService(\"Workspace\")\n\n   local path = PathfindingService:CreatePath({\n   \tCosts = {\n   \t\tDangerZone = math.huge\n   \t}\n   })\n\n\n\n\nIgnore obstacles\n\nIn some cases, it's useful to pathfind through solid obstacles as if they didn't exist. This lets you compute a path through specific physical blockers, versus the computation failing outright.\n\n1. Create an Class.BasePart.Anchored|Anchored part around the object and set its Class.BasePart.CanCollide|CanCollide property to false.\n\n\n\n1. Insert a Class.PathfindingModifier instance onto the part and enable its Class.PathfindingModifier.PassThrough|PassThrough property.\n\n\n\n   Now, when a path is computed from the zombie NPC to the player character, the path extends beyond the door and you can prompt the zombie to traverse it. Even if the zombie is unable to open the door, it reacts as if it \"hears\" the character behind the door.\n\n\n\nPathfinding links\n\nSometimes it's necessary to find a path across a space that cannot be normally traversed, such as across a chasm, and perform a custom action to reach the next waypoint. This can be achieved through the Class.PathfindingLink object.\n\nUsing the island example from above, you can make the agent use a boat instead of walking across all of the bridges.\n\nTo create a Class.PathfindingLink using this example:\n\n1.  To assist with visualization and debugging, toggle on Pathfinding links from the Visualization Options widget in the upper‑right corner of the 3D viewport.\n1. Create two Class.Attachment|Attachments, one on the boat's seat and one near the boat's landing point.\n\n\n\n1. Create a Class.PathfindingLink object in the workspace, then assign its Attachment0 and Attachment1 properties to the starting and ending attachments respectively.\n\n\n\n\n\n1. Assign a meaningful name like UseBoat to its Class.PathfindingLink.Label|Label property. This name is used as a flag in the pathfinding script to trigger a custom action when the agent reaches the starting link point.\n\n\n\n1. Include a Costs table within Class.PathfindingService:CreatePath()|CreatePath() containing both a Water key and a custom key matching the Class.PathfindingLink.Label|Label property name. Assign the custom key a lower value than Water.\n\n   lua title=\"LocalScript - Character Pathfinding\" highlight=\"6-9\"\n   local PathfindingService = game:GetService(\"PathfindingService\")\n   local Players = game:GetService(\"Players\")\n   local RunService = game:GetService(\"RunService\")\n   local Workspace = game:GetService(\"Workspace\")\n\n   local path = PathfindingService:CreatePath({\n   \tCosts = {\n   \t\tWater = 20,\n   \t\tUseBoat = 1\n   \t}\n   })\n\n\n1. In the event which fires when a waypoint is reached, add a custom check for the Class.PathfindingLink.Label|Label modifier name and take a different action than Class.Humanoid:MoveTo() &mdash; in this case, calling a function to seat the agent in the boat, move the boat across the water, and continue the agent's path upon arrival at the destination island.\n\n   lua title=\"LocalScript - Character Pathfinding\" highlight=\"52-56, 72\"\n   local PathfindingService = game:GetService(\"PathfindingService\")\n   local Players = game:GetService(\"Players\")\n   local RunService = game:GetService(\"RunService\")\n   local Workspace = game:GetService(\"Workspace\")\n\n   local path = PathfindingService:CreatePath({\n   \tCosts = {\n   \t\tWater = 20,\n   \t\tUseBoat = 1\n   \t}\n   })\n\n   local player = Players.LocalPlayer\n   local character = player.Character\n   local humanoid = character:WaitForChild(\"Humanoid\")\n\n   local TESTDESTINATION = Vector3.new(228.9, 17.8, 292.5)\n\n   local waypoints\n   local nextWaypointIndex\n   local reachedConnection\n   local blockedConnection\n\n   local function followPath(destination)\n   \t-- Compute the path\n   \tlocal success, errorMessage = pcall(function()\n   \t\tpath:ComputeAsync(character.PrimaryPart.Position, destination)\n   \tend)\n\n   \tif success and path.Status == Enum.PathStatus.Success then\n   \t\t-- Get the path waypoints\n   \t\twaypoints = path:GetWaypoints()\n\n   \t\t-- Detect if path becomes blocked\n   \t\tblockedConnection = path.Blocked:Connect(function(blockedWaypointIndex)\n   \t\t\t-- Check if the obstacle is further down the path\n   \t\t\tif blockedWaypointIndex >= nextWaypointIndex then\n   \t\t\t\t-- Stop detecting path blockage until path is re-computed\n   \t\t\t\tblockedConnection:Disconnect()\n   \t\t\t\t-- Call function to re-compute new path\n   \t\t\t\tfollowPath(destination)\n   \t\t\tend\n   \t\tend)\n\n   \t\t-- Detect when movement to next waypoint is complete\n   \t\tif not reachedConnection then\n   \t\t\treachedConnection = humanoid.MoveToFinished:Connect(function(reached)\n   \t\t\t\tif reached and nextWaypointIndex = 94 then\n   \t\t\t\tboatPositionConnection:Disconnect()\n   \t\t\t\tboat.CylindricalConstraint.Velocity = 0\n   \t\t\t\ttask.wait(1)\n   \t\t\t\t-- Unseat agent and continue to destination\n   \t\t\t\thumanoid.Sit = false\n   \t\t\t\thumanoid:MoveTo(waypoints[nextWaypointIndex].Position)\n   \t\t\tend\n   \t\tend)\n   \tend)\n   end\n\n   followPath(TESTDESTINATION)\n\n\n\n\nStreaming compatibility\n\nIn-experience instance streaming is a powerful feature that dynamically loads and unloads 3D content as a player's character moves around the world. As they explore the 3D space, new subsets of the space stream to their device and some of the existing subsets might stream out.\n\nConsider the following best practices for using Class.PathfindingService in streaming-enabled experiences:\n\n- Streaming can block or unblock a given path as a character moves along it. For example, while a character runs through a forest, a tree might stream in somewhere ahead of them and obstruct the path. To make pathfinding work seamlessly with streaming, it's highly recommended that you use the handling blocked paths technique and re-compute the path when necessary.\n\n- A common approach in pathfinding is to use the coordinates of existing objects for computation, such as setting a path destination to the position of an existing TreasureChest model in the world. This approach is fully compatible with server-side Class.Script|Scripts since the server has full view of the world at all times, but Class.LocalScript|LocalScripts and Class.ModuleScript|ModuleScripts that run on the client may fail if they attempt to compute a path to an object that's not streamed in.\n\n  To address this issue, consider setting the destination to the position of a Class.BasePart within a persistent model. Persistent models load soon after the player joins and they never stream out, so a client-side script can connect to the Class.Workspace.PersistentLoaded|PersistentLoaded event and safely access the model for creating waypoints after the event fires.",
    "source": "pathfinding.md"
}