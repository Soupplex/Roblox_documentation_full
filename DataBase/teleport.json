{
    "title": "Teleport between places",
    "description": "Explains how to use TeleportService to teleport users between different places in your experience.",
    "content": "Many experiences are subdivided into multiple places, such as a fantasy world with towns, castles, dungeons, and a vast forest. Use Class.TeleportService to teleport users between places, to different servers, or even to other experiences.\n\nClass.TeleportService doesn't support playtesting in Roblox Studio. You must publish the experience and test in the Roblox client.\n\nTeleport players\n\nTo teleport players, use Class.TeleportService:TeleportAsync(). This method accepts three parameters:\n\n- The Class.DataModel.PlaceId|PlaceId for users to teleport to.\n- An array containing the Class.Player instances you want to teleport.\n- An optional Class.TeleportOptions instance that contains custom properties for the Class.TeleportService:TeleportAsync()|TeleportAsync() call.\n\nlua\nlocal Players = game:GetService(\"Players\")\nlocal TeleportService = game:GetService(\"TeleportService\")\n\nlocal TARGETPLACEID = 12345678901234 -- replace with your own\nlocal playerToTeleport = Players:GetPlayers()[1] -- get the first user in the experience\n\nTeleportService:TeleportAsync(TARGETPLACEID, {playerToTeleport})\n\nTo get the appropriate players to teleport, you might use a Class.BasePart.Touched or a Class.ProximityPrompt.Triggered event to get an individual Class.Player. Then you can check if the player is part of a team (Class.Player.Team) or party (Class.Player.PartyId). Finally, you can use Class.Team:GetPlayers() or Class.SocialService:GetPlayersByPartyId() if you want to teleport the entire group rather than just the individual.\n\nTo reduce client-side exploits, you can only call Class.TeleportService:TeleportAsync()|TeleportAsync() from server scripts. If necessary, client scripts can call Class.TeleportService:Teleport()|Teleport(), but we don't recommend it. For more information, see Configure secure teleportation.\n\nConfigure secure teleportation\n\nThree settings handle teleport security.\n\nSetting | Description\n:--- | :---\n(Creator Dashboard) Experience > Access Settings > Access Control for Places | Controls whether players can join any place in your experience or must first join the start place.\n(Creator Dashboard) Place > Access > Direct Access Control | Overrides your experience-level Access Control for Places setting for a non-start place.\n(Studio) File > Experience Settings > Security > Allow Third Party Teleports | Controls teleports from your experience to experiences that you don't own. You can leave this setting disabled and still teleport players between published experiences you own.\n\nAccess Control for Places controls players teleporting into your experience and is the most critical setting for preventing teleport-based exploits.\n\n!Access control for places on the Creator Hub\n\n- If you choose Fully open, players can join any place in your experience through teleports from any experience, including deep links, game invites, joining a connection, and more.\n\n  This is a good choice if your experience has several places and you want friends to be able to easily join each other no matter which place they're in.\n\n- If you choose Limited to same universe, players can only join non-start places through teleports within your experiences. This setting allows both client- and server-initiated teleports.\n\n  This is a good choice if you have a legacy experience that you don't want to migrate to secure teleports.\n\n- If you choose Secure within universe only, players can only join non-start places through server-initiated teleports within this experience.\n\n  This is a good choice if your experience has a strict progression system before players can access certain areas. It's also a good choice if your experience has a test place that players shouldn't have access to or for places that exclusively use reserved servers.\n\nUltimately, your Access Control for Places setting depends on the type of experience you want to build. Many experiences don't need secure teleports.\n\nMigrate to secure teleports\n\nIf you have an existing experience that uses client-side teleports and want to require server-initiated teleports, the goal is to move all teleport logic out of client scripts and into server scripts:\n\n1. Find all client scripts that call Class.TeleportService:Teleport()|Teleport().\n1. Change these calls to instead fire remote events. Alternatively, you can change the calls to instead use Class.ProximityPrompt|ProximityPrompts, Class.ClickDetector|ClickDetectors, or even just the Class.BasePart.Touched event.\n1. Reimplement the teleport in a server script using Class.TeleportService:TeleportAsync()|TeleportAsync().\n1. When no more Class.TeleportService:Teleport()|Teleport() calls exist, change Access Control for Places to Secure.\n\nCreate custom teleport screens\n\nWhen a user triggers a teleport, they see the standard Roblox loading screen as they wait for the new place to load. If desired, you can add a custom teleport screen by calling Class.TeleportService:SetTeleportGui() on the client.\n\nThe following example sets a customized Class.ScreenGui from Class.ReplicatedStorage. Any scripts within the Class.ScreenGui do not run.\n\nlua\nlocal TeleportService = game:GetService(\"TeleportService\")\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal teleportGui = ReplicatedStorage.TeleportGui\n\nTeleportService:SetTeleportGui(teleportGui)\n\nCustomize teleport options\n\nYou can customize teleportations, such as teleporting users to a specific server and sending user data along with teleports, by setting the Class.TeleportOptions instance and passing it to the Class.TeleportService:TeleportAsync() method.\n\nTeleport to specific servers\n\nTo teleport users to specific servers, set the target server using Class.TeleportOptions and pass it to the Class.TeleportService:TeleportAsync()|TeleportAsync() method. If you don't specify a server, users are teleported into a public server; the information of the first user in the list is used for matchmaking.\n\nTo teleport users to a specific public server, set the Class.TeleportOptions.ServerInstanceId property as a valid instance ID, which is a unique identifier for a public server.\n\nlua\nlocal teleportOptions = Instance.new(\"TeleportOptions\")\nteleportOptions.ServerInstanceId = targetServerId\n\nTo teleport users to a specific reserved server, set a valid Class.TeleportOptions.ReservedServerAccessCode, which is a unique code for entering a reserved server.\n\nlua\nlocal teleportOptions = Instance.new(\"TeleportOptions\")\nteleportOptions.ReservedServerAccessCode = reservedServerCode\n\nTo teleport users to a new reserved server, set Class.TeleportOptions.ShouldReserveServer to true.\n\nlua\nlocal teleportOptions = Instance.new(\"TeleportOptions\")\nteleportOptions.ShouldReserveServer = true\n\nSend user data along with teleports\n\nTeleporting a user between places discards any local data associated with that user. You can use the following approaches to handle data persistence between places:\n\n- If your experience utilizes secure user data like in-experience currency or inventory, implement data stores or memory stores to maintain data from place to place.\n\n- To send basic non-secure data from place to place, call Class.TeleportOptions:SetTeleportData() before passing it to Class.TeleportService:TeleportAsync()|TeleportAsync(). Don't pass secure data using this method; the data is visible to the client and unencrypted.\n\nlua\nlocal teleportData = {\n    randomNumber = RNG:NextInteger(1, 100),\n}\n\nlocal teleportOptions = Instance.new(\"TeleportOptions\")\nteleportOptions:SetTeleportData(teleportData)\n\nTo retrieve all data when a user arrives at the new place after a teleport, use the Class.Player:GetJoinData() function, which returns a dictionary with a TeleportData key.\n\nlua\nlocal Players = game:GetService(\"Players\")\n\nlocal function onPlayerAdded(player)\n    local joinData = player:GetJoinData()\n    local teleportData = joinData.TeleportData\n    local randomNumber = teleportData.randomNumber\n\n    print(player.Name .. \" joined with the number \" .. randomNumber)\nend\n\nPlayers.PlayerAdded:Connect(onPlayerAdded)\n\nTo retrieve only the teleport data on the client, you can use Class.TeleportService:GetLocalPlayerTeleportData().\n\nHandle failed teleports\n\nLike any API call that involves network requests, teleports can fail and throw an error. Wrap them in protected calls (Global.LuaGlobals.pcall()). Some failures benefit from retries, particularly those involving reserved servers, so we recommend retrying some number of times on failure.\n\nEven if a call succeeds and the teleport initiates, it can still fail at the last moment without throwing an error and leave the user in the server. When this happens, it triggers the Class.TeleportService.TeleportInitFailed event.\n\nThe following example Class.ModuleScript returns a single SafeTeleport function that teleports players in a protected call with retry logic. It also has a handleFailedTeleport function to deal with situations in which the call was successful, but the teleport didn't occur.\n\nlua\nlocal TeleportService = game:GetService(\"TeleportService\")\n\nlocal ATTEMPTLIMIT = 5\nlocal RETRYDELAY = 1\nlocal FLOODDELAY = 15\n\nlocal function SafeTeleport(placeId, players, options)\n    local attemptIndex = 0\n    local success, result -- define pcall results outside of loop so results can be reported later on\n\n    repeat\n        success, result = pcall(function()\n            return TeleportService:TeleportAsync(placeId, players, options) -- teleport the user in a protected call to prevent erroring\n        end)\n        attemptIndex += 1\n        if not success then\n            task.wait(RETRYDELAY)\n        end\n    until success or attemptIndex == ATTEMPTLIMIT -- stop trying to teleport if call was successful, or if retry limit has been reached\n\n    if not success then\n        warn(result) -- print the failure reason to output\n    end\n\n    return success, result\nend\n\nlocal function handleFailedTeleport(player, teleportResult, errorMessage, targetPlaceId, teleportOptions)\n    if teleportResult == Enum.TeleportResult.Flooded then\n        task.wait(FLOODDELAY)\n    elseif teleportResult == Enum.TeleportResult.Failure then\n        task.wait(RETRYDELAY)\n    else\n        -- if the teleport is invalid, report the error instead of retrying\n        error((\"Invalid teleport [%s]: %s\"):format(teleportResult.Name, errorMessage))\n    end\n\n    SafeTeleport(targetPlaceId, {player}, teleportOptions)\nend\n\nTeleportService.TeleportInitFailed:Connect(handleFailedTeleport)\n\nreturn SafeTeleport\n\nThe SafeTeleport function receives the same arguments as the Class.TeleportService:TeleportAsync()|TeleportAsync() function. You can use the following script with the SafeTeleport function to perform teleports from anywhere in your experience:\n\nlua\nlocal Players = game:GetService(\"Players\")\nlocal TeleportService = game:GetService(\"TeleportService\")\nlocal ServerScriptService = game:GetService(\"ServerScriptService\")\n\nlocal SafeTeleport = require(ServerScriptService.SafeTeleport)\n\nlocal PLACETOTELEPORTTO = 12345678\n\nlocal function teleport(touchPart)\n    local playerToTeleport = game.Players:GetPlayerFromCharacter(touchPart.Parent)\n\n    if playerToTeleport then\n        SafeTeleport(PLACETOTELEPORTTO, {playerToTeleport})\n    end\nend\n\nscript.Parent.Touched:Connect(teleport)",
    "source": "teleport.md"
}