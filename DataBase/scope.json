{
    "title": "Scope",
    "description": "The scope of a variable or function is the block of code that can access it.",
    "content": "In scripting, a block of code is the body of a control structure or function. The scope of a variable or function is the block of code that can access it, and it can be global or local. All blocks can access global variables and functions. A block can access local variables and functions in its parent block, but not in any of its child blocks.\n\nVariables and functions have global scope by default, but it's almost always better to declare them with local scope because Luau accesses local variables and functions faster than global ones. To give a variable or function local scope, put the keyword local before its name when you declare it.\n\nScripts cannot access global and local variables or functions in other scripts. If you want to share values and functions between scripts, use Class.ModuleScript|ModuleScripts.\n\nlua\nlocal helloWorld = 'Hello World!'\nlocal function printHelloWorld()\n\tprint(helloWorld)\nend\nprintHelloWorld() -- Hello World!\n\n- Block B can access the local variable in block A.\n- Block C can access the local variables and functions in blocks A and B.\n- Block A cannot access the local variables and functions in blocks B or C.\n- Block B cannot access the local variable in block C.\n\nGlobal scope\n\nAfter you declare a global variable or function, any block of code in the same script can access it. Variables and functions have global scope unless you declare them with the local keyword.\n\nIn the following code, testVar has global scope within the local testFunc() function. When Luau calls the testFunc(), it assigns testVar the value 64. The testVar has global scope, so the print() function outside testFunc() can access it and print 64.\n\nlua title = 'Example of global functions and variables'\nlocal function testFunc()  -- local scope\n\ttestVar = 64  -- global scope\nend\n\ntestFunc()\n\nprint(testVar) -- 64\n\nIn the following code, the global variable x starts at 0, increments by 1 with each iteration of the for loop, and prints again afterward with a final value of 4.\n\nlua\nx = 0  -- Global variable \"x\"\n\nfor i = 1, 4 do\n\tx += 1\n\tprint(\"Global 'x' = \" .. x)\nend\n\nprint(\"Global 'x' = \" .. x)\n\n--[[ Resulting output:\nGlobal 'x' = 1\nGlobal 'x' = 2\nGlobal 'x' = 3\nGlobal 'x' = 4\nGlobal 'x' = 4\n]]\n\nIt's easier to declare global variables and functions because you don't need to type as much, but global variables and functions have the following disadvantages compared to local ones:\n\n- Luau accesses global variables and functions with a hash lookup, so it's expensive to use in terms of performance. Using a global variable in a time-critical loop can make it perform more than 10% slower than using a local variable in the same loop.\n- Luau disposes of local variables after their scope ends, reducing memory usage.\n- You can access global variables and functions within the same script, but not between multiple scripts. Therefore, a global variable or function doesn't provide any benefit over an in-scope local equivalent, an upvalue, or a shadow.\n\nLocal scope\n\nLuau can only access a local variable or function in the block of code where you declare it. Creating a variable with local scope gives you tighter control over when and where its value changes.\n\nIn the following code, the testFunc() function and testVar variable have local scope. Only the code within testFunc() can access the testVar variable. The testVar variable doesn't have a value outside testFunc(), so calling print(testVar) within testFunc() prints the value of testVar, but calling print(testVar) outside testFunc() prints nil.\n\nlua\nlocal function testFunc()  -- local scope\n\tlocal testVar = 64  -- local scope\n\tprint(testVar) -- 64\nend\n\ntestFunc()\n\nprint(testVar) -- nil\n\nIn the following code, the local variable x has value 0 at line 1. As Luau iterates through the for loop, a different local variable x has value 1. Then, Luau prints the initial variable x with an unchanged value 0.\n\nlua\nlocal x = 0  -- Local variable \"x\"\n\nfor i = 1, 4 do\n\tlocal x = 1  -- Different variable \"x\", local to this \"for\" loop\n\tprint(\"Loop 'x' = \" .. x)\nend\n\nprint(\"Initial 'x' = \" .. x)\n\n--[[ Resulting output:\nLoop 'x' = 1\nLoop 'x' = 1\nLoop 'x' = 1\nLoop 'x' = 1\nInitial 'x' = 0\n]]\n\nCapture\n\nAfter you declare and assign a local variable, you can read it in its scope level and functions whose scopes is enclosed by the same scope containing the local variable. This technique is known as capturing.\n\nIn the following code, the function f captures the local variable x. The variable x in f() is an upvalue.\n\nlua\nlocal x = 5\n\nlocal function f()\n\tprint(x)\nend\n\nf() -- 5\nprint(x) -- 5\n\nShadow\n\nAfter you declare and assign a local variable, you can read it in its scope level and descendant scope levels. If you redeclare and reassign the variable in a descendant scope level, then you create a new local variable with the same name but different value from the most previous assignment. The new local variable doesn't affect the local variable from the previous assignment. This technique, known as shadowing, helps you reuse the name of a variable without reusing its value.\n\nIn the following code, Luau shadows the variable x. The variable x in f() is a shadow variable.\n\nlua\nlocal x = 5\n\nlocal function f()\n\tlocal x = 7\n\tprint(x)\nend\n\nf() -- 7\nprint(x) -- 5\n\nYou can also redeclare a local variable without assigning a value to it so you can reassign the variable in both its scope level and descendant scope levels. Redeclaring a local variable without assigning a value to it sets its value to nil.\n\nIn the following code, Luau shadows the local variable fruitName in the function getFruitByColor(). The function redeclares fruitName as a new shadow variable and sets its value to nil. The function has a descendant scope level, a for loop, that assigns a value to fruitName. After the for loop, the function returns the fruitName shadow variable. Throughout the entire function, fruitName is the same local variable that doesn't overwrite the initial fruitName local variable.\n\nlua\nlocal fruitName = \"Chocolate\"\nlocal fruitTable = {\n\tLemon = \"Yellow\",\n\tApple = \"Red\",\n\tOrange = \"Orange\"\n}\n\nlocal function getFruitByColor(color)\n\tlocal fruitName\n\tfor key, value in fruitTable do\n\t\tif value == color then\n\t\t\tfruitName = key\n\t\tend\n\tend\n\treturn fruitName\nend\n\nlocal fruit = getFruitByColor(\"Yellow\")\nprint(fruit) -- Lemon\nprint(fruit .. \", not \" .. fruitName) -- Lemon, not Chocolate",
    "source": "scope.md"
}