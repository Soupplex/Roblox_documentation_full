{
    "title": "Stacks",
    "description": "Stacks are data structures that follow the Last in First Out (LIFO) principle.",
    "content": "A stack is a linear data structure with a collection of items that follows the Last-In-First-Out (LIFO) principle. The top of the stack is the item most recently added to the stack, and the bottom of the stack is the item that was least recently added.\n\nYou can think of the stack data structure as a stack of dinner plates: you start with one, and then you put another above it. When you take plates from the stack, the first one you remove from the stack is the last one you put on the top.\n\nStacks have two main operations: push for adding an element to the top of the stack and pop for removing the element from the top of the stack. A Stack can either have a fixed size or be dynamically resized. Stacks are helpful for design usage such as backtracking algorithms.\n\nImplement stacks\n\nThough Luau doesn't have stacks as a built-in data structure, you can use tables to implement stacks. The following code sample shows how to create a stack, push an object to a stack, and pop an object from the stack. To use this implementation for your experience, you should save it as a Class.ModuleScript and store it in Class.ReplicatedStorage, so your stack is accessible for both client and server.\n\nlua Implement a Stack Using Table\nlocal Stack = {}\nStack.index = Stack\n\nfunction Stack.new()\n\tlocal self = setmetatable({}, Stack)\n\n\tself.stack = {}\n\n\treturn self\nend\n\n-- Check if the stack is empty\nfunction Stack:isEmpty()\n\treturn #self.stack == 0\nend\n\n-- Put a new value onto the stack\nfunction Stack:push(value)\n\ttable.insert(self.stack, value)\nend\n\n-- Take a value off the stack\nfunction Stack:pop()\n\tif self:isEmpty() then\n\t\treturn nil\n\tend\n\n\treturn table.remove(self.stack, #self.stack)\nend\n\nreturn Stack\n\nThe following code sample is a usage example as a Class.Script under Class.Workspace. You can modify the code, type, and storage location to fit your own usage, as long as you have the previous implementation code sample properly stored.\n\nlua title=\"Stack Usage Example\"\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Stack = require(ReplicatedStorage:WaitForChild(\"Stack\"))\n\nlocal s = Stack.new()\n\n-- Change the stack \tResulting stack\t\t Output\n\ns:push(1)      \t\t\t-- {1}\n\ns:push(5)      \t\t\t-- {1, 5}\n\ns:push(10)     \t\t\t-- {1, 5, 10}\n\nprint(s:pop()) \t\t\t-- {1, 5}            10\n\nprint(s:pop()) \t\t\t-- {1}               5\n\ns:push(20)     \t\t\t-- {1, 20}\n\nprint(s:pop()) \t\t\t-- {1}               20\n\nprint(s:pop()) \t\t\t-- {}                1\n\nWhen running pop() on a stack, make sure the stack is not empty.\n\nIf you run the previous code sample without changing anything, the expected output is:\n\nlua title=\"Example Output\"\n10\n5\n20\n1",
    "source": "stacks.md"
}