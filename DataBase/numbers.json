{
    "title": "Numbers",
    "description": "A double-precision floating-point number.",
    "content": "The number data type, or double, represents a double-precision (64-bit) floating-point number. Numbers can range from -1.7 \\ 10308 to 1.7 \\ 10308 (around 15 digits of precision, positive or negative).\n\nSigned and unsigned\n\nThe sign of the number indicates whether it's positive or negative. For example, 1 is positive and -1 is negative. In Luau, the number -0 is equivalent to 0.\n\nlua\nprint(0 == -0)  --> true\nprint(-0 > 1)  --> false\nprint(-0  true\nprint(-0 > -1)  --> true\nprint(-0  false\n\nNumber classifications\n\nLuau doesn't distinguish between integers and numbers, but the API reference sometimes distinguishes between them to be more specific about how to use each API.\n\nfloat\n\nThe float number type refers to a real number with a decimal place. In computer science terms, they are single-precision (32-bit) floating-point number, which isn't as precise as double-precision floating-point numbers, but is sufficiently precise for most use cases and requires less memory and storage.\n\nint\n\nThe integer number type, or int, refers to a 32-bit whole number, which ranges from -231 to 231 - 1. Properties and functions that expect integers may automatically round or raise errors when you assign or pass non-integers to them.\n\nint64\n\nThe int64 number type refers to a signed 64-bit integer, which ranges from -263 to 263 - 1. This type of integer is common for methods that use ID numbers from the Roblox website. For example, Class.Player.UserId is an int64, and Class.MarketplaceService:PromptPurchase() and Class.TeleportService:Teleport() each expect int64 for the ID arguments.\n\nNotation\n\nNumbers are notated with the most significant digits first (big-endian). There are multiple ways to notate number literals in Luau:\n\n- Decimal (base-10) — Write the digits of the number normally using digits 0–9 with a single optional decimal point, for example 7, 1.25, or -22.5.\n- Scientific notation — Write a decimal number followed by e or e+, then an integer to raise the decimal number to a power of 10. For instance, 12e3 is 12 × 10^3 (12,000).\n- Hexadecimal (base-16) — Begin the number with 0x followed by digits 0–9 or A–F (capitalization ignored). For example, 0xF is 15 and 0x3FC is 1020.\n- Binary (base-2) — Begin the number with 0b followed by 0s or 1s, for instance 0b1100 (12 in decimal format).\n\nTo aid in the readability of long numbers, you can include underscores anywhere within a number literal without changing the value, except at the beginning where this would make it an identifier. For example, 1234567 is the same as 1234567, both of which are equal to 1,234,567.\n\nOperations\n\nYou can use logical and relational operators to manipulate and compare numbers. You can also use mathematical functions such as Library.math.sqrt() and Library.math.exp() in the Library.math library and bitwise operations in the Library.bit32 library.\n\nType introspection\n\nYou can determine if a value x is a number by using type(x) or typeof(x). Both return the string number if x is a number.\n\nlua\nlocal testInt = 5\nlocal testDecimal = 9.12761656\nlocal testString = \"Hello\"\n\nprint(type(testInt))  --> number\nprint(type(testDecimal))  --> number\nprint(type(testString))  --> string\n\nprint(typeof(testInt))  --> number\nprint(typeof(testDecimal))  --> number\nprint(typeof(testString))  --> string\n\nRound functions\n\nYou can round numbers using Library.math.floor(), Library.math.ceil(), or Library.math.modf(). These functions return an integer result if Luau can represent it as an integer. If the number is too large, Luau returns it as a float.\n\n- To determine if a number x is an integer, use math.floor(x) == x.\n- To round a number down, use Library.math.floor().\n- To round a number up, use Library.math.ceil().\n- To round a number towards zero, use Library.math.modf(). It also returns the fractional difference of the rounded number as a second result.\n\nlua\nprint(math.floor(3.3))  --> 3\nprint(math.floor(-3.3))  --> -4\nprint(math.ceil(3.3))  --> 4\nprint(math.ceil(-3.3))  --> -3\nprint(math.modf(3.3))  --> 3 0.2999999999999998\nprint(math.modf(-3.3))  --> -3 -0.2999999999999998",
    "source": "numbers.md"
}