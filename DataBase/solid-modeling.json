{
    "title": "Solid modeling",
    "description": "Solid modeling is the process of joining parts together to form complex shapes.",
    "content": "Solid modeling is the process of joining parts\ntogether in unique ways to form more complex shapes known as unions or intersections. You can perform four solid modeling operations using the tools within the Model tab toolbar.\n\n\n\n      Tool\n\t    Shortcut\n      Description\n\n\n\n\n      Union\n\t    ShiftCtrlG (Windows)Shift⌘G (Mac)\n      Join two or more parts together to form a single solid union.\n\n\n      Intersect\n\t    ShiftCtrlI (Windows)Shift⌘I (Mac)\n      Intersect overlapping parts into a single solid intersection.\n\n\n      Negate\n\t    ShiftCtrlN (Windows)Shift⌘N (Mac)\n      Negate parts, useful for making holes and indentations.\n\n\n      Separate\n\t    ShiftCtrlU (Windows)Shift⌘U (Mac)\n      Separate the union or intersection back into its individual parts.\n\n\n\nUnion parts\n\nThe Union tool joins two or more parts together to form a single solid Class.UnionOperation. By default, a new union respects the Class.BasePart.Color|Color property of each of its parts, although you can enable its Class.PartOperation.UsePartColor|UsePartColor property to change the entire union to a specific color.\n\n\n\n\n\n\n\n\nTo combine parts together into a union:\n\n1. Select all parts that you want to join together.\n2. Click the Union button. All of the parts combine into one solid Class.UnionOperation with the name Union.\n\nIntersect parts\n\nThe Intersect tool intersects overlapping parts into a single solid Class.IntersectOperation. By default, the face colors of the resulting intersection are borrowed from the Class.BasePart.Color|Color property of the original parts, although you can enable its Class.PartOperation.UsePartColor|UsePartColor property to change the entire intersection to a specific color.\n\n\n\n\n\n\n\n\n\n\n\n\nTo intersect overlapping parts together:\n\n1. Select all parts that you want to intersect.\n2. Click the Intersect button. All of the parts combine into one solid Class.IntersectOperation with the name Intersection.\n\nNegate parts\n\nThe Negate tool negates a part so that when it's unioned with another part, the shape of the negated part is subtracted from the other part.\n\n\n\n\n\n\n\n\n\n\n\n\nTo subtract a part from other overlapping parts:\n\n1. Select the part you want to negate from other parts.\n1. Click Negate. The part becomes a Class.NegateOperation with the name NegativePart and turns pink and translucent to indicate its state.\n1. Select both the negated part and the parts you want to subtract it from.\n1. Click Union. The negated part is cut out from the included overlapping parts.\n\nSeparate unions or intersections\n\nThe Separate tool separates a Class.UnionOperation back into its individual parts, essentially serving as an \"undo\" tool for unions and intersections.\n\nTo separate a union or intersection back into individual parts:\n\n1. Select the union or intersection.\n1. Click Separate. The parts separate back into their original form.\n\nRender fidelity\n\nBy default, new solid modeled operations will always be shown in Enum.RenderFidelity.Automatic|Automatic render fidelity, meaning the part's detail is based on its distance from the camera as outlined in the following table.\n\n\n\n            Distance from camera\n            Render fidelity\n\n\n\n\n            Less than 250 studs\n            Highest\n\n\n            250-500 studs\n            Medium\n\n\n            500 or more studs\n            Lowest\n\n\n\nSmoothing angle\n\nA solid modeled part's Class.PartOperation.SmoothingAngle|SmoothingAngle property smooths angles between adjacent surfaces of the same color or material. A higher value produces a smoother appearance while a lower value produces a rougher appearance with more sharp edges.\n\nWhile a value between 30 and 70 degrees usually produces a good result, values between 90 and 180 are not recommended as they may cause a \"shadowing\" effect on unions and intersections with sharp edges.\n\n\n\n    Class.PartOperation.SmoothingAngle|SmoothingAngle = 0\n\n\n\n    Class.PartOperation.SmoothingAngle|SmoothingAngle = 50\n\n\nIn-experience solid modeling\n\nIn addition to the Union, Intersect, and Negate tools in Studio, you can allow players to use solid modeling operations while inside an experience through Class.BasePart:UnionAsync()|UnionAsync(), Class.BasePart:IntersectAsync()|IntersectAsync(), and Class.BasePart:SubtractAsync()|SubtractAsync(). All of these methods must be called on a Class.BasePart and they all require an array of one or more parts to union with, intersect with, or subtract from the calling part.\n\nIn-experience solid modeling operations are asynchronous, meaning they can impact performance. For best results, you should not perform a large series of Class.BasePart:UnionAsync()|UnionAsync(), Class.BasePart:IntersectAsync()|IntersectAsync(), or Class.BasePart:SubtractAsync()|SubtractAsync() calls in quick succession.\n\nWhen performing a Class.BasePart:UnionAsync()|UnionAsync(), Class.BasePart:IntersectAsync()|IntersectAsync(), or Class.BasePart:SubtractAsync()|SubtractAsync() operation, the following properties from the calling part are applied to the resulting union: Class.BasePart.Color|Color, Class.BasePart.Material|Material, Class.BasePart.MaterialVariant|MaterialVariant, Class.BasePart.Reflectance|Reflectance, Class.BasePart.Transparency|Transparency, Class.BasePart.Anchored|Anchored, Class.BasePart.CanCollide|CanCollide, Class.BasePart.Density|Density, Class.BasePart.Elasticity|Elasticity, Class.BasePart.ElasticityWeight|ElasticityWeight, Class.BasePart.Friction|Friction, and Class.BasePart.FrictionWeight|FrictionWeight.\n\nUnionAsync()\n\nTo demonstrate Class.BasePart:UnionAsync()|UnionAsync(), the following Class.Script uses the Part1 Class.BasePart from the workspace, unions it together with the Part2, Part3, and Part4 Class.BasePart|BaseParts, then parents the resulting Class.UnionOperation to the workspace at the original position of Part1.\n\nlua highlight=\"6\"\nlocal Workspace = game:GetService(\"Workspace\")\n\nlocal mainPart = Workspace.Part1\nlocal otherParts = {Workspace.Part2, Workspace.Part3, Workspace.Part4}\n\n-- Perform union operation\nlocal success, newUnion = pcall(function()\n\treturn mainPart:UnionAsync(otherParts)\nend)\n\n-- If operation succeeds, position it at the same location and parent it to the workspace\nif success and newUnion then\n\tnewUnion.Position = mainPart.Position\n\tnewUnion.Parent = Workspace\nend\n\n-- Destroy original parts which remain intact after operation\nmainPart:Destroy()\nfor , part in otherParts do\n\tpart:Destroy()\nend\n\nIntersectAsync()\n\nTo demonstrate Class.BasePart:IntersectAsync()|IntersectAsync(), the following Class.Script uses the Part1 Class.BasePart from the workspace, intersects it with the Part2 and Part3 Class.BasePart|BaseParts, then parents the resulting Class.IntersectOperation to the workspace at the original position of Part1.\n\nlua highlight=\"6\"\nlocal Workspace = game:GetService(\"Workspace\")\n\nlocal mainPart = Workspace.Part1\nlocal otherParts = {Workspace.Part2, Workspace.Part3}\n\n-- Perform intersect operation\nlocal success, newIntersect = pcall(function()\n\treturn mainPart:IntersectAsync(otherParts)\nend)\n\n-- If operation succeeds, position it at the same location and parent it to the workspace\nif success and newIntersect then\n\tnewIntersect.Position = mainPart.Position\n\tnewIntersect.Parent = Workspace\nend\n\n-- Destroy original parts which remain intact after operation\nmainPart:Destroy()\nfor , part in otherParts do\n\tpart:Destroy()\nend\n\nSubtractAsync()\n\nTo demonstrate Class.BasePart:SubtractAsync()|SubtractAsync(), the following Class.Script uses the Part1 Class.BasePart from the workspace, negates the Part2, Part3, and Part4 Class.BasePart|BaseParts from it, then parents the resulting Class.UnionOperation to the workspace at the original position of Part1.\n\nlua highlight=\"6\"\nlocal Workspace = game:GetService(\"Workspace\")\n\nlocal mainPart = Workspace.Part1\nlocal otherParts = {Workspace.Part2, Workspace.Part3, Workspace.Part4}\n\n-- Perform subtract operation\nlocal success, newSubtract = pcall(function()\n\treturn mainPart:SubtractAsync(otherParts)\nend)\n\n-- If operation succeeds, position it at the same location and parent it to the workspace\nif success and newSubtract then\n\tnewSubtract.Position = mainPart.Position\n\tnewSubtract.Parent = Workspace\nend\n\n-- Destroy original parts which remain intact after operation\nmainPart:Destroy()\nfor , part in otherParts do\n\tpart:Destroy()\nend",
    "source": "solid-modeling.md"
}