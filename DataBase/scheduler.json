{
    "title": "Schedule code",
    "description": "Explains how to schedule code so it executes after a specific action or cycle has completed.",
    "content": "Scheduling code is useful in many situations, such as ensuring code executes after a specific action or cycle has completed, or delaying code for a specific duration of time. You can use the Library.task library to optimize Roblox's task scheduler to manage and schedule code. You can also use a similar library called Library.coroutine to schedule code which has some additional functionality.\n\nCommon methods\n\nThe following are the most common Library.task methods used to schedule code. You should use the task methods over legacy scheduling methods, such as Global.RobloxGlobals.wait(), to ensure that your code runs optimally.\n\nCertain legacy global methods, such as (Global.RobloxGlobals.spawn(), Global.RobloxGlobals.delay(), and Global.RobloxGlobals.wait()) can provide similar code scheduling results but are less optimized and configurable as their Library.task alternatives. If your experience uses these legacy methods, you should use Library.task instead to ensure your experience's code remains efficient and up-to-date.\n\nThe following table lists the relevant legacy global methods and their preferred, more optimized counterparts:\n\n| Legacy global methods                   | Task methods                                       | Additional alternatives                            |\n| :-------------------------------------- | :------------------------------------------------- | :------------------------------------------------- |\n| wait()                                | Library.task.wait()                              | Class.RunService.Heartbeat                       |\n| wait(n)                               | Library.task.wait()\\|task.wait(n)                |                                                    |\n| spawn(f)                              | Library.task.defer()\\|task.defer(f)              | Library.task.delay()\\|task.delay(0, f)           |\n| delay(n, f)                           | Library.task.delay()\\|task.delay(n, f)           |                                                    |\n| spawn(function() f(uv1, ...) end)    | Library.task.defer()\\|task.defer(f, uv1, ...)    | Library.task.delay()\\|task.delay(0, f, uv1, ...) |\n| delay(n, function() f(uv1, ...) end) | Library.task.delay()\\|task.delay(n, f, uv1, ...) |                                                    |\n\ntask.spawn()\n\nLibrary.task.spawn() takes a thread or function and resumes it immediately through the engine's scheduler. Additional arguments are passed to the thread or function being resumed.\n\nThe following code sample is an example of how you can use Library.task.spawn() when calling a function that may yield while iterating over a set of objects:\n\nlua\nlocal function playerAdded(player)\n\tprint(player)\nend\n\nfor , player in Players:GetPlayers() do\n\ttask.spawn(playerAdded, player)\nend\n\ntask.defer()\n\nLibrary.task.defer() takes a thread or function and defers it until the end of the current resume point within the current frame. Additional arguments are passed to the thread or function resuming.\n\nYou should typically use this when you want similar behavior to Library.task.spawn() but don't care about the thread running immediately. The following code sample illustrates how the Global.RobloxGlobals.print() statement for \"A\" will defer until after the Global.RobloxGlobals.print() statement for \"B\" executes:\n\nlua\ntask.defer(print, \"A\")\nprint(\"B\")\n--> B\n--> A\n\nLibrary.task.defer() is an optimized version of Global.RobloxGlobals.spawn() that schedules a thread to resume as soon as possible (but not immediately) without any throttling.\n\ntask.delay()\n\nLibrary.task.delay() takes a thread or function and schedules it for resumption after the given amount of time elapses on the next Class.RunService.Heartbeat|Heartbeat step. The thread resumes with built-in error handling and support for other engine features. Any additional arguments are passed to the thread or function resuming.\n\nSince the actual delay time may vary, the following code sample illustrates how you can calculate it by passing the current time as an argument:\n\nlua\ntask.delay(2, function(scheduledTime)\n\tprint(os.clock() - scheduledTime) --> 2.038702\nend, os.clock())\n\nA duration of zero will result in the thread or function resuming on the next step.\n\nLibrary.task.delay() is an optimized version of Global.RobloxGlobals.delay() that schedules a thread to resume after some time elapses without throttling.\n\ntask.wait()\n\nLibrary.task.wait() yields the current thread until the given duration (in seconds) elapses and then resumes the thread on the next Class.RunService.Heartbeat|Heartbeat step.\n\nThe actual yield time may vary. The following code sample illustrates how this method returns it for convenience:\n\nSince the actual delay time may vary, the following code sample illustrates how you can get the actual time by storing the method's return value:\n\nlua\nlocal elapsedTime = task.wait(2) -- Wait for 2 seconds\nprint(elapsedTime) --> 2.0792941\n\nIf no duration is given the duration will default to zero meaning the thread will automatically resume on the next step. This means Library.task.wait() is equivalent in behavior to Class.RunService.Heartbeat.\n\nLibrary.task.wait() is an optimized version of Global.RobloxGlobals.wait() that schedules the current thread to resume after some time elapses without throttling.",
    "source": "scheduler.md"
}