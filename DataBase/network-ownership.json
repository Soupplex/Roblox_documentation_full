{
    "title": "Network ownership",
    "description": "Learn how the Roblox Engine utilizes network ownership to improve physical responsiveness for players.",
    "content": "In order to support complex physical mechanisms while also aiming for a smooth and responsive experience for players, the Roblox physics engine utilizes a distributed physics system in which computations are distributed between the server and all connected clients. Within this system, the engine assigns network ownership of physically simulated Class.BasePart|BaseParts to either a client or server to divide the work of calculating physics.\n\nClients experience more responsive physics interactions with parts that they own, since there's no latency from communication with the server. Network ownership also improves server performance because physics computations can be split up among individual clients, allowing the server to prioritize other tasks.\n\nBasePart ownership\n\nBy default, the server retains ownership of any Class.BasePart. Additionally, the server always owns anchored Class.BasePart|BaseParts and you cannot manually change their ownership.\n\nBased on a client's hardware capacity and the player's Class.Player.Character proximity to an unanchored Class.BasePart, the engine automatically assigns ownership of that part to the client. Thus, parts close to a player's character are more likely to become player-owned.\n\nAssembly ownership\n\nIf a physics-based mechanism has no anchored parts, setting ownership on an assembly within that mechanism sets the same ownership for every assembly in the mechanism.\n\nIf you anchor a lone assembly that is not part of a broader mechanism, its ownership goes to the server, since the server always owns anchored Class.BasePart|BaseParts. Upon unanchoring the same assembly, its previous ownership state is lost and it reverts to automatic handling by the engine.\n\nIf you anchor one assembly within a broader mechanism of assemblies, its ownership goes to the server, but ownership of the other assemblies remains unchanged. Unanchoring the same assembly reverts its previously set ownership.\n\nSetting ownership\n\nIn experiences with complex physics interactions or in cases where you need to assign direct control, you can set ownership through a server-side call to Class.BasePart:SetNetworkOwner().\n\nWhile you can manually call Class.BasePart:SetNetworkOwner()|SetNetworkOwner(nil) for the server for gameplay-critical objects that the client should not be able to manipulate, you should do so conservatively since it may result in  jittery physics interactions for clients.\nAlso note that the server always owns anchored Class.BasePart|BaseParts and you cannot manually change their ownership.\n\nConsider a vehicle that has a Class.VehicleSeat object for the driver and a Class.Seat object for a passenger, with both included in the vehicle assembly. With the default ownership rules, if a player character sits in the Class.Seat (passenger) and then another player jumps into the Class.VehicleSeat (driver), the passenger gains physical ownership of the entire vehicle because they entered first. The driver will have to wait several network cycles before their input is recognized and the vehicle will feel less responsive.\n\nThe following Class.Script fixes this by manually assigning network ownership to the driver. In it, the Class.VehicleSeat sets its Class.VehicleSeat.Occupant|Occupant to the Class.Humanoid sitting on it, so the script listens for the seat's Class.Instance.Changed|Changed event to catch when a player sits in the seat. When the driver leaves the seat, the vehicle's network ownership is reverted to automatic with Class.BasePart:SetNetworkOwnershipAuto().\n\nlua\nlocal Players = game:GetService(\"Players\")\n\nlocal vehicleSeat = script.Parent\n\nvehicleSeat.Changed:Connect(function(prop)\n\tif prop == \"Occupant\" then\n\t\tlocal humanoid = vehicleSeat.Occupant\n\t\tif humanoid then\n\t\t\t-- Get the player from the character\n\t\t\tlocal player = Players:GetPlayerFromCharacter(humanoid.Parent)\n\t\t\tif player then\n\t\t\t\tvehicleSeat:SetNetworkOwner(player)\n\t\t\tend\n\t\telse\n\t\t\t-- Reset ownership when seat is unoccupied\n\t\t\tvehicleSeat:SetNetworkOwnershipAuto()\n\t\tend\n\tend\nend)\n\nFor smooth performance and responsive behavior, ensure you also assign ownership of any loose Class.BasePart|BaseParts on top of a vehicle to the same client that controls the vehicle.\n\nVisualizing ownership\n\nTo assist with network ownership debugging, Studio can render colored outlines around objects when playtesting.\n\n\n\t\tOutline color\n\t\tDescription\n\n\n\n\n\t\t(green)\n\t\tYour client owns the part and is simulating it.\n\n\n\n\t\t(red)\n\t\tThe part is within a \"buffer zone\" where your client is simulating it but it's still owned by something else. Your client might get ownership after this, or it may reject.\n\n\n\n\t\t(white/grey)\n\t\tServer or another client owns the part through either automatic network ownership or from explicit assignment through Class.BasePart:SetNetworkOwner()|part:SetNetworkOwner().\n\n\n\n\t\t(black)\n\t\tThe part is owned by neither the server nor the client. Physics will not apply to this part.\n\n\nNote that in a multi-client simulation, each client is assigned a unique color to indicate their ownership; this is mirrored in the Server view, helping you determine which client owns which part(s) at any given time.\n\nTo enable network ownership visualization:\n\n1. Click on the visualization options button in the upper-right corner of the 3D viewport.\n\n\n\n2. In the dropdown menu, toggle on Network owners.\n\nSecurity concerns\n\nRoblox cannot verify physics calculations when a client has ownership over a Class.BasePart. Clients can exploit this and send bad data to the server, such as teleporting the Class.BasePart, making it go through walls or fly around.\n\nAdditionally, Class.BasePart.Touched events are tied to network ownership, meaning that a client can fire Class.BasePart.Touched|Touched events on a Class.BasePart it owns and send it to the server, even if the server doesn't see it touch anything. For example, a client can make a sword deal damage to another player across the map by firing the event through script injections, so it's important to check the validity of such events fired by clients.\n\nSee Security Tactics and Cheat Mitigation for detailed security tactics and cheat mitigation tactics for Roblox experiences.",
    "source": "network-ownership.md"
}