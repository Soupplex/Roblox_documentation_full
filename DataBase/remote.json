{
    "title": "Remote events and callbacks",
    "description": "Remote network events and callbacks allow for back-and-forth communication across the client-server boundary.",
    "content": "Roblox experiences are multiplayer by default, so all experiences inherently communicate between the server and the players' connected clients. In the simplest case, as players move their characters, certain Class.Humanoid properties, such as states, are communicated to the server, which passes this information to other connected clients.\n\nRemote events and callbacks let you communicate across the client-server boundary:\n\n- Class.RemoteEvent|RemoteEvents enable one-way communication (sending a request and not yielding for a response).\n- Class.UnreliableRemoteEvent|UnreliableRemoteEvents enable one-way communication for data that changes continuously or isn't critical to the experience's state. These events trade ordering and reliability for improved network performance.\n- Class.RemoteFunction|RemoteFunctions enable two-way communication (sending a request and yielding until a response is received from the recipient).\n\nUnlike bindable events, which have more limited utility, the use cases for remote events and functions are too numerous to list:\n\n- Gameplay - Basic gameplay, such as a player reaching the end of a level, can require a remote event. A client script notifies the server, and server scripts reset the player's position.\n- Server verification - If a player tries to drink a potion, do they actually have that potion? To ensure fairness, the server has to be the source of truth for an experience. A client script can use a remote event to notify the server that the player is drinking a potion, and then server scripts can decide whether the player actually has that potion and whether to confer any benefits.\n- User interface updates - As the experience's state changes, server scripts can use remote events to notify clients of changes to scores, objectives, etc.\n- In-experience Marketplace purchases - For an example implementation that uses remote functions, see Prompt subscription purchases.\n\nQuick reference\n\nThe following tables serve as a quick reference for how to use Class.RemoteEvent|RemoteEvents and Class.RemoteFunction|RemoteFunctions to communicate between the client and server.\n\n  Client &rarr; Server\n\n\n    Client\n    RemoteEvent:FireServer(args)\n\n\n    Server\n    RemoteEvent.OnServerEvent:Connect(function(player, args))\n\n\n  Server &rarr; Client\n\n\n    Server\n    RemoteEvent:FireClient(player, args)\n\n\n    Client\n    RemoteEvent.OnClientEvent:Connect(function(args))\n\n\n  Server &rarr; All Clients\n\n\n    Server\n    RemoteEvent:FireAllClients(args)\n\n\n    Client\n    RemoteEvent.OnClientEvent:Connect(function(args))\n\n\n  Client &rarr; Server &rarr; Client\n\n\n    Client\n    serverResponse = RemoteFunction:InvokeServer(args)\n\n\n    Server\n    RemoteFunction.OnServerInvoke = function(player, args)\n\n\n  Server &rarr; Client &rarr; Server\n\n\n    See risks.\n\n\nRemote events\n\nA Class.RemoteEvent object facilitates asynchronous, one-way communication across the client-server boundary without yielding for a response.\n\nTo create a new Class.RemoteEvent via the Explorer window in Studio:\n\n1. Hover over the container into which you want to insert the Class.RemoteEvent. In order to ensure both server and client access, it must be in a place where both sides can see it, such as Class.ReplicatedStorage, although in some cases it's appropriate to store it in Class.Workspace or inside a Class.Tool.\n1. Click the &CirclePlus; button that appears to the right of the container's name and insert a RemoteEvent instance.\n1. Rename the instance to describe its purpose.\n\nOnce you've created a Class.RemoteEvent, it can facilitate one-way communication from client to server, from server to client, or from the server to all clients.\n\n\n\n\n    Client &rarr; Server\n\n\n\n\n\n    Server &rarr; Client\n\n\n\n\n\n    Server &rarr; All Clients\n\n\n\nClients cannot communicate directly with other clients, although you can effectively dispatch an event from one client to another by using the Class.RemoteEvent:FireServer() method, then calling Class.RemoteEvent:FireClient()|FireClient() or Class.RemoteEvent:FireAllClients()|FireAllClients() in the event handler for Class.RemoteEvent.OnServerEvent|OnServerEvent.\n\nClient → server\n\nYou can use a Class.LocalScript to trigger an event on the server by calling the Class.RemoteEvent:FireServer()|FireServer() method on a Class.RemoteEvent. If you pass arguments to Class.RemoteEvent:FireServer()|FireServer(), they pass to the event handler on the server with certain limitations. Note that the first parameter of the event handler on the server is always the Class.Player object of the client that calls it, and additional parameters follow.\n\n\n    Client\n    RemoteEvent:FireServer(args)\n\n\n    Server\n    RemoteEvent.OnServerEvent:Connect(function(player, args))\n\n\nThe following Class.Script connects an event handler to Class.RemoteEvent.OnServerEvent|OnServerEvent that creates a new Class.Part on the server. The accompanying Class.LocalScript then calls Class.RemoteEvent:FireServer()|FireServer() on the Class.RemoteEvent instance with the desired Class.BasePart.Color|Color and Class.BasePart.Position|Position for the part.\n\nlua title=\"Event Connection - Script\"\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Workspace = game:GetService(\"Workspace\")\n\n-- Get reference to remote event instance\nlocal remoteEvent = ReplicatedStorage:FindFirstChildOfClass(\"RemoteEvent\")\n\nlocal function onCreatePart(player, partColor, partPosition)\n\tprint(player.Name .. \" fired the RemoteEvent\")\n\tlocal newPart = Instance.new(\"Part\")\n\tnewPart.Color = partColor\n\tnewPart.Position = partPosition\n\tnewPart.Parent = Workspace\nend\n\n-- Connect function to event\nremoteEvent.OnServerEvent:Connect(onCreatePart)\n\nlua title=\"Event Firing - LocalScript\"\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\n-- Get reference to remote event instance\nlocal remoteEvent = ReplicatedStorage:FindFirstChildOfClass(\"RemoteEvent\")\n\n-- Fire the remote event and pass additional arguments\nremoteEvent:FireServer(Color3.fromRGB(255, 0, 0), Vector3.new(0, 25, -20))\n\nServer → client\n\nYou can use a Class.Script to trigger an event on a client by calling the Class.RemoteEvent:FireClient()|FireClient() method on a Class.RemoteEvent. The first argument for Class.RemoteEvent:FireClient()|FireClient() is the Class.Player object of the client that you want to respond to the event, and additional arguments pass to the client with certain limitations. Note that the event handler doesn't need to include the Class.Player object as its first argument because you can determine the player on the client with Class.Players.LocalPlayer.\n\n\n    Server\n    RemoteEvent:FireClient(player, args)\n\n\n    Client\n    RemoteEvent.OnClientEvent:Connect(function(args))\n\n\nThe following Class.LocalScript connects an event handler to the Class.RemoteEvent.OnClientEvent|OnClientEvent event. The accompanying Class.Script then listens for incoming players to the server and calls Class.RemoteEvent:FireClient()|FireClient() for each with arbitrary data.\n\nlua title=\"Event Connection - LocalScript\"\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Players = game:GetService(\"Players\")\n\n-- Get reference to remote event instance\nlocal remoteEvent = ReplicatedStorage:FindFirstChildOfClass(\"RemoteEvent\")\n\nlocal player = Players.LocalPlayer\n\nlocal function onNotifyPlayer(maxPlayers, respawnTime)\n   print(\"[Client] Event received by player\", player.Name)\n   print(maxPlayers, respawnTime)\nend\n\n-- Connect function to event\nremoteEvent.OnClientEvent:Connect(onNotifyPlayer)\n\nlua title=\"Event Firing - Script\"\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Players = game:GetService(\"Players\")\n\n-- Get reference to remote event instance\nlocal remoteEvent = ReplicatedStorage:FindFirstChildOfClass(\"RemoteEvent\")\n\n-- Listen for incoming players and dispatch remote event to each\nlocal function onPlayerAdded(player)\n   print(\"[Server] Firing event to player\", player.Name)\n   remoteEvent:FireClient(player, Players.MaxPlayers, Players.RespawnTime)\nend\nPlayers.PlayerAdded:Connect(onPlayerAdded)\n\nServer → all clients\n\nYou can use a Class.Script to trigger an event on all clients by calling the Class.RemoteEvent:FireAllClients()|FireAllClients() method on a Class.RemoteEvent. Unlike Class.RemoteEvent:FireClient()|FireClient(), the Class.RemoteEvent:FireAllClients()|FireAllClients() method doesn't require a Class.Player object because it fires the Class.RemoteEvent to all clients.\n\n\n    Server\n    RemoteEvent:FireAllClients(args)\n\n\n    Client\n    RemoteEvent.OnClientEvent:Connect(function(args))\n\n\nThe following Class.LocalScript connects an event handler to the Class.RemoteEvent.OnClientEvent|OnClientEvent event which outputs a remaining countdown time. The accompanying Class.Script then calls Class.RemoteEvent:FireAllClients()|FireAllClients() in a loop every second to fire the Class.RemoteEvent for all clients.\n\nlua title=\"Event Connection - LocalScript\"\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\n-- Get reference to remote event instance\nlocal remoteEvent = ReplicatedStorage:FindFirstChildOfClass(\"RemoteEvent\")\n\nlocal function onTimerUpdate(seconds)\n\tprint(seconds)\nend\n\n-- Connect function to event\nremoteEvent.OnClientEvent:Connect(onTimerUpdate)\n\nlua title=\"Event Firing - Script\"\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\n-- Get reference to remote event instance\nlocal remoteEvent = ReplicatedStorage:FindFirstChildOfClass(\"RemoteEvent\")\n\nlocal countdown = 5\n\n-- Fire the RemoteEvent every second until time expires\nfor timeRemaining = -1, countdown do\n\tremoteEvent:FireAllClients(countdown - timeRemaining)\n\ttask.wait(1)\nend\n\nRemote callbacks\n\nA Class.RemoteFunction object facilitates synchronous, two-way communication across the client-server boundary. The sender of a remote function will yield until it receives a response from the recipient.\n\nTo create a new Class.RemoteFunction via the Explorer window in Studio:\n\n1. Hover over the container into which you want to insert the Class.RemoteFunction. In order to ensure both server and client access, it must be in a place where both sides can see it, such as Class.ReplicatedStorage, although in some cases it's appropriate to store it in Class.Workspace or inside a Class.Tool.\n1. Click the &CirclePlus; button that appears to the right of the container's name and insert a RemoteFunction instance.\n1. Rename the instance to describe its purpose.\n\nOnce you've created a Class.RemoteFunction, it can facilitate two-way communication between client and server or between server and client.\n\n\n\n\n    Client &rarr; Server &rarr; Client\n\n\n\n\n\n    Server &rarr; Client &rarr; Server\n\n\n\nClient → server → client\n\nYou can use a Class.LocalScript to call a function on the server by calling the Class.RemoteFunction:InvokeServer()|InvokeServer() method on a Class.RemoteFunction. Unlike a remote event, the Class.LocalScript that invokes the Class.RemoteFunction yields until the callback returns. Arguments that you pass to Class.RemoteFunction:InvokeServer()|InvokeServer() pass to the Class.RemoteFunction.OnServerInvoke|OnServerInvoke callback of the Class.RemoteFunction with certain limitations. Note that if you define multiple callbacks to the same Class.RemoteFunction, only the last definition executes.\n\n\n    Client\n    RemoteFunction:InvokeServer(args)\n\n\n    Server\n    RemoteFunction.OnServerInvoke = function(player, args)\n\n\nThe following Class.Script defines the callback function via Class.RemoteFunction.OnServerInvoke|OnServerInvoke and returns the requested Class.Part through its return value. The accompanying Class.LocalScript then calls Class.RemoteFunction:InvokeServer()|InvokeServer() with extra arguments defining the requested part color and position.\n\nlua title=\"Callback Connection - Script\"\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Workspace = game:GetService(\"Workspace\")\n\n-- Get reference to remote function instance\nlocal remoteFunction = ReplicatedStorage:FindFirstChildOfClass(\"RemoteFunction\")\n\n-- Callback function\nlocal function createPart(player, partColor, partPosition)\n\tprint(player.Name .. \" requested a new part\")\n\tlocal newPart = Instance.new(\"Part\")\n\tnewPart.Color = partColor\n\tnewPart.Position = partPosition\n\tnewPart.Parent = Workspace\n\treturn newPart\nend\n\n-- Set function as remote function's callback\nremoteFunction.OnServerInvoke = createPart\n\nlua title=\"Event Invocation - LocalScript\"\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\n-- Get reference to remote function instance\nlocal remoteFunction = ReplicatedStorage:FindFirstChildOfClass(\"RemoteFunction\")\n\n-- Pass a color and position when invoking the callback\nlocal newPart = remoteFunction:InvokeServer(Color3.fromRGB(255, 0, 0), Vector3.new(0, 25, -20))\n\n-- Output the returned part reference\nprint(\"The server created the requested part:\", newPart)\n\nServer → client → server\n\nYou can use a Class.Script to call a function on the client by calling the Class.RemoteFunction:InvokeClient()|InvokeClient() method on a Class.RemoteFunction, but it has serious risks as follows:\n\n- If the client throws an error, the server throws the error too.\n- If the client disconnects while it's being invoked, Class.RemoteFunction:InvokeClient()|InvokeClient() throws an error.\n- If the client doesn't return a value, the server yields forever.\n\nFor actions that don't require two-way communications, such as updating a GUI, use a Class.RemoteEvent and communicate from server to client.\n\nArgument limitations\n\nWhen you fire a Class.RemoteEvent or invoke a Class.RemoteFunction, it forwards any arguments that you pass with the event or to the callback function. Any type of Roblox object such as an Datatype.Enum, Class.Instance, or others can be passed, as well as Luau types such as numbers, strings, and booleans, although you should carefully explore the following limitations.\n\nNon-string indices\n\nIf any indices of a passed table are non-string types such as an Class.Instance, userdata, or function, Roblox automatically converts those indices to strings.\n\nlua title=\"Event Connection - LocalScript\"\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal remoteEvent = ReplicatedStorage:FindFirstChildOfClass(\"RemoteEvent\")\n\nlocal function onEventFire(passedTable)\n\tfor k, v in passedTable do\n\t\tprint(typeof(k))  --> string\n\tend\nend\n\n-- Connect function to event\nremoteEvent.OnClientEvent:Connect(onEventFire)\n\nlua title=\"Event Firing - Script\"\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Players = game:GetService(\"Players\")\nlocal Workspace = game:GetService(\"Workspace\")\n\nlocal remoteEvent = ReplicatedStorage:FindFirstChildOfClass(\"RemoteEvent\")\n\n-- Listen for incoming players and dispatch remote event to each\nlocal function onPlayerAdded(player)\n\tremoteEvent:FireClient(player,\n\t\t{\n\t\t\t[Workspace.Baseplate] = true\n\t\t}\n\t)\nend\nPlayers.PlayerAdded:Connect(onPlayerAdded)\n\nPassed functions\n\nFunctions included as arguments for a Class.RemoteEvent or Class.RemoteFunction will not be replicated across the client-server boundary, making it impossible to pass functions remotely. Instead, the resulting argument on the receiving side will be nil.\n\nlua title=\"Event Connection - LocalScript\"\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal remoteEvent = ReplicatedStorage:FindFirstChildOfClass(\"RemoteEvent\")\n\nlocal function onClientEvent(func)\n\tprint(func)  --> nil\nend\n\nremoteEvent.OnClientEvent:Connect(onClientEvent)\n\nlua title=\"Event Firing - Script\"\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal remoteEvent = ReplicatedStorage:FindFirstChildOfClass(\"RemoteEvent\")\n\nlocal function testFunction()\n\tprint(\"Hello world!\")\nend\n\n-- Fire remote event with function as an argument\nremoteEvent:FireAllClients(testFunction)\n\nTable indexing\n\nIf you pass a table of data, do not pass a mixed table of numeric and string keys. Instead, pass a table that consists entirely of key-value pairs (dictionary) or entirely of numeric indices.\n\nWhether passing a dictionary table or a numerically indexed table, avoid nil values for any index.\n\nlua title=\"Event Connection - Script\"\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal remoteEvent = ReplicatedStorage:FindFirstChildOfClass(\"RemoteEvent\")\n\nlocal function onEventFire(player, passedTable)\n\tfor k, v in passedTable do\n\t\tprint(k .. \" = \" .. v)\n\t\t--> 1 = Sword\n\t\t--> 2 = Bow\n\t\t--> CharName = Diva Dragonslayer\n\t\t--> CharClass = Rogue\n\tend\nend\n\n-- Connect function to event\nremoteEvent.OnServerEvent:Connect(onEventFire)\n\nlua title=\"Event Firing - LocalScript\"\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal remoteEvent = ReplicatedStorage:FindFirstChildOfClass(\"RemoteEvent\")\n\n-- Numerically indexed table\nlocal inventoryData = {\n\t\"Sword\", \"Bow\"\n}\n-- Dictionary table\nlocal characterData = {\n\tCharName = \"Diva Dragonslayer\",\n\tCharClass = \"Rogue\"\n}\n\nremoteEvent:FireServer(inventoryData)\nremoteEvent:FireServer(characterData)\n\nTable identities\n\nTables passed as arguments to remote events/callbacks are copied, meaning they will not be exactly equivalent to those provided when firing the event or invoking the callback. Nor will tables returned to the invoker be exactly equivalent to those provided. You can demonstrate this by running the following script on a Class.RemoteFunction and observing how the table identities differ.\n\nlua title=\"Callback Connection - Script\"\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal remoteFunction = ReplicatedStorage:FindFirstChildOfClass(\"RemoteFunction\")\n\n-- Callback function\nlocal function returnTable(player, passedTable)\n\t-- Output table identity on invocation\n\tprint(tostring(passedTable))  --> table: 0x48eb7aead27563d9\n\treturn passedTable\nend\n\n-- Set function as remote function's callback\nremoteFunction.OnServerInvoke = returnTable\n\nlua title=\"Event Invocation - LocalScript\"\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal remoteFunction = ReplicatedStorage:FindFirstChildOfClass(\"RemoteFunction\")\n\nlocal inventoryData = {\n\t\"Sword\", \"Bow\"\n}\n-- Output original table identity\nprint(tostring(inventoryData))  --> table: 0x059bcdbb2b576549\n\nlocal invokeReturn = remoteFunction:InvokeServer(inventoryData)\n\n-- Output table identity upon return\nprint(tostring(invokeReturn))  --> table: 0x9fcae7919563a0e9\n\nMetatables\n\nIf a table has a metatable, all of the metatable information is lost in the transfer. In the following code sample, the NumWheels property is part of the Car metatable. When the server receives the following table, the truck table has the Name property but not the NumWheels property.\n\nlua title=\"Event Connection - Script\"\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal remoteEvent = ReplicatedStorage:FindFirstChildOfClass(\"RemoteEvent\")\n\nlocal function onEvent(player, param)\n\tprint(param)  --> {[\"Name\"] = \"MyTruck\"}\nend\n\n-- Connect function to event\nremoteEvent.OnServerEvent:Connect(onEvent)\n\nlua title=\"Event Firing - LocalScript\"\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal remoteEvent = ReplicatedStorage:FindFirstChildOfClass(\"RemoteEvent\")\n\nlocal Car = {}\nCar.NumWheels = 4\nCar.index = Car\n\nlocal truck = {}\ntruck.Name = \"MyTruck\"\nsetmetatable(truck, Car)\n\n-- Fire event with table including a metatable\nremoteEvent:FireServer(truck)\n\nNon-replicated instances\n\nIf a Class.RemoteEvent or Class.RemoteFunction passes a value that's only visible to the sender, Roblox doesn't replicate it across the client-server boundary and passes nil instead of the value. For example, if a Class.Script passes a descendant of Class.ServerStorage, the client listening to the event will receive a nil value because that object isn't replicable for the client.\n\nlua title=\"Event Firing - Script\"\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal ServerStorage = game:GetService(\"ServerStorage\")\nlocal Players = game:GetService(\"Players\")\n\nlocal remoteEvent = ReplicatedStorage:FindFirstChildOfClass(\"RemoteEvent\")\n\n-- Will be received as \"nil\" because client can't access ServerStorage\nlocal storedPart = Instance.new(\"Part\")\nstoredPart.Parent = ServerStorage\n\nlocal function onPlayerAdded(player)\n\tremoteEvent:FireClient(player, storedPart)\nend\nPlayers.PlayerAdded:Connect(onPlayerAdded)\n\nSimilarly, if you create a part in a Class.LocalScript and try to pass it to a Class.Script, the server will see nil because the part isn't replicable for the server.\n\nlua title=\"Event Firing - LocalScript\"\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Workspace = game:GetService(\"Workspace\")\n\nlocal remoteEvent = ReplicatedStorage:FindFirstChildOfClass(\"RemoteEvent\")\n\n-- Will be received as \"nil\" because the server doesn't know about this part\nlocal clientPart = Instance.new(\"Part\")\nclientPart.Parent = Workspace\n\nremoteEvent:FireServer(clientPart)",
    "source": "remote.md"
}