{
    "title": "SharedTable",
    "description": "",
    "content": "This file is automatically generated. Please don't edit it manually.\nTo submit a bug report on the content, see\nhttps://devforum.roblox.com/c/bug-reports/documentation-issues/72\n\nname: SharedTable\ntype: datatype\nsummary: |\n  Provides sharable, table-like storage for key/value pairs.\ndescription: |\n  Represents a table-like data structure that can be shared across execution\n  contexts. While it can be used for various sorts of general data storage, it\n  is designed especially for use with\n  Parallel Luau, where it can be used to\n  share state across scripts parented under different Class.Actor instances.\n\n  There are a couple idiomatic ways to communicate shared tables between\n  scripts. One method is to store and retrieve Datatype.SharedTable objects in\n  the Class.SharedTableRegistry. The registry lets any script in the same data\n  model get or set a Datatype.SharedTable by name. Another method is to use\n  Class.Actor:SendMessage() to send a shared table to another Class.Actor\n  inside a message.\n\n  Like a Luau table, a Datatype.SharedTable object stores a set of key-value\n  element pairs. Unlike a Luau table, only selected types of objects may be\n  stored in a SharedTable, similar to other restrictions you'll find elsewhere\n  in the Roblox Engine.\n\n  Keys must either be (1) a string or (2) a nonnegative integer number less than\n  232. Other kinds of keys are not supported.\n\n  Values must have one of the following types: Boolean, Number, Vector, String,\n  Datatype.SharedTable, or a serializable data type. The ability to store a\n  Datatype.SharedTable as a value in another Datatype.SharedTable permits\n  the construction of nested and recursive data structures.\n\n  Datatype.SharedTable objects are distinct and different\n  Datatype.SharedTable objects never compare equal, even if they have contents\n  that would compare equal.\n\n  Like a Luau table, a Datatype.SharedTable object may be frozen, in which\n  case it is read-only. An attempt to modify a frozen Datatype.SharedTable\n  will raise an error. A frozen Datatype.SharedTable can be created by first\n  creating a (non-frozen, modifiable) Datatype.SharedTable with the desired\n  contents, and then calling Datatype.SharedTable.cloneAndFreeze() to create a\n  frozen clone of it.\ncodesamples:\n  - SharedTable-ElementAccess\n  - SharedTable-ElementIteration\ntags: []\ndeprecationmessage: ''\nconstructors:\n  - name: SharedTable.new\n    summary: Returns a new, empty Datatype.SharedTable.\n    description: |-\n      Returns a new, empty Datatype.SharedTable.\n\n      lua\n      local st = SharedTable.new()\n\n    parameters: []\n    codesamples: []\n    tags: []\n    deprecationmessage: ''\n  - name: SharedTable.new\n    summary: |-\n      Returns a new Datatype.SharedTable containing elements equivalent to\n      those in the provided Luau table.\n    description: |-\n      Returns a new Datatype.SharedTable containing elements equivalent to\n      those in the provided Luau table.\n\n      If the provided Luau table contains any keys or values that cannot be\n      stored in a Datatype.SharedTable, construction of the\n      Datatype.SharedTable fails.  See the summary at the top of this page for\n      a list of types of objects that can be stored in a Datatype.SharedTable.\n      If the Luau table contains any table as a value, that table is converted\n      into a new Datatype.SharedTable.\n\n      lua\n      local t = {}\n      t.x = 1\n      t.y = 2\n      t.z = {\"a\", \"b\", \"c\"}\n\n      local st = SharedTable.new(t)\n      assert(st.x == 1)\n      assert(st.y == 2)\n      assert(st.z[1] == \"a\")\n      assert(st.z[2] == \"b\")\n      assert(st.z[3] == \"c\")\n\n\n      Note that in some cases it may be desirable to store a Datatype.SharedTable in the Class.SharedTableRegistry. The Class.ShareTableRegistry:GetSharedTable() method provides a convenient way to accomplish this.\n    parameters:\n      - name: t\n        type: table\n        default:\n        summary: |-\n          The Luau table whose elements are to be stored in the new\n          Datatype.SharedTable.\n    codesamples: []\n    tags: []\n    deprecationmessage: ''\nconstants: []\nproperties: []\nmethods: []\nfunctions:\n  - name: SharedTable.clear\n    summary: |\n      Removes all of the elements from the Datatype.SharedTable.\n    description: |\n      Atomically removes all of the elements from a Datatype.SharedTable.\n\n      If the Datatype.SharedTable is frozen, the operation fails and an error\n      will be raised.\n\n      lua\n      local st = SharedTable.new({\"a\", \"b\", \"c\"})\n      assert(SharedTable.size(st) == 3)\n\n      SharedTable.clear(st)\n      assert(SharedTable.size(st) == 0)\n\n    parameters:\n      - name: st\n        type: SharedTable\n        default:\n        summary: |\n          The Datatype.SharedTable to clear.\n    returns:\n      - type: ()\n        summary: ''\n    codesamples: []\n    tags: []\n    deprecationmessage: ''\n  - name: SharedTable.clone\n    summary: |\n      Creates and returns a clone of the provided Datatype.SharedTable.\n    description: |\n      Creates a clone of a Datatype.SharedTable and returns the clone.\n\n      If the optional deep argument is not present, or if it is present and\n      its value is false, then a shallow clone is created. A shallow clone\n      copies only the top-level Datatype.SharedTable object. If any value in\n      the Datatype.SharedTable itself is a Datatype.SharedTable, then both\n      the original Datatype.SharedTable and the clone Datatype.SharedTable\n      will refer to the same Datatype.SharedTable.\n\n      The shallow clone operation is atomic, so the clone Datatype.SharedTable\n      will contain a consistent snapshot of the state in the original\n      Datatype.SharedTable, even if it is being modified concurrently from\n      other scripts.\n\n      If the optional deep argument is present and its value is true, then a\n      deep clone is created. A deep clone recursively copies a structure of\n      Datatype.SharedTable objects, such that there is no state shared between\n      the original Datatype.SharedTable and the clone.\n\n      The clone of each Datatype.SharedTable within the graph of\n      Datatype.SharedTable objects is atomic, but the deep clone as a whole is\n      not atomic. Thus, the clone of each Datatype.SharedTable within the\n      graph will contain a consistent snapshot of the state of the original\n      Datatype.SharedTable object from which it was cloned, but the states of\n      different Datatype.SharedTable objects may be inconsistent if the graph\n      is being modified concurrently from other scripts.\n\n      The Datatype.SharedTable object(s) being cloned may be frozen\n      (read-only) or not. Regardless, the newly created clones are not frozen\n      (and are thus modifiable). To create frozen clones, use the\n      Datatype.SharedTable.cloneAndFreeze function.\n\n      To illustrate the difference between a shallow clone and a deep clone,\n      consider the following samples. This first sample creates a shallow clone\n      and the second creates a deep clone.\n    parameters:\n      - name: st\n        type: SharedTable\n        default:\n        summary: |\n          The Datatype.SharedTable object to clone.\n      - name: deep\n        type: boolean?\n        default: false\n        summary: |\n          Whether to create a deep clone (true) or a shallow clone (false).\n    returns:\n      - type: SharedTable\n        summary: ''\n    codesamples:\n      - SharedTable-ShallowClone\n      - SharedTable-DeepClone\n    tags: []\n    deprecationmessage: ''\n  - name: SharedTable.cloneAndFreeze\n    summary: |\n      Creates and returns a frozen (read-only) clone of the provided\n      Datatype.SharedTable.\n    description: |\n      Creates a frozen (read-only) clone of a Datatype.SharedTable and returns\n      the clone. The behavior of this function is the same as the behavior of\n      clone, except that the clone is frozen.\n\n      If a deep clone is requested, then all of the cloned\n      Datatype.SharedTable objects are frozen.\n    parameters:\n      - name: st\n        type: SharedTable\n        default:\n        summary: |\n          The SharedTable object to clone.\n      - name: deep\n        type: boolean?\n        default: false\n        summary: |\n          Whether to create a deep clone (true) or a shallow clone (false).\n    returns:\n      - type: SharedTable\n        summary: ''\n    codesamples: []\n    tags: []\n    deprecationmessage: ''\n  - name: SharedTable.increment\n    summary: |\n      Adds delta to the value with the provided key and returns the original\n      value.\n    description: |\n      Atomically increments the value of an element. An element with the\n      specified key must exist in the Datatype.SharedTable, and it must be of\n      type number. The specified delta is added to the value, and the\n      original value is returned.\n\n      The SharedTable.update function can also be used for this purpose; this\n      increment function exists for convenience and performance (in general,\n      increment is much faster than update, so it should be preferred where\n      possible). The following two function calls have the same effect:\n\n      lua\n      local st = SharedTable.new()\n      st[\"x\"] = 1\n\n      local oldValue = SharedTable.increment(st, \"x\", 1)\n\n      SharedTable.update(st, \"x\", function(v)\n          oldValue = v\n          return v + 1\n      end)\n\n\n      If the Datatype.SharedTable is frozen, the operation fails and an error\n      will be raised.\n    parameters:\n      - name: st\n        type: SharedTable\n        default:\n        summary: |\n          The Datatype.SharedTable object to be updated.\n      - name: key\n        type: string | number\n        default:\n        summary: |\n          The key of the element in the Datatype.SharedTable object to be\n          updated.\n      - name: delta\n        type: number\n        default:\n        summary: |\n          The value to be added to the element in the Datatype.SharedTable.\n    returns:\n      - type: number\n        summary: |\n          The original value of the element, before delta was added to it.\n    codesamples:\n      - SharedTable-Increment\n    tags: []\n    deprecationmessage: ''\n  - name: SharedTable.isFrozen\n    summary: |\n      Returns true if the Datatype.SharedTable is frozen (read-only).\n    description: |\n      Returns true if the Datatype.SharedTable is frozen (read-only).\n\n      lua\n      local st1 = SharedTable.new({\"a\", \"b\", \"c\"})\n      assert(not SharedTable.isFrozen(st1))\n\n      local st2 = SharedTable.cloneAndFreeze(st1)\n      assert(SharedTable.isFrozen(st2))\n\n    parameters:\n      - name: st\n        type: SharedTable\n        default:\n        summary: |\n          The Datatype.SharedTable object whose frozen state is to be queried.\n    returns:\n      - type: boolean\n        summary: ''\n    codesamples: []\n    tags: []\n    deprecationmessage: ''\n  - name: SharedTable.size\n    summary: |\n      Returns the number of elements stored in the Datatype.SharedTable.\n    description: |\n      Returns the number of elements stored in the SharedTable. Note that if\n      other scripts are concurrently modifying the SharedTable, the returned\n      size may no longer be correct after it is returned, since other scripts\n      may have added or removed elements from the SharedTable.\n\n      lua\n      local st = SharedTable.new({\"a\", \"b\", \"c\"})\n      assert(SharedTable.size(st) == 3)\n\n      st[2] = nil\n      assert(SharedTable.size(st) == 2)\n\n    parameters:\n      - name: st\n        type: SharedTable\n        default:\n        summary: |\n          The Datatype.SharedTable object whose size is to be queried.\n    returns:\n      - type: number\n        summary: ''\n    codesamples: []\n    tags: []\n    deprecationmessage: ''\n  - name: SharedTable.update\n    summary: |\n      Updates the value with the provided key via the provided update function.\n    description: |\n      Atomically updates the value of an element.\n\n      When a Datatype.SharedTable is accessed concurrently from scripts\n      running in different execution contexts, it is possible for their accesses\n      to interleave unpredictably. Because of this, code like the following is\n      generally incorrect, because the value may have changed between the read\n      on the first line and the update on the second line:\n\n      lua\n      local oldValue = st[\"x\"]\n      st[\"x\"] = oldValue .. \",x\"\n\n\n      The update function makes it possible to perform an atomic update to an\n      element. It takes a function that it will call with the current value of\n      the element. The function can then compute and return the new value. Note\n      that the function may be called multiple times if the\n      Datatype.SharedTable is being concurrently modified from other scripts.\n\n      If the Datatype.SharedTable is frozen, the operation fails and an error\n      will be raised.\n    parameters:\n      - name: st\n        type: SharedTable\n        default:\n        summary: |\n          The Datatype.SharedTable object to be updated.\n      - name: key\n        type: string | number\n        default:\n        summary: |\n          The key of the element in the Datatype.SharedTable object to be\n          updated.\n      - name: f\n        type: function\n        default:\n        summary: |\n          The function that will be called to compute the new value for the\n          element.\n    returns:\n      - type: ()\n        summary: ''\n    codesamples:\n      - SharedTable-Update\n    tags: []\n    deprecationmessage: ''\nmathoperations: []",
    "source": "SharedTable.yaml"
}