{
    "title": "Third-party tools",
    "description": "These popular tools for managing Roblox projects as a set of local files can enhance developer productivity.",
    "content": "For professional development studios, setting up third-party tools and investing in automation can dramatically improve developer productivity. Roblox's cloud-first approach has many advantages, but moving certain portions of the development workflow outside of the cloud can help larger teams track changes over time, review code, and use the languages and tools with which they're already familiar.\n\n- If you just want to use an external text editor or keep code in version control, Script Sync is a great choice.\n- If you want to manage your entire project as a set of local files, this page covers some tools and strategies.\n\nAlthough this page covers several popular tools, it shouldn't be taken as a strict recommendation of them. Every team has different needs, so this page is intended to help you examine ways to improve your workflow rather than tell you to download anything in particular.\n\nThe tools on this page are not maintained by Roblox and can change or stop working at any time.\n\nThe syncing problem\n\nAt its core, using external tools with Roblox is a syncing problem:\n\n- You want your Roblox instances to exist as files on disk so that you can use your own tools to work on them.\n- You have to get your files back into your Roblox project after you've finished working on them.\n- If someone else changed those same files in the meantime, you have to handle any conflicts.\n\nFor the whole solution to feel seamless and automatic, you need to a) listen for changes to files and b) incorporate these changes back into Studio.\n\nRather than Roblox's cloud-first approach, Rojo allows for a \"file system-first\" approach. It extracts instances in your project into external files. Then it runs a server. The Rojo plugin connects to the server to synchronize those files with Studio.\n\nInstall Rojo with Foreman\n\nYou can manually download and run a Rojo binary, but that approach runs the risk of different developers on your team using different Rojo versions. A better solution is to use a tool manager like Foreman, which uses a configuration file—a list of repositories and versions—to make the installation and upgrade process consistent across machines.\n\nBecause it manages your baseline development environment rather than the packages within your project, Foreman is more akin to nvm than npm, but the comparison isn't perfect. A simple foreman.toml file looks like this:\n\ntoml\n[tools]\nrojo = { github = \"rojo-rbx/rojo\", version = \"7.4.1\" }\nwally = { github = \"UpliftGames/wally\", version = \"0.3.2\" }\n\nThen you install these tools with foreman install. In addition to a global foreman.toml file, Foreman supports per-project files, so you can easily use different versions of Rojo, Wally, or any other tool for different projects and keep your entire team on those same versions.\n\nWhen a tool releases a new version, you then explicitly bump the version number in your .toml file, use Foreman to perform the upgrade, test the new version, and downgrade if it causes any problems. For commands and installation instructions, see Foreman.\n\nRun Rojo\n\nAfter you install Rojo with Foreman, what you've really installed is the Rojo server. The next step is to install the Rojo plugin for Roblox Studio:\n\nbash\nrojo plugin install\n\nThen generate the project structure for your new experience and build it:\n\nbash\nrojo init my-new-experience\ncd my-new-experience\nrojo build -o my-new-experience.rbxl\n\nAlternatively, you can port an existing experience. Either way, after you have a project, start the Rojo server:\n\nbash\nrojo serve\n\nIn Roblox Studio, open the .rbxl file you just built, start the Rojo plugin, and connect to your now-running server, at which point you can start making changes in your preferred text editor and watch those changes automatically sync back to Studio.\n\n!Visual Studio Code with a Rojo project open.\n\n!The Rojo plugin and Studio Explorer side-by-side.\n\nRojo projects have certain naming requirements for files, numerous configuration options, and some limitations, all of which are covered in the Rojo documentation.\n\nPackage managers\n\nRoblox has a robust set of included APIs, but if you want to make use of community software packages in a consistent, reproducible way, you need a package manager. Wally is a popular option. You can install it through Foreman, just like Rojo.\n\nWithin your experience's Rojo directory, run wally init. Then add your desired packages to wally.toml. The file might look like this:\n\ntoml\n[package]\nname = \"my-home-directory/my-new-experience\"\nversion = \"0.1.0\"\nregistry = \"https://github.com/UpliftGames/wally-index\"\nrealm = \"shared\"\n\n[dependencies]\nreact = \"jsdotlua/react@17.1.0\"\nreact-roblox = \"jsdotlua/react-roblox@17.1.0\"\ncryo = \"phalanxia/cryo@1.0.3\"\n\nThen run wally install. Wally creates a Packages directory and downloads the specified packages there. The final step is to add the Packages directory to Rojo so that its contents sync back to Roblox. Open default.project.json and add the path. For simplicity, this example adds the entire directory to Class.ReplicatedStorage so that all packages are available to all scripts, but you might prefer to add specific packages to Class.ServerScriptService or Class.StarterPlayerScripts:\n\njson\n{\n  \"name\": \"my-new-experience\",\n  \"tree\": {\n    \"$className\": \"DataModel\",\n\n    \"ReplicatedStorage\": {\n      \"Shared\": {\n        \"$path\": \"src/shared\"\n      },\n      \"Packages\": {\n        \"$path\": \"Packages\"\n      }\n    },\n\n    ...\n\n  }\n}\n\nThen you can require packages within your scripts just like any other Class.ModuleScript:\n\nlua\nlocal Players = game:GetService(\"Players\")\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal React = require(ReplicatedStorage.Packages.react)\nlocal ReactRoblox = require(ReplicatedStorage.Packages[\"react-roblox\"])\n\nlocal handle = Instance.new(\"ScreenGui\", Players.LocalPlayer.PlayerGui)\nlocal root = ReactRoblox.createRoot(handle)\n\nlocal helloFrame = React.createElement(\"TextLabel\", {\n\tText = \"Hello World!\",\n\tSize = UDim2.new(0, 200, 0, 200),\n\tPosition = UDim2.new(0.5, 0, 0.5, 0),\n\tAnchorPoint = Vector2.new(0.5, 0.5),\n\tBackgroundColor3 = Color3.fromRGB(248, 217, 109),\n\tFont = Enum.Font.LuckiestGuy,\n\tTextSize = 24\n})\n\nroot:render(helloFrame)\n\nLike most other software projects, the goal is that contributors can clone a repository, install Foreman, run a few commands, and have the same development environment as the rest of the team.\n\nFor a detailed walkthrough of using React to create a Roblox UI, see React + Roblox.\n\nVersion control\n\nHaving a set of plain text files on your computer unlocks a variety of capabilities, but the primary one is version control. You can store your files in a Git or Mercurial repository; host remote repositories and review code changes in GitHub, GitLab, or Bitbucket; and use whichever text editor you like.\n\nVisual Studio Code and Cursor have the largest extension ecosystem, but Sublime Text and Notepad++, and Vim are all popular choices. Whichever editor you choose, matching the capabilities of the Studio script editor will require some extensions.\n\nYou might also consider adding:\n\n- A linter like selene to catch common issues and enforce coding standards\n- A code formatter like StyLua\n- A language server like Luau Language Server for autocompletion, type checking, and more\n- Open Cloud scripts (not synced to Studio) to update a published experience or restart servers\n\nUndo everything\n\nBecause third-party tools sync changes back to Roblox Studio rather than replacing it, no part of this workflow involves any lock-in. At any time, you can stop using one or all of these tools and go back to editing your experience exclusively in Studio. The lack of risk makes experimenting with third-party tools particularly appealing.",
    "source": "external-tools.md"
}