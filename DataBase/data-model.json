{
    "title": "Data model",
    "description": "Explains the hierarchy of objects that describe everything about a place.",
    "content": "Every place is represented by a data model, a hierarchy of objects that describe\neverything about the place. The data model contains all objects that make up the\n3D world, such as parts, terrain, lighting, and other environmental elements. It\nalso contains objects that can control runtime behavior, such as scripts that\nmodify properties, call methods and functions, and respond to events that enable\ndynamic behavior and interactivity.\n\nThe Roblox Engine uses the data model as a source of truth for a place's state,\nso it can simulate and render it on client devices. For more information on how\nthe Roblox Engine interprets the data model, see Client-Server\nRuntime.\n\nObjects\n\nYou place and organize objects in the data model to describe a place in Roblox.\nEvery object in Roblox inherits from the Class.Instance class, which defines\ngeneric properties, methods, and events that are common to all objects. Objects\nalso define their own characteristics depending on the functionality the object\nprovides. There are many categories of objects with a wide variety of uses, but\nyou'll frequently work with Class.BasePart and Class.LuaSourceContainer\nobjects, commonly referred to as parts and scripts.\n\nFor a comprehensive list of all the features of the Roblox Engine, see the\nreference documentation.\n\n3D building blocks\n\nClass.BasePart is the core class for physically-simulated 3D building blocks in the world. It defines the properties and methods common to all physical objects with properties like position, size, and orientation.\n\n\n    Object\n    Description\n\n\n\n    Class.Part\n    A primitive part that can take the shape of a block, ball, cylinder, wedge, or corner wedge.\n\n\n    Class.MeshPart\n    An imported mesh from 3D modeling software like Maya or Blender.\n\n\n    Class.TrussPart\n    A truss beam that characters can climb like a ladder.\n\n\nWhile you can theoretically create a fully functional Roblox experience using\njust simple parts, you'll most likely import meshes and combine primitive parts into more complex objects and structures through solid\nmodeling.\n\nScripts\n\nYou can add interactivity and behavior to your place's 3D world and define logic\nwith scripts. You write scripts in the Luau programming language to do things\nlike moving parts, calling other scripts, and responding to events. Because\nRoblox works in a client-server model, you can run scripts on the server,\nclient, or have them communicate across the network boundary.\n\n- A Class.Script object represents a script that can only run on the server.\n- A Class.LocalScript object represents a script that can only run on the\n  client.\n- A Class.ModuleScript object represents a reusable script that you can\n  Global.LuaGlobals.require() from both\n  server and client scripts.\n\nFor scripts to behave properly, you must place them in the correct containers in\nthe data model. For more information, see the Server and Client sections.\n\nObject organization\n\nWhile you have a lot of flexibility in how you organize your data model, the\nRoblox Engine expects certain objects to be in certain container services\nwhich are objects that have specific behaviors and can affect the behaviors of\nthe objects they contain. The main categories of container services include:\n\n- Workspace — Class.Workspace stores all objects that render in the 3D\n  world.\n- Environment — Containers like Class.Lighting and Class.SoundService\n  that contain objects for environmental settings and elements.\n- Replication — Containers for content and logic that replicates between the\n  server and client, such as Class.ReplicatedStorage and\n  Class.ReplicatedFirst.\n- Server — Containers for server-side only content and logic, such as\n  Class.ServerScriptService and Class.ServerStorage.\n- Client — Containers for client-side content and logic, such as\n  Class.StarterPlayer and Class.StarterGui.\n- Chat — Containers for objects that enable chat features, such as\n  Class.VoiceChatService and Class.TextChatService.\n\nThe Roblox Engine has many more services that provide\nbuilt-in functionality that you can call within your scripts. The Roblox Engine\ndoesn't give these services special treatment in the data model. For more\ninformation, see services.\n\nIn addition, you can further organize your objects with the following objects:\n\n- Folders — A Class.Folder is for organizational purposes and doesn't\n  define any behavior. For example, you can use folders to group similar objects\n  like a set of scripts in server storage.\n- Models — A Class.Model is mainly intended for geometric groupings of\n  parts, such as grouping together a desk set that includes a chair, table, and\n  a lamp. To organize more complex sets, you can even nest models within models.\n\nWorkspace\n\nClass.Workspace contains all objects that make up a place's 3D world. You can\nadd objects to the workspace to customize your 3D world, such as base parts,\nmesh parts, and models. Clients render everything that appears in this container\nand nothing outside of it, so you can control what users see and interact with\nin your place. Although not actually rendered, you can also add scripts that are\nparented to the parts and models that they are associated with. By default, the\nworkspace is pre-populated with a Class.Terrain and Class.Camera object.\n\nCamera\n\nClass.Camera determines how the client views the 3D world. By default, there\nis one camera in the workspace, but you can add multiple camera objects for\ncreating different perspectives and views. Every client takes these settings and\ncreates its own camera view that the server can't directly modify.\n\nFor example, you can set a camera to follow user movements or stay fixed in a\nparticular location. You can also adjust the field of view, distance, and angle\nto create different visual effects of how users view your 3D world.\n\nFor more information, see customize the camera.\n\nTerrain\n\nClass.Terrain lets you create landscapes for your place. You can apply a\nmaterial to the terrain to simulate desired natural environments, such as grass,\nwater, sand, or a custom material. Though you can only have one terrain object\nfor your 3D world and apply one material to that terrain, you can use the\nTerrain Editor to edit regions of your\nterrain.\n\nFor more information, see environmental terrain.\n\nEnvironment\n\nCustom lighting can make your 3D world much more immersive and realistic. The Class.Lighting service contains objects that control global lighting settings of your place, such as Class.Atmosphere for simulating atmospheric effects or Class.Sky to alter the sun, moon, and stars in your environments. In addition, you can use light sources to emit light from specific objects.\n\nAdding audio to your experiences is also crucial for elevating your experiences to new heights. By strategically using positional and non-positional audio, you can immerse players into your worlds, provide them useful feedback for their actions, and direct their attention to what they need to do to be successful in their objectives.\n\nReplication\n\nReplication is the process of the server synchronizing the state of your\nplace with all connected clients. The Roblox Engine intelligently and\nautomatically replicates data, physics, and chat messages between the server and\nclient for many cases, but you can also specify certain objects to replicate by\nplacing them in specific containers.\n\nReplicatedFirst\n\nClass.ReplicatedFirst contains objects that you want to replicate to a client\nwhen it joins your place. It typically contains objects that are essential to\ninitialize a player, such as client-side Class.LocalScript objects and the\nobjects associated with the scripts. All content in this container is replicated\nfrom the server to the client only once.\n\nReplicatedStorage\n\nClass.ReplicatedStorage contains objects that are available to both the server\nand connected clients. Any changes that occur on the client persist but won't be\nreplicated to the server. The server can overwrite changes on the client to\nmaintain consistency. This container is typically used for Class.ModuleScript\nobjects that need to be shared and accessed by both Class.Script (server-side)\nand Class.LocalScript (client-side) objects. In addition, you can use this\ncontainer to replicate any objects that don't need to exist in the 3D world\nuntil needed, such as a Class.ParticleEmitter for cloning and parenting to all\nincoming character models.\n\nFor more information on how replication works, see client-server runtime.\n\nServer\n\nThe data model defines dedicated containers for server-side only objects that\nare never replicated to the client. This allows the server to affect client\nbehavior and state without exposing the server's objects and logic to the\nclient.\n\nYou can use remote events and functions to allow\nclient-side communication with the server.\n\nServerScriptService\n\nClass.ServerScriptService contains Class.Script objects,\nClass.ModuleScript objects that are required by server scripts, and other\nscripting-related objects that are only meant for server use. If your scripts\nrequire other, non-scripting objects, you must place them in\nClass.ServerStorage. Scripts in this container are never replicated to\nclients, which allows you to have secure, server-side logic.\n\nServerStorage\n\nClass.ServerStorage contains objects that are only meant for server use. You\ncan use this container to store objects that you want to clone and parent to the\nworkspace or other containers at runtime. For example, you can store large\nobjects such as maps in this container until they are needed and move them into\nthe workspace only when required. This lets you decrease client network traffic\non initial join.\n\nScripts don't run when they are parented to this\ncontainer, but scripts inside Class.ServerScriptService can access and run\nClass.ModuleScript objects in this container.\n\nClient\n\nThe client container services are meant for objects that are replicated to every\nconnected client. This category of containers replicate to every connected\nclient and typically contain 3D objects and associated Class.LocalScript\nobjects. All objects you store in these containers are non-persistent across\nsessions and reset every time a client rejoins. You can put objects in these\ncontainers such as player GUIs, client-side scripts, and other objects that are\nonly relevant to the client.\n\nWhen a client connects to a server, the Class.Players container service\nlistens for users joining your place and creates a Class.Player object for\nevery client. The server copies the objects from the client containers in the\nedit data model to the corresponding location in the runtime data model inside\nthe Class.Players object. The following table describes the original container\nit resides on in the container and the resulting container they are copied to on\nthe client:\n\n\n    Edit data model\n    Runtime data model\n    Notes\n\n\n\n    Class.StarterPack\n    Player.Backpack\n    Scripts that set up the player's inventory and generally contain Class.Tool objects but often contains local scripts as well.\n\n\n    Class.StarterGui\n    Player.PlayerGui\n    Scripts that can manage the player's local GUI. When a player respawns, the contents of PlayerGui are emptied. The server copies the objects inside StarterGui into the PlayerGui.\n\n\n    Class.StarterPlayerScripts\n    Player.PlayerScripts\n    General purpose scripts for the client. For example, if you want to create special effects on the client when certain conditions are met, you can place a local script in this container to do that. The server cannot access this container.\n\n\n    Class.StarterCharacterScripts\n    Player.Character\n    Scripts that are copied to the client when they spawn. These scripts do not persist when the player respawns.\n\n\n    Class.ReplicatedFirst\n\n    The contents of this container are replicated to all clients (but not back to the server) first, before anything else.\n\n\nFor more information on edit and runtime data models, see client-server runtime.\n\nYou don't add Class.Player objects to the Class.Players container\nservice explicitly.\n\nChat\n\nTextChatService\n\nClass.TextChatService represents the service that handles various,\nin-experience text chat tasks, such as managing channels, decorating messages,\nfiltering text, creating commands, and developing custom chats interfaces.\n\nFor more information, see text chat overview.\n\nVoiceChatService\n\nClass.VoiceChatService represents the proximity-based voice chat\nfeature that simulates realistic communication based on how close you are to\nother users. You can use this service to toggle the feature on and off.\n\nFor more information, see voice chat.\n\nFolders and models\n\nThere are two primary methods for grouping objects in the data model:\nfolders and models. Both are containers for objects, but they have\ndifferent purposes.\n\n- Folders are best for storing sections of an environment, such as the lobby or a combat arena.\n- Models are used for sets of objects, such as a desk set that includes a chair,\n  table, and a lamp. To organize more complex sets, nest models inside models.\n\nYou should always name your objects descriptively. This makes it easy to\nfind and modify objects later on if needed.\n\n\n\n    Objects organized into Class.Folder|Folders\n\n\n\n    Various \"map\" models to swap between Class.Workspace and Class.ServerStorage",
    "source": "data-model.md"
}