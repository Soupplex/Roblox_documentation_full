{
    "title": "debug",
    "description": "",
    "content": "{\n    \"title\": \"debug\",\n    \"description\": \"\",\n    \"content\": \"This file is automatically generated. Please don't edit it manually.\\nTo submit a bug report on the content, see\\nhttps://devforum.roblox.com/c/bug-reports/documentation-issues/72\\n\\nname: debug\\ntype: library\\nsummary: |\\n  This library provides functions useful for debugging and profiling code.\\ndescription: |\\n  Provides a few basic functions for debugging code in Roblox. Unlike the\\n  Library.debug library found in Lua natively, this version has been heavily\\n  sandboxed.\\ntags: []\\ncodesamples: []\\nproperties: []\\nfunctions:\\n  - name: debug.traceback\\n    summary: |\\n      Returns a string of undefined format that describes the current function\\n      call stack.\\n    description: |\\n      Returns a traceback of the current function call stack as a string; in\\n      other words, a description of the functions that have been called up to\\n      this point. During debugging, this behaves like an error stack trace but\\n      does not stop execution of the script.\\n\\n      The level parameter specifies what level of the call stack to consider,\\n      with 1 being the call of Library.debug.traceback() itself, 2 being\\n      the call of the function calling Library.debug.traceback(), and so on.\\n      See the code sample below for an example of sequential function calls.\\n\\n      Note that this function will often return inaccurate results (compared to\\n      the original source code) and that the format of the returned traceback\\n      may change at any time. You should not parse the return value for\\n      specific information such as script names or line numbers.\\n\\n      The following example includes sequential function calls; fnB() is\\n      called, and it calls fnA() which then calls Library.debug.traceback().\\n\\n      lua\\n      local function fnA()\\n      \\tprint(debug.traceback(\\\"Specific moment during fnA()\\\"))\\n      end\\n\\n      local function fnB()\\n      \\tfnA()\\n      end\\n\\n      -- Call function fnB() to begin traceback\\n      fnB()\\n\\n    parameters:\\n      - name: message\\n        type: string\\n        default: ''\\n        summary: |\\n          The first line of the returned string.\\n      - name: level\\n        type: number\\n        default: 1\\n        summary: |\\n          The number of calls \\\"up\\\" the call stack to return.\\n    returns:\\n      - type: string\\n        summary: |\\n          Traceback of the current function call stack.\\n    tags: []\\n    codesamples: []\\n    deprecationmessage: ''\\n  - name: debug.traceback\\n    summary: |\\n      Returns a string of undefined format that describes the current function\\n      call stack.\\n    description: |\\n      Returns a traceback of the current function call stack as a string; in\\n      other words, a description of the functions that have been called up to\\n      this point. During debugging, this behaves like an error stack trace but\\n      does not stop execution of the script.\\n\\n      The level parameter specifies what level of the call stack to consider,\\n      with 1 being the call of Library.debug.traceback() itself, 2 being\\n      the call of the function calling Library.debug.traceback(), and so on.\\n      See the code sample below for an example of sequential function calls.\\n\\n      Note that this function will often return inaccurate results (compared to\\n      the original source code) and that the format of the returned traceback\\n      may change at any time. You should not parse the return value for\\n      specific information such as script names or line numbers.\\n\\n      The following example includes sequential function calls; fnB() is\\n      called, and it calls fnA() which then calls Library.debug.traceback().\\n\\n      lua\\n      local function fnA()\\n      \\tprint(debug.traceback(\\\"Specific moment during fnA()\\\"))\\n      end\\n\\n      local function fnB()\\n      \\tfnA()\\n      end\\n\\n      -- Call function fnB() to begin traceback\\n      fnB()\\n\\n    parameters:\\n      - name: thread\\n        type: thread\\n        default:\\n        summary: |\\n          A thread as returned by Library.coroutine.create().\\n      - name: message\\n        type: string\\n        default: ''\\n        summary: |\\n          The first line of the returned string.\\n      - name: level\\n        type: number\\n        default: 1\\n        summary: |\\n          The number of calls \\\"up\\\" the call stack to return.\\n    returns:\\n      - type: string\\n        summary: |\\n          Traceback of the current function call stack.\\n    tags: []\\n    codesamples: []\\n    deprecationmessage: ''\\n  - name: debug.info\\n    summary: |\\n      Traverses the entire stack of current thread and returns a string\\n      containing the call stack of target level details.\\n    description: |\\n      Allows programmatic inspection of the call stack. This function differs\\n      from Library.debug.traceback() in that it guarantees the format of the\\n      data it returns. This is useful for general logging and filtering purposes\\n      as well as for sending the data to systems expecting structured input,\\n      such as crash aggregation.\\n\\n      lua\\n      local function fnA()\\n      \\t-- Output source identifier (\\\"s\\\") and line (\\\"l\\\") at levels 1 and 2\\n      \\tprint(debug.info(1, \\\"sl\\\"))  --> fnA() 3\\n      \\tprint(debug.info(2, \\\"sl\\\"))  --> fnA() 7\\n      end\\n\\n      fnA()\\n\\n\\n      Note that this function is similar to\\n      debug.getinfo, an unavailable part of\\n      the standard Lua library which serves a similar purpose.\\n    parameters:\\n      - name: level\\n        type: number\\n        default:\\n        summary: |\\n          Determines at what level of the call stack the information returned\\n          should describe. A value of 1 represents the function which is\\n          calling Library.debug.info(), a value of 2 represents the function\\n          that called that function, and so on.\\n      - name: options\\n        type: string\\n        default:\\n        summary: |\\n          A string that describes what the returned information should\\n          represent. It must only contain 0 or 1 instances of the characters\\n          slnaf, each representing a piece of information:\\n\\n          - s (string) — The function source identifier,\\n            equal to the full name of the script the function is defined in.\\n          - l (number) — The line number of the function\\n            call represented by level.\\n          - n (string) — The name of the function; may be\\n            nil for anonymous functions and C functions without an assigned\\n            debug name.\\n          - a (number, boolean) —\\n            Arity of the function, which refers to the parameter count and\\n            whether the function is variadic.\\n          - f (function) — The function which was\\n            inspected.\\n    returns:\\n      - type: Tuple\\n        summary: ''\\n    tags: []\\n    codesamples: []\\n    deprecationmessage: ''\\n  - name: debug.info\\n    summary: |\\n      Traverses the entire stack of current thread and returns a string\\n      containing the call stack of target function details.\\n    description: |\\n      Allows programmatic inspection of the call stack. This function differs\\n      from Library.debug.traceback() in that it guarantees the format of the\\n      data it returns. This is useful for general logging and filtering purposes\\n      as well as for sending the data to systems expecting structured input,\\n      such as crash aggregation.\\n\\n      lua\\n      local function fnA()\\n\\n      end\\n\\n      local function fnB()\\n\\n      end\\n\\n      -- Output line (\\\"l\\\"), name (\\\"n\\\"), and identifier (\\\"f\\\") for both fnA() and fnB()\\n      print(debug.info(fnA, \\\"lnf\\\"))  --> 1 fnA function: 0x75e3d3c398a81252\\n      print(debug.info(fnB, \\\"lnf\\\"))  --> 5 fnB function: 0x6022a6dc5ccf4ab2\\n\\n\\n      Note that this function is similar to\\n      debug.getinfo, an unavailable part of\\n      the standard Lua library which serves a similar purpose.\\n    parameters:\\n      - name: function\\n        type: function\\n        default:\\n        summary: |\\n          The function of the call stack which the information returned should\\n          describe.\\n      - name: options\\n        type: string\\n        default:\\n        summary: |\\n          A string that describes what the returned information should\\n          represent. It must only contain 0 or 1 instances of the characters\\n          slnaf, each representing a piece of information:\\n\\n          - s (string) — The function source identifier,\\n            equal to the full name of the script the function is defined in.\\n          - l (number) — The line that function is\\n            defined on.\\n          - n (string) — The name of the function; may be\\n            nil for anonymous functions and C functions without an assigned\\n            debug name.\\n          - a (number, boolean) —\\n            Arity of the function, which refers to the parameter count and\\n            whether the function is variadic.\\n          - f (function) — The function which was\\n            inspected.\\n    returns:\\n      - type: Tuple\\n        summary: ''\\n    tags: []\\n    codesamples: []\\n    deprecationmessage: ''\\n  - name: debug.info\\n    summary: |\\n      Traverses the entire stack of target thread and returns a string\\n      containing the call stack of target level details.\\n    description: |\\n      Allows programmatic inspection of the call stack. This function differs\\n      from Library.debug.traceback() in that it guarantees the format of the\\n      data it returns. This is useful for general logging and filtering purposes\\n      as well as for sending the data to systems expecting structured input,\\n      such as crash aggregation.\\n\\n      lua\\n      local function fnA()\\n      \\t-- Output source identifier (\\\"s\\\") and line (\\\"l\\\") at levels 1 and 2\\n      \\tprint(debug.info(1, \\\"sl\\\"))  --> fnA() 3\\n      \\tprint(debug.info(2, \\\"sl\\\"))  --> fnA() 7\\n      end\\n\\n      fnA()\\n\\n\\n      Note that this function is similar to\\n      debug.getinfo, an unavailable part of\\n      the standard Lua library which serves a similar purpose.\\n    parameters:\\n      - name: thread\\n        type: thread\\n        default:\\n        summary: |\\n          A thread as returned by Library.coroutine.create().\\n      - name: level\\n        type: number\\n        default:\\n        summary: |\\n          Determines at what level of the call stack the information returned\\n          should describe. A value of 1 represents the function which is\\n          calling Library.debug.info(), a value of 2 represents the function\\n          that called that function, and so on.\\n      - name: options\\n        type: string\\n        default:\\n        summary: |\\n          A string that describes what the returned information should\\n          represent. It must only contain 0 or 1 instances of the characters\\n          slnaf, each representing a piece of information:\\n\\n          - s (string) — The function source identifier,\\n            equal to the full name of the script the function is defined in.\\n          - l (number) — The line number of the function\\n            call represented by level.\\n          - n (string) — The name of the function; may be\\n            nil for anonymous functions and C functions without an assigned\\n            debug name.\\n          - a (number, boolean) —\\n            Arity of the function, which refers to the parameter count and\\n            whether the function is variadic.\\n          - f (function) — The function which was\\n            inspected.\\n    returns:\\n      - type: Tuple\\n        summary: ''\\n    tags: []\\n    codesamples: []\\n    deprecationmessage: ''\\n  - name: debug.profilebegin\\n    summary: |\\n      Starts profiling for a label.\\n    description: |\\n      Starts profiling for a\\n      MicroProfiler label.\\n    parameters:\\n      - name: label\\n        type: string\\n        default:\\n        summary: |\\n          The text that this\\n          MicroProfiler label\\n          displays.\\n    returns:\\n      - type: ()\\n        summary: ''\\n    tags: []\\n    codesamples: []\\n    deprecationmessage: ''\\n  - name: debug.profileend\\n    summary: |\\n      Stops profiling for the most recent label that\\n      Library.debug.profilebegin() opened.\\n    description: |\\n      Stops profiling for the most recent\\n      MicroProfiler label that\\n      Library.debug.profilebegin() opened.\\n    parameters: []\\n    returns:\\n      - type: ()\\n        summary: ''\\n    tags: []\\n    codesamples: []\\n    deprecationmessage: ''\\n  - name: debug.getmemorycategory\\n    summary: |\\n      Returns the name of the current thread's active memory category.\\n    description: |\\n      Returns the name of the current thread's active memory category.\\n    parameters: []\\n    returns:\\n      - type: string\\n        summary: |\\n          The current thread's active memory category.\\n    tags: []\\n    codesamples: []\\n    deprecationmessage: ''\\n  - name: debug.setmemorycategory\\n    summary: |\\n      Assigns a custom tag to the current thread's memory category.\\n    description: |\\n      Assigns a custom tag name to the current thread's memory category in the\\n      Developer Console. Useful for\\n      analyzing memory usage of multiple threads in the same script which would\\n      otherwise be grouped together under the same tag/name. Returns the name of\\n      the current thread's previous memory category.\\n    parameters:\\n      - name: tag\\n        type: string\\n        default:\\n        summary: ''\\n    returns:\\n      - type: string\\n        summary: |\\n          The current thread's previous memory category.\\n    tags: []\\n    codesamples: []\\n    deprecationmessage: ''\\n  - name: debug.resetmemorycategory\\n    summary: |\\n      Resets the tag assigned by Library.debug.setmemorycategory() to the\\n      automatically assigned value (typically, the script name).\\n    description: |\\n      Resets the tag assigned by Library.debug.setmemorycategory() to the\\n      automatically assigned value (typically, the script name).\\n    parameters: []\\n    returns:\\n      - type: ()\\n        summary: ''\\n    tags: []\\n    codesamples: []\\n    deprecationmessage: ''\\n  - name: debug.dumpcodesize\\n    summary: |\\n      Displays a table of native code size of individual functions and scripts.\\n    description: |\\n      Displays a table of native code size of individual functions and scripts.\\n      This function is only available in the Command Bar in Studio. More details\\n      can be found on the\\n      Native Code Generation page.\\n    parameters: []\\n    returns:\\n      - type: ()\\n        summary: ''\\n    tags: []\\n    codesamples: []\\n    deprecationmessage: ''\",\n    \"source\": \"debug.yaml\"\n}",
    "source": "debug.json"
}