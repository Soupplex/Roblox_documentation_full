{
    "title": "bindable",
    "description": "",
    "content": "{\n    \"title\": \"Bindable events and callbacks\",\n    \"description\": \"Bindable events and callbacks allow for back-and-forth communication on the same side of the client-server boundary.\",\n    \"content\": \"Class.BindableEvent and Class.BindableFunction objects let you bind behaviors between scripts on the same side of the client-server boundary and communicate a specific desired outcome for in-experience actions.\\n\\nThe most common use case for bindable events is for experiences that have a round-based structure. For example, you might have a \\\"match started\\\" event that lets other scripts start a timer and display a leaderboard, with a corresponding \\\"match ended\\\" event that lets other scripts know when to move players back into a lobby and display the winners.\\n\\nBecause they coordinate activities between scripts, bindable events are typically used on the server, but you can use them on the client, too.\\n\\nDepending on how your experience works, bindable events can help make your code more modular, but module scripts are often a better alternative for situations in which you need to share data between scripts. You can also use bindable events in conjunction with module scripts for a cleaner syntax, as noted in Custom events.\\n\\nTo communicate between scripts across the client-server boundary, see Remote events.\\n\\nBindable events\\n\\nThe Class.BindableEvent object enables custom events through asynchronous, one-way communication between scripts.\\n\\nWhen you fire a Class.BindableEvent through the Class.BindableEvent:Fire()|Fire() method, the firing script does not yield, and the target function receives the passed arguments with certain limitations. Like all events, Class.BindableEvent|BindableEvents create threads of each connected function, so even if one errors, others continue.\\n\\nTo create a new Class.BindableEvent using the Explorer window in Studio:\\n\\n1. Hover over the container into which you want to insert the Class.BindableEvent. We recommend using Class.ServerScriptService for communication between server scripts and Class.ReplicatedStorage for communication between client scripts.\\n2. Click the &CirclePlus; button that appears to the right of the container's name and insert a BindableEvent instance.\\n3. Rename the instance to TestBindableEvent.\\n\\nAfter you've created a Class.BindableEvent, connect a function to its Class.BindableEvent.Event|Event event in one script, and then Class.BindableEvent:Fire()|Fire() the event from another script.\\n\\nlua title=\\\"Event Connection\\\"\\nlocal ServerScriptService = game:GetService(\\\"ServerScriptService\\\")\\n\\n-- Get reference to bindable event instance\\nlocal bindableEvent = ServerScriptService:WaitForChild(\\\"TestBindableEvent\\\")\\n\\n-- Connect anonymous function to event\\nbindableEvent.Event:Connect(function(data)\\n\\tprint(data)  --> Round started!\\nend)\\n\\nlua title=\\\"Event Firing\\\"\\nlocal ServerScriptService = game:GetService(\\\"ServerScriptService\\\")\\n\\n-- Get reference to bindable event instance\\nlocal bindableEvent = ServerScriptService:WaitForChild(\\\"TestBindableEvent\\\")\\n\\n-- Fire bindable event\\nbindableEvent:Fire(\\\"Round started!\\\")\\n\\nYou can connect multiple functions to the same Class.BindableEvent, but Luau executes them in an unpredictable order. To ensure that functions execute in a particular order, combine them into a single function and connect it to the event.\\n\\nCustom callbacks\\n\\nThe Class.BindableFunction object allows for synchronous, two-way communication between scripts. You can use it to define a custom callback function and invoke it manually by calling Class.BindableFunction:Invoke(). The code invoking the function yields until the corresponding callback is found, and the callback receives the arguments that you passed to Class.BindableFunction:Invoke()|Invoke(). If the callback was never set, the script that invokes it doesn't resume execution.\\n\\nTo create a new Class.BindableFunction using the Explorer window in Studio:\\n\\n1. Hover over the container into which you want to insert the Class.BindableFunction. We recommend using Class.ServerScriptService for communication between server scripts and Class.ReplicatedStorage for communication between client scripts.\\n1. Click the &CirclePlus; button that appears to the right of the container's name and insert a BindableFunction instance.\\n1. Rename the instance to TestBindableFunction.\\n\\nOnce you've created a Class.BindableFunction, you can connect to its Class.BindableFunction.OnInvoke|OnInvoke callback in one script, then Class.BindableFunction:Invoke()|Invoke() the callback function from another script.\\n\\nlua title=\\\"Callback Connection\\\"\\nlocal ServerScriptService = game:GetService(\\\"ServerScriptService\\\")\\n\\n-- Get reference to bindable function\\nlocal bindableFunction = ServerScriptService:WaitForChild(\\\"TestBindableFunction\\\")\\n\\n-- Callback function\\nlocal function addTwoNumbers(a, b)\\n\\treturn a + b\\nend\\n\\n-- Set function as bindable function's callback\\nbindableFunction.OnInvoke = addTwoNumbers\\n\\nlua title=\\\"Event Invocation\\\"\\nlocal ServerScriptService = game:GetService(\\\"ServerScriptService\\\")\\n\\n-- Get reference to bindable function\\nlocal bindableFunction = ServerScriptService:WaitForChild(\\\"TestBindableFunction\\\")\\n\\n-- Invoke callback function and output returned value\\nlocal sum = bindableFunction:Invoke(2, 4)\\nprint(sum)  --> 6\\n\\nEach Class.BindableFunction can only utilize one Class.BindableFunction.OnInvoke|OnInvoke callback. If you make multiple definitions, only the last one assigned runs. Also note that if the Class.BindableFunction.OnInvoke|OnInvoke callback does not have a return statement, the invocation returns nil.\\n\\nArgument limitations\\n\\nWhen you fire a Class.BindableEvent or invoke a Class.BindableFunction, it forwards any arguments that you pass with the event or to the callback function. You can pass any type of Roblox object (Datatype.Enum, Class.Instance, etc.), as well as Luau types like numbers, strings, and booleans, although you should carefully consider the following limitations.\\n\\nNon-string indices\\n\\nIf any indices of a passed table are non-string types, such as an Class.Instance, userdata, or function, Roblox automatically converts those indices to strings.\\n\\nlua title=\\\"Event Connection\\\"\\nlocal ServerScriptService = game:GetService(\\\"ServerScriptService\\\")\\n\\nlocal bindableEvent = ServerScriptService:WaitForChild(\\\"TestBindableEvent\\\")\\n\\nlocal function onEventFire(passedTable)\\n\\tfor k, v in passedTable do\\n\\t\\tprint(typeof(k))  --> string\\n\\tend\\nend\\n\\n-- Connect function to event\\nbindableEvent.Event:Connect(onEventFire)\\n\\nlua title=\\\"Event Firing\\\"\\nlocal ServerScriptService = game:GetService(\\\"ServerScriptService\\\")\\n\\nlocal bindableEvent = ServerScriptService:WaitForChild(\\\"TestBindableEvent\\\")\\n\\n-- Fire event with table containing a workspace instance as a key\\nbindableEvent:Fire({\\n\\t[workspace.Baseplate] = true\\n})\\n\\nTable indexing\\n\\nIf you pass a table of data, do not pass a mixed table of numeric and string keys. Doing so can result in removed elements during the transfer. Instead, pass a table that consists entirely of key-value pairs (a dictionary) or entirely of numeric indices (an array).\\n\\nIn both cases, whether passing a dictionary table or a numerically indexed table, avoid nil values for any index.\\n\\nlua title=\\\"Event Connection\\\"\\nlocal ServerScriptService = game:GetService(\\\"ServerScriptService\\\")\\n\\nlocal bindableEvent = ServerScriptService:WaitForChild(\\\"TestBindableEvent\\\")\\n\\nlocal function onEventFire(passedTable)\\n\\tfor k, v in passedTable do\\n\\t\\tprint(k .. \\\" = \\\" .. v)\\n\\t\\t--> 1 = Sword\\n\\t\\t--> 2 = Bow\\n\\t\\t--> CharName = Diva Dragonslayer\\n\\t\\t--> CharClass = Rogue\\n\\tend\\nend\\n\\n-- Connect function to event\\nbindableEvent.Event:Connect(onEventFire)\\n\\nlua title=\\\"Event Firing\\\"\\nlocal ServerScriptService = game:GetService(\\\"ServerScriptService\\\")\\n\\nlocal bindableEvent = ServerScriptService:WaitForChild(\\\"TestBindableEvent\\\")\\n\\n-- Numerically indexed table\\nlocal inventoryData = {\\n\\t\\\"Sword\\\", \\\"Bow\\\"\\n}\\n-- Dictionary table\\nlocal characterData = {\\n\\tCharName = \\\"Diva Dragonslayer\\\",\\n\\tCharClass = \\\"Rogue\\\"\\n}\\n\\n-- Fire event with consistently-indexed tables\\nbindableEvent:Fire(inventoryData)\\nbindableEvent:Fire(characterData)\\n\\nTable identities\\n\\nTables passed as arguments to bindable events and callbacks are copied, meaning they will not be exactly equivalent to those provided when firing the event or invoking the callback. Nor will tables returned to the invoker be exactly equivalent to those provided. You can demonstrate this by running the following script on a Class.BindableFunction and observing how the table identities differ.\\n\\nlua title=\\\"Callback Connection\\\"\\nlocal ServerScriptService = game:GetService(\\\"ServerScriptService\\\")\\n\\nlocal bindableFunction = ServerScriptService:WaitForChild(\\\"TestBindableFunction\\\")\\n\\n-- Callback function\\nlocal function returnTable(passedTable)\\n\\t-- Output table identity on invocation\\n\\tprint(tostring(passedTable))  --> table: 0x48eb7aead27563d9\\n\\treturn passedTable\\nend\\n\\n-- Set function as bindable function's callback\\nbindableFunction.OnInvoke = returnTable\\n\\nlua title=\\\"Event Invocation\\\"\\nlocal ServerScriptService = game:GetService(\\\"ServerScriptService\\\")\\n\\nlocal bindableFunction = ServerScriptService:WaitForChild(\\\"TestBindableFunction\\\")\\n\\nlocal inventoryData = {\\n\\t\\\"Sword\\\", \\\"Bow\\\"\\n}\\n-- Output original table identity\\nprint(tostring(inventoryData))  --> table: 0x059bcdbb2b576549\\n\\nlocal invokeReturn = bindableFunction:Invoke(inventoryData)\\n\\n-- Output table identity upon return\\nprint(tostring(invokeReturn))  --> table: 0x9fcae7919563a0e9\\n\\nMetatables\\n\\nIf a table has a metatable, all of the metatable information is lost in the transfer. In the following code sample, the NumWheels property is part of the Car metatable. When the server receives the following table, the truck table has the Name property but not the NumWheels property.\\n\\nlua title=\\\"Event Connection\\\"\\nlocal ServerScriptService = game:GetService(\\\"ServerScriptService\\\")\\n\\nlocal bindableEvent = ServerScriptService:WaitForChild(\\\"TestBindableEvent\\\")\\n\\nlocal function onEvent(param)\\n\\tprint(param)  --> {[\\\"Name\\\"] = \\\"MyTruck\\\"}\\nend\\n\\n-- Connect function to event\\nbindableEvent.Event:Connect(onEvent)\\n\\nlua title=\\\"Event Firing\\\"\\nlocal ServerScriptService = game:GetService(\\\"ServerScriptService\\\")\\n\\nlocal bindableEvent = ServerScriptService:WaitForChild(\\\"TestBindableEvent\\\")\\n\\nlocal Car = {}\\nCar.NumWheels = 4\\nCar.index = Car\\n\\nlocal truck = {}\\ntruck.Name = \\\"MyTruck\\\"\\nsetmetatable(truck, Car)\\n\\n-- Fire event with table including a metatable\\nbindableEvent:Fire(truck)\",\n    \"source\": \"bindable.md\"\n}",
    "source": "bindable.json"
}