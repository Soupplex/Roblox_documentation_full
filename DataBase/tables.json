{
    "title": "Tables",
    "description": "Data type which can store multiple values of any non-nil type, including booleans, numbers, strings, functions, and other tables.",
    "content": "The table data type can store multiple values of any type that isn't nil, including booleans, numbers, strings, functions, and other tables. Construct tables with curly braces ({}):\n\nlua\n-- Construct an empty table assigned to variable \"t\"\nlocal t = {}\nprint(t) -- {}\n\nYou can use a table as an array or dictionary. Arrays use an ordered list of numbers as indices, but dictionaries can have numbers, strings, and objects as indices.\n\nFor more information on built-in functions for working with tables, see the Library.table library.\n\nArrays\n\nAn array is an ordered list of values. Arrays are useful for storing collections of data, such as a group of players with special permissions.\n\nCreate arrays\n\nTo create an array using a Luau table, declare the values in sequential order, separated by commas.\n\nlua\n-- Construct an array with three items\nlocal testArray = {\"A string\", 3.14159, true}\nprint(testArray)\n\nRead from arrays\n\nTo read from an array, add a pair of square brackets after its reference and specify the index number of the element inside ([pos]):\n\nlua\n-- Construct an array with three items\nlocal testArray = {\"A string\", 3.14159, true}\n\nprint(testArray[1]) -- A string\nprint(testArray[2]) -- 3.14159\nprint(testArray[3]) -- true\n\nUnlike some languages, Luau uses 1-based indexing for arrays, so the first item in the array is [1], not [0].\n\nWrite to arrays\n\nTo define or rewrite the value of an array at an index, declare the index number in square brackets ([index]) followed by = and the value:\n\nlua\nlocal testArray = {\"A string\", 3.14159, true}\n\ntestArray[2] = 12345\ntestArray[4] = \"New string\"\n\nprint(testArray[2]) --12345\nprint(testArray[4]) -- New string\n\nIterate over arrays\n\nTo iterate over an array, you can use a for loop. Because the arrays have numerical indices, you can also use a numeric for loop from 1 to the length of the array (#array).\n\nlua\nlocal testArray = {\"A string\", 3.14159, true, \"New string\"}\n\n-- Loop using general iteration\nfor index, value in testArray do\n\tprint(index, value)\nend\n\n-- Iterate using the array length operator (#)\nfor index = 1, #testArray do\n\tprint(index, testArray[index])\nend\n\nInsert items\n\nThere are two built-in ways to insert an item to the end of an array:\n\n- Pass a reference to the array and the item value to Luau's Library.table.insert() function.\n- Add the new item to the array using the array[#array+1] syntax.\n\nlua\nlocal testArray = {\"A string\", 3.14159}\n\ntable.insert(testArray, \"New string\")\ntestArray[#testArray+1] = \"Another new string\"\n\nprint(testArray[3]) -- New string\nprint(testArray[4]) -- Another new string\n\nTo insert an item between the start and end of an array, include a position value as the second argument of Library.table.insert(). This inserts the new item and pushes the following items up one index position.\n\nlua\nlocal testArray = {\"First item\", \"Next item\"}\n\ntable.insert(testArray, 2, \"NEW ITEM #2\")\n\nprint(testArray[1]) -- First item\nprint(testArray[2]) -- NEW ITEM #2\nprint(testArray[3]) -- Next item\n\nRemove items\n\nTo remove an item from an array, use Library.table.remove(). This removes the item at the specified position and moves any following items back one index position.\n\nlua\nlocal testArray = {\"First item\", \"Next item\", \"Last item\"}\n\ntable.remove(testArray, 2)\n\nprint(testArray[1]) -- First item\nprint(testArray[2]) -- Last item\n\nDictionaries\n\nDictionaries are an extension of arrays. Dictionaries store a set of key-value pairs, where the keys can be any number, string, or object.\n\nCreate dictionaries\n\nTo create a dictionary table, define each key followed by = and the value. Separate each key-value pair with a comma:\n\nlua\nlocal testDictionary = {\n\tfruitName = \"Lemon\",\n\tfruitColor = \"Yellow\",\n\tsour = true\n}\n\nThe keys for dictionaries can be numbers, strings, and objects. For example, a key may also be an Class.Instance. To use objects as keys, declare the key in square brackets ([key]):\n\nlua\nlocal part = Instance.new(\"Part\")\n\nlocal testDictionary = {\n\tpartType = \"Block\",\n\t[part] = true\n}\n\nRead from dictionaries\n\nTo read from a dictionary, add a pair of brackets after its reference and specify the key name. Directly reference a string key using either ([\"key\"]) or (.key), or instead use a variable value ([key]).\n\nlua\nlocal part = Instance.new(\"Part\")\n\nlocal testDictionary = {\n\tpartType = \"Block\",\n\t[part] = true\n}\n-- Include quotes for string keys\nprint(testDictionary[\"partType\"]) -- Block\n-- Or use . to index string keys without spaces\nprint(testDictionary.partType) -- Block\n-- Omit quotes for non-string keys\nprint(testDictionary[part]) -- true\n\nWrite to dictionaries\n\nTo define or rewrite the value of a new or existing dictionary key, declare the key name in brackets ([key]) or, if the key is a string, use (.key) followed by = and the value:\n\nlua\nlocal testDictionary = {\n\tfruitName = \"Lemon\",\n\tsour = true\n}\n\n-- Change value of existing keys\ntestDictionary[\"fruitName\"] = \"Cherry\"\ntestDictionary.sour = false\n\n-- Insert new key-value pair\ntestDictionary.fruitCount = 10\n\nprint(testDictionary.fruitName) -- Cherry\nprint(testDictionary.sour) -- false\nprint(testDictionary.fruitCount) -- 10\n\nIterate over dictionaries\n\nTo iterate over a dictionary, use a for loop:\n\nlua\nlocal testDictionary = {\n\tfruitName = \"Lemon\",\n\tfruitColor = \"Yellow\",\n\tsour = true\n}\n\nfor key, value in testDictionary do\n\tprint(key, value)\nend\n\n--[[ Resulting output:\nfruitName Lemon\nsour true\nfruitColor Yellow\n]]\n\nRemove key-value pairs\n\nTo remove or erase a key-value pair from a dictionary, set its value for a key to nil.\n\nlua\nlocal testDictionary = {\n\tfruitName = \"Lemon\",\n\tfruitColor = \"Yellow\",\n\tsour = true\n}\n\ntestDictionary.sour = nil\n\nfor key, value in testDictionary do\n\tprint(key, value)\nend\n--[[ Resulting output:\nfruitName Lemon\nfruitColor Yellow\n]]\n\nTables as references\n\nIf you store a table in a new variable, Luau doesn't create a copy of that table. Instead, the variable becomes a reference, or pointer, to the original table. Any reference to a table reflects any changes to the original table:\n\nlua\nlocal originalArray = {10, 20}\n\nlocal arrayReference = originalArray\n\nprint(\"Original:\", originalArray[1], originalArray[2])\nprint(\"Reference:\", arrayReference[1], arrayReference[2])\n\n-- Change values in original array\noriginalArray[1] = 1000\noriginalArray[2] = 2000\n\nprint(\"Reference:\", arrayReference[1], arrayReference[2])\n\n--[[ Resulting output:\nOriginal: 10 20\nReference: 10 20\nReference: 1000 2000\n]]\n\nClone tables\n\nShallow clones\n\nTo copy a table without any nested tables, Luau offers the Library.table.clone() method.\n\nlua\nlocal original = {\n\tkey = \"value\",\n\tengine = \"Roblox\",\n\tplayerID = 505306092\n}\n\nlocal clone = table.clone(original)\n\nDeep clones\n\nTo copy a more complex table with nested tables inside it, you'll need to use a recursive function similar to the following:\n\nlua\n-- The function used for deep cloning a table\nlocal function deepClone(original)\n\t-- Define the new table for the copy\n\tlocal clone = table.clone(original)\n\n\t-- Loop through the original table to check for table values\n\t-- If a table is found as a value, deep clone it to the key (index)\n\tfor key, value in original do\n\t\tif type(value) == \"table\" then\n\t\t\tclone[key] = deepClone(value)\n\t\tend\n\tend\n\n\t-- Return the finalized copy of the deep cloned table\n\treturn clone\nend\n\nWith the function in place, you can make a deep copy as follows:\n\nlua\nlocal original = {\n\tkey = \"value\",\n\tplayerInfo = {\n\t\tplayerID = 505306092,\n\t\tplayerName = \"PlayerName\"\n\t},\n\totherInfo = {\n\t\t{\n\t\t\t{1, 3, 5, 7, 9}\n\t\t}\n\t}\n}\n\nlocal clone = deepClone(original)\n\nFreeze tables\n\nFreezing a table makes it read-only, which is useful for creating constant values that you don't want to change. Freezing is permanent; there's no \"unfreeze\" or \"thaw\" method. To check if a table is frozen, use Library.table.isfrozen().\n\nShallow freezes\n\nTo freeze a table without any nested tables, Luau offers the Library.table.freeze() method.\n\nlua\nlocal target = {\n\tkey = \"value\",\n\tengine = \"Roblox\",\n\tplayerID = 505306092\n}\n\ntable.freeze(target)\ntarget.playerID = 1 --> attempt to modify a readonly table\n\nDeep freezes\n\nTo freeze a more complex table with nested tables inside it, use a recursive function similar to the following:\n\nlua\nlocal function deepFreeze(target)\n\t-- Shallow freeze the table\n\ttable.freeze(target)\n\n\t-- Check each key of the table and freeze it if it's a table\n\tfor , value in target do\n\t\t-- Make sure the value isn't frozen; if it already is, an error will occur\n\t\tif type(value) == \"table\" and table.isfrozen(value) == false then\n\t\t\tdeepFreeze(value)\n\t\tend\n\tend\nend\n\nWith the function in place, you can deep freeze a table as follows:\n\nlua\nlocal target = {\n\tkey = \"value\",\n\tplayerInfo = {\n\t\tplayerID = 505306092,\n\t\tplayerName = \"PlayerName\"\n\t},\n\totherInfo = {\n\t\t{\n\t\t\t{1, 3, 5, 7, 9}\n\t\t}\n\t}\n}\n\ndeepFreeze(target)\ntarget.playerInfo.playerID = 1 --> attempt to modify a readonly table",
    "source": "tables.md"
}