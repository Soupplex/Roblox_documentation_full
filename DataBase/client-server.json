{
    "title": "Client-server runtime",
    "description": "An overview of the client-server model in Roblox.",
    "content": "Server\n\nRoblox experiences are multiplayer by default and run in a client-server model.\nThe Roblox server is the ultimate authority for maintaining the experience's\nstate, and is responsible for keeping all connected clients in sync with the\nserver.\n\n\n  Server with connections to three client devices\n\nClient\n\nWhen an experience runs, Roblox copies a version of the \"edit\" data model that\nyou built and published from Studio and runs it on Roblox servers as the\n\"runtime\" data model.\n\nConnected clients also receive a copy of the runtime data model and any\ninitialization of the player occurs, such as initializing a player's backpack\n(inventory) or local user interface. When an experience has\nClass.Workspace.StreamingEnabled set to true, the server initially only sends\na subset of content under Class.Workspace that is closest to the client. The\nclient then renders the 3D world and begins running any\napplicable scripts.\n\n\n\n\nReplication\n\nThe server constantly updates connected clients, keeping everything in sync\nacross the server and clients through a process called replication, which\nsynchronizes the data model, physics simulation, and chat messages. Replication\nlogic exists on both the client and server to ensure synchronization.\n\nData model changes can occur in a variety of cases, such as when something in the 3D\nworld is created or a property of the 3D world changes. This typically occurs\nwhen a script on the server or client makes a change that needs to be reflected\non the other side of the client-server boundary. The following diagrams show\ncommon scenarios for data replication.\n\nCommunication from any client to the server. For example, a client presses the P key to drink an invisibility potion, and tells the server to make that player's character invisible to all other players.\n\nCommunication from the server to one specific client. For example, a player joins the experience and the server populates that player's inventory with a set of items.\n\nCommunication between the server and all connected clients. For example, displaying a countdown timer to all participants in a race.\n\nRoblox uses a rigid body physics engine, which is responsible for\ncalculating the movement and interactions of parts in the 3D world. By default,\nall parts in Roblox are rigid bodies and participate in simulated physics,\nunless otherwise specified. You can also group multiple parts together into\nassemblies, which the physics engine treats as a single rigid body.\n\n\n\n    1 assembly; 1 part\n\n\n\n    1 assembly; 18 parts\n\n\n\n    1 assembly; 179 parts\n\n\nRoblox replicates physics simulation data between the server and clients when\nnecessary. To assist with simulation performance, Roblox can assign ownership of\nassemblies to a specific client or server. This means that the client or server\ncan be responsible for simulating the physics of that assembly. Other clients\nreceive updates about the assembly's position and movement from the owning\nclient or server. Ownership typically happens automatically, but you can assign\nit directly for fine-tuned responsiveness.\n\n\n  Part ownership indicated through colored outlines\n\nRoblox replicates chat messages between the server and client. The server is\nresponsible for filtering chat messages and deciding which messages to replicate\nto other clients. For example, the server may filter out messages that contain\nprofanity or are too long.\n\nMost players on Roblox experience between 100–300 milliseconds of network latency. Roblox Studio playtesting runs with a default of no latency, but you can change Incoming Replication Lag in the Network section of Studio's settings (AltS on Windows; ⌥S on Mac) to 0.1–0.3 to better simulate how replication latency will affect your experience.",
    "source": "client-server.md"
}